<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>The Google File System总结</title>
      <link href="/2019/04/21/Architeture%20GFS/"/>
      <url>/2019/04/21/Architeture%20GFS/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;做你应该做的&emsp;追你喜欢的<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——xiaomi<br>这篇文章是我阅读<a href="http://nil.csail.mit.edu/6.824/2017/papers/gfs.pdf" target="_blank" rel="noopener">Google File System</a>的论文以及<a href="https://mr-dai.github.io/gfs/" target="_blank" rel="noopener">相关资料</a>并总结而来。当然也是我自己的理解，如有问题请邮件联系<a href="mailto:mee.gaoyang@OutLook.com" target="_blank" rel="noopener">mee.gaoyang@OutLook.com</a> :)</p><h3 id="GFS的主要设计需求"><a href="#GFS的主要设计需求" class="headerlink" title="GFS的主要设计需求"></a>GFS的主要设计需求</h3><p>GFS是应用到Google内部的文件系统，针对于其自身的业务场景需求，设计主要基于以下几个需求：</p><ol><li>节点失效是常态。系统会构建在大量的普通廉价机器上，这使得节点失效的可能性很高。因此，GFS 必须能有较高的容错性、能够持续地监控自身的状态，比如应用程序 bug、操作系统的 bug、人为失误，甚至还有硬盘、内存、连接器、网络以及电源失效等造成的问题。所以，持续的监控、错误侦测、灾难冗余以及自动恢复的机制必须集成在 GFS 中。</li><li>存储内容以大文件为主。系统需要存储的内容在通常情况下由数量不多的大文件构成，每个文件通常有几百 MB 甚至是几 GB 的大小；系统应当支持小文件，但不需要为其做出优化。</li><li>主要负载为大容量连续读、小容量随机读以及追加式的连续写。绝大部分文件的修改是采用在文件尾部追加数据，而不是覆盖原有数据的方式。</li><li>系统应当支持高效且原子的文件追加操作，源于在 Google 的情境中，这些文件多用于生产者-消费者模式或是多路归并。</li><li>当需要做出取舍时，系统应选择高数据吞吐量而不是低延时。  </li></ol><h3 id="GFS-集群组成"><a href="#GFS-集群组成" class="headerlink" title="GFS 集群组成"></a>GFS 集群组成</h3><p>&emsp;&emsp;简单来讲，除了客户端以外，一个 GFS 集群还包括一个 Master 节点和若干个 Chunk Server。它们会作为用户级进程运行在普通的 Linux 机器上。<br>&emsp;&emsp;在存储文件时，GFS 会把文件切分成若干个拥有固定长度的 Chunk（块）并存储。Master 在创建 Chunk 时会为它们赋予一个唯一的 64 位 Handle（句柄），并把它们移交给 Chunk Server，而 Chunk Server 则以Linux系统普通文件的形式将每个 Chunk 存储在自己的本地磁盘上。为了确保 Chunk的可用性，GFS 会把每个 Chunk 备份成若干个 Replica（一般为三个备份）分配到其他 Chunk Server 上。<br>&emsp;&emsp;GFS 的 <strong>Master</strong> 负责维护整个集群的元数据，包括集群的 Namespace（命名空间，即文件元数据）以及 Chunk Lease 管理、无用 Chunk 回收等系统级操作。Chunk Server 除了保存 Chunk 以外也会周期地和 Master 通过心跳信号进行通信，Master 也借此得以收集每个 Chunk Server 当前的状态，并向其发送指令。<br>&emsp;&emsp;鉴于整个集群只有一个 Master，客户端在和 GFS 集群通信时，首先会从 Master 处获取 GFS 的元数据，而实际文件的数据传输则会与 Chunk Server 直接进行，以避免 Master 成为整个系统的数据传输瓶颈；除此以外，客户端也会在一定时间内缓存 Master 返回的集群元数据。</p><h3 id="GFS的元数据"><a href="#GFS的元数据" class="headerlink" title="GFS的元数据"></a>GFS的元数据</h3><p>&emsp;&emsp;GFS 集群的所有元数据都会保存在 Master 的内存中。鉴于整个集群只会有一个 Master，这也使得元数据的管理变得更为简单。GFS 集群的元数据主要包括以下三类信息：</p><ol><li>文件与 Chunk 的 Namespace</li><li>文件与 Chunk 之间的映射关系</li><li>每个 Chunk Replica 所在的位置</li></ol><p>&emsp;&emsp;元数据保存在 Master 的内存中使得 Master 要对元数据做出变更变得极为容易；同时，这也使得 Master 能够更加高效地扫描集群的元数据，以唤起 Chunk 回收、Chunk 均衡等系统级管理操作。唯一的不足在于这使得整个集群所能拥有的 Chunk 数量受限于 Master 的内存大小，不过从论文的内容来看，这样的瓶颈在 Google 中从来没有被触及过，源于对于一个 64MB 大小的 Chunk，Master 只需要维持不到 64 字节的元数据。况且，相比于增加代码的复杂度，提高 Master 内存容量的成本要小得多。<br>&emsp;&emsp;为了保证元数据的可用性，Master 在对元数据做任何操作前对会用先写日志的形式将操作进行记录，日志写入完成后再进行实际操作，而这些日志也会被备份到多个机器上进行保存。不过，Chunk Replica 的位置不会被持久化到日志中，而是由 Master 在启动时询问各个 Chunk Server 其当前所有的 Replica。这可以省去 Master 与 Chunk Server 同步数据的成本，同时进一步简化 Master 日志持久化的工作。这样的设计也是合情合理的，毕竟 Chunk Server 当前实际持有哪些 Replica 也应由 Chunk Server 自己说了算。  </p><h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><p>&emsp;&emsp;用户在使用 GFS 这类数据存储系统时，首先应当了解其所能提供的数据一致性，而作为学习者我们也应先理解 GFS 对外呈现的数据一致性功能。<br>&emsp;&emsp;首先，命名空间完全由单节点 Master 管理在其内存中，这部分数据的修改可以通过让 Master 为其添加互斥锁来解决并发修改的问题，&emsp;&emsp;因此命名空间的数据修改是可以确保完全原子的。<br>文件的数据修改则相对复杂。在讲述接下来的内容前，首先我们先明确，在文件的某一部分被修改后，它可能进入以下三种状态的其中之一：  </p><ol><li>客户端读取不同的 Replica 时可能会读取到不同的内容，那这部分文件是不一致的（Inconsistent）</li><li>所有客户端无论读取哪个 Replica 都会读取到相同的内容，那这部分文件就是一致的（Consistent）</li><li>所有客户端都能看到上一次修改的所有完整内容，且这部分文件是一致的，那么我们说这部分文件是确定的（Defined）  </li></ol><p>&emsp;&emsp;在修改后，一个文件的当前状态将取决于此次修改的类型以及修改是否成功。具体来说：   </p><ul><li>如果一次写入操作成功且没有与其他并发的写入操作发生重叠，那这部分的文件是确定的（同时也是一致的）</li><li>如果有若干个写入操作并发地执行成功，那么这部分文件会是一致的但会是不确定的：在这种情况下，客户端所能看到的数据通常不能直接体现出其中的任何一次修改</li><li>失败的写入操作会让文件进入不一致的状态</li></ul><p>这之间的关系也被整理为了论文中的表格 1：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/GFS_consistency-model.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>   </p><p>&emsp;&emsp;GFS 支持的文件数据修改数据包括两种：指定偏移值的数据写入（Write）以及数据追加（Record Append）。当写入时，指定的数据会被直接写入到客户端指定的偏移位置中，覆盖原有的数据。GFS 并未为该操作提供太多的一致性保证：如果不同的客户端并发地写入同一块文件区域，操作完成后这块区域的数据可能由各次写入的数据碎片所组成，即进入不确定的状态。<br>&emsp;&emsp;与写入操作不同，GFS 确保即便是在并发时，数据追加操作也是原子且 at least once（至少一次）的。操作完成后，GFS 会把实际写入的偏移值返回给客户端，该偏移值即代表包含所写入数据的确定的文件区域的起始位置。由于数据追加操作是 at least once 的，GFS 有可能会在文件中写入填充（padding）或是重复数据，但出现的概率不高。<br>&emsp;&emsp;在读取数据时，为了避免读入填充数据或是损坏的数据，数据在写入前往往会放入一些如校验和等元信息以用于验证其可用性，如此一来 GFS 的客户端 library 便可以在读取时自动跳过填充和损坏的数据。不过，鉴于数据追加操作的 at lease once 特性，客户端仍有可能读入重复的数据，此时只能由上层应用通过鉴别记录的唯一 ID 等信息来过滤重复数据了。  </p><h3 id="对应用的影响"><a href="#对应用的影响" class="headerlink" title="对应用的影响"></a>对应用的影响</h3><p>&emsp;&emsp;GFS 的一致性模型是相对松散的，这就要求上层应用在使用 GFS 时能够适应 GFS 所提供的一致性语义。简单来讲，上层应用可以通过两种方式来做到这一点：更多使用追加操作而不是覆写操作；写入包含校验信息的数据。<br>&emsp;&emsp;青睐追加操作而不是覆写操作的原因是明显的：GFS 针对追加操作做出了显著的优化，这使得这种数据写入方式的性能更高，而且也能提供更强的一致性语义。尽管如此，追加操作 at least once 的特性仍使得客户端可能读取到填充或是重复数据，这要求客户端能够容忍这部分无效数据。一种可行的做法是在写入的同时为所有记录写入各自的校验和，并在读取时进行校验，以剔除无效的数据；如果客户端无法容忍重复数据，客户端也可以在写入时为每条记录写入唯一的标识符，以便在读取时通过标识符去除重复的数据。</p><h3 id="GFS-集群常见操作流程"><a href="#GFS-集群常见操作流程" class="headerlink" title="GFS 集群常见操作流程"></a>GFS 集群常见操作流程</h3><h4 id="Master-Namespace-管理"><a href="#Master-Namespace-管理" class="headerlink" title="Master Namespace 管理"></a>Master Namespace 管理</h4><p>&emsp;&emsp;在前面我们已经了解到，Namespace 作为 GFS 元信息的一部分会被维持在 Master 的内存中，由 Master 负责管理。在逻辑上，GFS Master 并不会根据文件与目录的关系以分层的结构来管理这部分数据，而是单纯地将其表示为从完整路径名到对应文件元数据的映射表，并在路径名上应用前缀压缩以减少内存占用。<br>&emsp;&emsp;为了管理来自不同客户端的并发请求对 Namespace 的修改，Master 会为 Namespace 中的每个文件和目录都分配一个读写锁（Read-Write Lock）。由此，对不同 Namespace 区域的并发请求便可以同时进行。<br>&emsp;&emsp;所有 Master 操作在执行前都会需要先获取一系列的锁：通常，当操作涉及某个路径 /d1/d2/…/dn/leaf 时，Master 会需要先获取从 /d1、/d1/d2 到 /d1/d2/…/dn 的读锁，然后再根据操作的类型获取 /d1/d2/…/dn/lead 的读锁或写锁 —— 获取父目录的读锁是为了避免父目录在此次操作执行的过程中被重命名或删除。<br>&emsp;&emsp;由于大量的读写锁可能会造成较高的内存占用，这些锁会在实际需要时才进行创建，并在不再需要时被销毁。除外，所有的锁获取操作也会按照一个相同的顺序进行，以避免发生死锁：锁首先按 Namespace 树的层级排列，同一层级内则以路径名字典序排列。   </p><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><p>&emsp;&emsp;客户端从 GFS 集群中读取文件内容的过程大致如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/gfs-architecture.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>   </p><ol><li>对于指定的文件名和读取位置偏移值，客户端可以根据固定的 Chunk 大小来计算出该位置在该文件的哪一个 Chunk 中</li><li>客户端向 Master 发出请求，其中包含要读取的文件名以及 Chunk 索引值</li><li>Master 向客户端响应该 Chunk 的 Handle 以及其所有 Replica 当前所在的位置。客户端会以文件名和 Chunk 索引值为键缓存该数据</li><li>之后，客户端便可以选取其中一个 Replica 所在的 Chunk Server 并向其发起请求，请求中会指定需要读取的 Chunk 的 Handle 以及要读取的范围<br>Chunk Lease<br>在客户端对某个 Chunk 做出修改时，GFS 为了能够处理不同的并发修改，会把该 Chunk 的 Lease 交给某个 Replica，使其成为 Primary：Primary 会负责为这些修改安排一个执行顺序，然后其他 Replica 便按照相同的顺序执行这些修改。  </li></ol><h5 id="Chunk-Lease"><a href="#Chunk-Lease" class="headerlink" title="Chunk Lease"></a>Chunk Lease</h5><p>&emsp;&emsp;在初始时会有 60 秒的超时时间。在未超时前，Primary 可以向 Master 申请延长 Chunk Lease 的时间；必要时 Master 也可以直接撤回已分配的 Chunk Lease。  </p><h4 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h4><p>&emsp;&emsp;客户端尝试将数据写入到某个 Chunk 的指定位置的过程大致如下：<br><img src="/images/gfs-write.png" alt="">  </p><ol><li>客户端向 Master 询问目前哪个 Chunk Server 持有该 Chunk 的 Lease</li><li>Master 向客户端返回 Primary 和其他 Replica 的位置</li><li>客户端将数据推送到所有的 Replica 上。Chunk Server 会把这些数据保存在缓冲区中，等待使用</li><li>待所有 Replica 都接收到数据后，客户端发送写请求给 Primary。Primary 为来自各个客户端的修改操作安排连续的执行序列号，并按顺序地应用于其本地存储的数据</li><li>Primary 将写请求转发给其他 Secondary Replica，Replica 们按照相同的顺序应用这些修改</li><li>Secondary Replica 响应 Primary，示意自己已经完成操作</li><li>Primary 响应客户端，并返回该过程中发生的错误（若有）<br>&emsp;&emsp;如果该过程有发生错误，可以认为修改已在 Primary 和部分 Secondary 上成功执行（如果在 Primary 上就出错了，那么写请求不会被转发出去）。此时可以认为此次修改操作没有成功，因为数据会处于不一致的状态。实际上，GFS 所使用的客户端 lib 在此时会重新尝试执行此次操作。<br>&emsp;&emsp;值得注意的是，这个流程特意将数据流与控制流分开：客户端先向 Chunk Server 提交数据，再将写请求发往 Primary。这么做的好处在于 GFS 能够更好地利用网络带宽资源。<br>&emsp;&emsp;从上述步骤可见，控制流借由写请求从客户端流向 Primary，再流向其他 Secondary Replica。实际上，数据流以一条线性数据管道进行传递的：客户端会把数据上传到离自己最近的 Replica，该 Replica 在接收到数据后再转发给离自己最近的另一个 Replica，如此递归直到所有 Replica 都能接收到数据，如此一来便能够利用上每台机器的所有出口带宽。  </li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式架构 </tag>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收（下）（回收器比较）</title>
      <link href="/2019/04/18/JVM%20GC_3/"/>
      <url>/2019/04/18/JVM%20GC_3/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;我个人认为应该把注意力放在前两篇文章中，例如 <strong>寻找失活对象的方法、安全点的建立、分代回收的思想、Thread Local Allocation Buffer、卡表。</strong> 所以本篇主要记录了各种各种收集器的使用场景与他们的比较。更详细的描绘可浏览Oracle的官方说明：<a href="https://blogs.oracle.com/jonthecollector/our-collectors" target="_blank" rel="noopener">https://blogs.oracle.com/jonthecollector/our-collectors</a>     </p><p><img src="/images/JVM_GCCollections.jpg" alt="Alt text"><br>&emsp;&emsp;<strong>上图中的 ‘?’ 就是目前的G1回收器。</strong><br>&emsp;&emsp;针对新生代的垃圾回收器共有三个：Serial，Parallel Scavenge 和 Parallel New。这三个采用的都是 <strong>标记 - 复制</strong> 算法。其中，Serial 是一个单线程的，Parallel New 可以看成 Serial 的多线程版本。Parallel Scavenge 和 Parallel New 类似，但更加注重吞吐率。此外，Parallel Scavenge 不能与 CMS 一起使用。<br>&emsp;&emsp;针对老年代的垃圾回收器也有三个：Serial Old 和 Parallel Old，以及 CMS。Serial Old 和 Parallel Old 都是 <strong>标记 - 压缩</strong> 算法。同样，前者是单线程的，而后者可以看成前者的多线程版本。  </p><p>&emsp;&emsp;CMS 采用的是标记 - 清除算法，并且是并发的。除了少数几个操作需要 Stop-the-world 之外，它可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，Java 虚拟机会使用其他两个压缩型垃圾回收器进行一次垃圾回收。由于 G1 的出现，CMS 在 Java 9 中已被废弃 [1]。</p><p>&emsp;&emsp;G1（Garbage First）是一个横跨新生代和老年代的垃圾回收器。实际上，它已经打乱了前面所说的堆结构，直接将堆分成极其多个区域。每个区域都可以充当 Eden 区、Survivor 区或者老年代中的一个。它采用的是标记 - 压缩算法，而且和 CMS 一样都能够在应用程序运行过程中并发地进行垃圾回收。   </p><p>&emsp;&emsp;G1 能够针对每个细分的区域来进行垃圾回收。在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。这也是 G1 名字的由来。</p><p>&emsp;&emsp;即将到来的 Java 11 引入了 ZGC，宣称暂停时间不超过 10ms。如果感兴趣的话，可参考 R 大的这篇文章 [2]。</p><h3 id="参考Blog"><a href="#参考Blog" class="headerlink" title="参考Blog"></a>参考Blog</h3><p>[1]<a href="http://openjdk.java.net/jeps/291" target="_blank" rel="noopener">http://openjdk.java.net/jeps/291</a><br>[2]<a href="https://www.zhihu.com/question/287945354/answer/458761494" target="_blank" rel="noopener">https://www.zhihu.com/question/287945354/answer/458761494</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收（中）</title>
      <link href="/2019/04/16/JVM%20GC_2/"/>
      <url>/2019/04/16/JVM%20GC_2/</url>
      
        <content type="html"><![CDATA[<p>繁华声 遁入空门 折煞了世人<br>梦偏冷 辗转一生 情债又几本<br>如你默认 生死枯等<br>枯等一圈 又一圈的 年轮<br>浮屠塔 断了几层 断了谁的魂<br>痛直奔 一盏残灯 倾塌的山门<br>容我再等 历史转身<br>等酒香醇 等你弹 一曲古筝<br>雨纷纷 旧故里草木深<br>我听闻 你始终一个人<br>斑驳的城门 盘踞着老树根<br>石板上回荡的是 再等<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——方文山</p><p>&emsp;&emsp;烟花易冷，珍惜当下。大部分的 Java 对象只存活一小段时间，而存活下来的小部分 Java 对象则会存活很长一段时间。下图（Java 对象生命周期的直方图，红色的表示被逃逸分析优化掉的对象）是一些研究者对Java对象生命周期的动态分析的结果。<br><img src="/images/JVM_GC.png" alt="Alt text"><br>&emsp;&emsp;Java 虚拟机的分代回收思想。简单来说，就是将堆空间划分为两代，分别叫做新生代和老年代。新生代用来存储新建的对象。当对象存活时间够长时，则将其移动到老年代。<br>&emsp;&emsp;Java 虚拟机可以给不同代使用不同的回收算法。对于 <strong>于新生代</strong>，我们猜测大部分的 Java 对象只存活一小段时间，那么便可以频繁地采用耗时较短的垃圾回收算法，让大部分的垃圾都能够在新生代被回收掉。<br>&emsp;&emsp;对于 <strong>老年代</strong>，我们猜测大部分的垃圾已经在新生代中被回收了，而在老年代中的对象有大概率会继续存活。当真正触发针对老年代的回收时，则代表这个假设出错了，或者堆的空间已经耗尽了。<br>&emsp;&emsp;这时候，Java 虚拟机往往需要做一次全堆扫描，耗时也将不计成本。（当然，现代的垃圾回收器都在并发收集的道路上发展，来避免这种全堆扫描的情况。）<br>&emsp;&emsp;本文我们会首先关注一下针对新生代的 Minor GC。以下我们先探讨下Java 虚拟机中的堆具体是咋划分的。  </p><h3 id="Java-虚拟机的堆划分"><a href="#Java-虚拟机的堆划分" class="headerlink" title="Java 虚拟机的堆划分"></a>Java 虚拟机的堆划分</h3><p>&emsp;&emsp;众所周知，Java 虚拟机将堆划分为新生代和老年代。其中，新生代又被划分为 Eden 区，以及两个大小相同的 Survivor 区。<br>&emsp;&emsp;默认情况下，Java 虚拟机采取的是一种动态分配的策略（对应 Java 虚拟机参数 <strong>-XX:+UsePSAdaptiveSurvivorSizePolicy</strong>），根据生成对象的速率，以及 Survivor 区的使用情况动态调整 Eden 区和 Survivor 区的比例。<br>&emsp;&emsp;当然，我们也可以通过参数 <strong>-XX:SurvivorRatio</strong> 来固定这个比例。但是需要注意的是，其中一个 Survivor 区会一直为空，因此比例越低浪费的堆空间将越高。<br><img src="/images/JVM_GCFromTo.png" alt="Alt text"><br>&emsp;&emsp;通常来说，当我们调用 new 指令时，它会在 Eden 区中划出一块作为存储对象的内存。由于堆空间是线程共享的，因此直接在这里边划空间是需要进行同步的。<br>&emsp;&emsp;否则，将有可能出现两个对象共用一段内存的事故。这里就相当于两个司机（线程）同时将车停入同一个停车位，因而发生剐蹭事故。<br>&emsp;&emsp;Java 虚拟机的解决方法是为每个司机预先申请多个停车位，并且只允许该司机停在自己的停车位上。那么当司机的停车位用完了该怎么办呢（假设这个司机代客泊车）？<br>&emsp;&emsp;答案是：再申请多个停车位便可以了。这项技术被称之为 TLAB（Thread Local Allocation Buffer，对应虚拟机参数 -XX:+UseTLAB，默认开启）。<br>&emsp;&emsp;具体来说，每个线程可以向 Java 虚拟机申请一段连续的内存，比如 2048 字节，作为线程私有的 TLAB。<br>&emsp;&emsp;这个操作需要加锁，线程需要维护两个指针（实际上可能更多，但重要也就两个），一个指向 TLAB 中空余内存的起始位置，一个则指向 TLAB 末尾。<br>&emsp;&emsp;接下来的 new 指令，便可以直接通过指针加法（bump the pointer）来实现，即把指向空余内存位置的指针加上所请求的字节数。   </p><blockquote><p>至于什么不把 bump the pointer 翻译成指针碰撞。是因为在英语中我们通常省略了 bump up the pointer 中的 up。在这个上下文中 bump 的含义应为“提高”。另外一个例子是当我们发布软件的新版本时，也会说 bump the version number。  </p></blockquote><p>&emsp;&emsp;如果加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。否则，TLAB 已经没有足够的空间来满足本次新建操作。这个时候，便需要当前线程重新申请新的 TLAB。<br>&emsp;&emsp;当 Eden 区的空间耗尽了怎么办？这个时候 Java 虚拟机便会触发一次 Minor GC，来收集新生代的垃圾。存活下来的对象，则会被送到 Survivor 区。<br>&emsp;&emsp;前面提到，新生代共有两个 Survivor 区，我们分别用 from 和 to 来指代。其中 to 指向的 Survivior 区是空的。<br>&emsp;&emsp;<strong>当发生 Minor GC 时，Eden 区和 from 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。</strong><br>&emsp;&emsp;Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 -<strong>XX:+MaxTenuringThreshold</strong>），那么该对象将被晋升（promote）至老年代。另外，如果单个 Survivor 区已经被占用了 50%（对应虚拟机参数 <strong>-XX:TargetSurvivorRatio</strong>），那么较高复制次数的对象也会被晋升至老年代。<br>&emsp;&emsp;总而言之，当发生 Minor GC 时，我们应用了 <strong>标记 - 复制 (copy)</strong> 算法，将 Survivor 区中的老存活对象晋升到老年代，然后将剩下的存活对象和 Eden 区的存活对象复制到另一个 Survivor 区中。<strong>理想情况下，Eden 区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种标记 - 复制算法的效果极好。</strong><br>&emsp;&emsp;Minor GC 的另外一个好处是不用对整个堆进行垃圾回收。但是，它却有一个问题，那就是 <strong>老年代的对象可能引用新生代的对象</strong>。也就是说，在标记存活对象的时候，我们需要扫描老年代中的对象。如果该对象拥有对新生代对象的引用，那么这个引用也会被作为 GC Roots。<br>&emsp;&emsp;这样一来，岂不是又做了一次全堆扫描呢？   </p><h4 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h4><p>&emsp;&emsp;HotSpot 给出的解决方案是一项叫做卡表（Card Table）的技术。该技术 <strong>将整个堆划分为一个个大小为 512 字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。</strong> 这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。<br>&emsp;&emsp;在进行 Minor GC 的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。<br>&emsp;&emsp;由于 Minor GC 伴随着存活对象的复制，而复制需要更新指向该对象的引用。因此，在更新引用的同时，我们又会设置引用所在的卡的标识位。这个时候，我们可以确保脏卡中必定包含指向新生代对象的引用。<br>&emsp;&emsp;在 Minor GC 之前，我们并不能确保脏卡中包含指向新生代对象的引用。其原因和如何设置卡的标识位有关。首先，如果想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么 Java 虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。这个操作在解释执行器中比较容易实现。但是在即时编译器生成的机器码中，则需要插入额外的逻辑。这也就是所谓的写屏障（ <strong>write barrier，注意不要和 volatile 字段的写屏障混淆</strong>）。<br>&emsp;&emsp;写屏障需要尽可能地保持简洁。这是因为我们并不希望在每条引用型实例变量的写指令后跟着一大串注入的指令。<br>&emsp;&emsp;因此，写屏障并不会判断更新后的引用是否指向新生代中的对象，而是宁可错杀，不可放过，一律当成可能指向新生代对象的引用。<br>&emsp;&emsp;这么一来，写屏障便可精简为下面的伪代码。这里右移 9 位相当于除以 512，Java 虚拟机便是通过这种方式来从地址映射到卡表中的索引的。最终，这段代码会被编译成一条移位指令和一条存储指令。</p><pre class="line-numbers language-java"><code class="language-java">CARD_TABLE <span class="token punctuation">[</span><span class="token keyword">this</span> address <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> DIRTY<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&emsp;&emsp;虽然写屏障不可避免地带来一些开销，但是它能够加大 Minor GC 的　<strong>吞吐率（ 应用运行时间 /(应用运行时间 + 垃圾回收时间) ）</strong>。总的来说还是值得的。不过，在高并发环境下，写屏障又带来了 <strong>虚共享（false sharing）</strong> 问题。<br>&emsp;&emsp;在对象内存布局中遇到的虚共享问题，讲的是几个 volatile 字段出现在同一缓存行里造成的虚共享。这里的虚共享则是卡表中不同卡的标识位之间的虚共享问题。<br>&emsp;&emsp;在 HotSpot 中，卡表是通过 byte 数组来实现的。对于一个 64 字节的缓存行来说，如果用它来加载部分卡表，那么它将对应 64 张卡，也就是 32KB 的内存。<br>&emsp;&emsp;如果同时有两个 Java 线程，在这 32KB 内存中进行引用更新操作，那么也将造成存储卡表的同一部分的缓存行的写回、无效化或者同步操作，因而间接影响程序性能。<br>&emsp;&emsp;为此，HotSpot 引入了一个新的参数 <strong>-XX:+UseCondCardMark</strong>，来尽量减少写卡表的操作。其伪代码如下所示：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>CARD_TABLE <span class="token punctuation">[</span><span class="token keyword">this</span> address <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">!=</span> DIRTY<span class="token punctuation">)</span>CARD_TABLE <span class="token punctuation">[</span><span class="token keyword">this</span> address <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> DIRTY<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;本文介绍了 Java 虚拟机中垃圾回收具体实现的一些通用知识。<br>&emsp;&emsp;Java 虚拟机将堆分为新生代和老年代，并且对不同代采用不同的垃圾回收算法。其中，新生代分为 Eden 区和两个大小一致的 Survivor 区，并且其中一个 Survivor 区是空的。<br>&emsp;&emsp;在只针对新生代的 Minor GC 中，Eden 区和非空 Survivor 区的存活对象会被复制到空的 Survivor 区中，当 Survivor 区中的存活对象复制次数超过一定数值时，它将被晋升至老年代。<br>&emsp;&emsp;因为 Minor GC 只针对新生代进行垃圾回收，所以在枚举 GC Roots 的时候，它需要考虑从老年代到新生代的引用。为了避免扫描整个老年代，Java 虚拟机引入了名为卡表的技术，大致地标出可能存在老年代到新生代引用的内存区域。  </p><p>Java 虚拟机的分代垃圾回收是基于大部分对象只存活一小段时间，小部分对象却存活一大段时间的假设的。<br>然而，现实情况中并非每个程序都符合前面提到的假设。如果一个程序拥有中等生命周期的对象，并且刚移动到老年代便不再使用，那么将给默认的垃圾回收策略造成极大的麻烦。</p><ul><li>JVM分代收集新生代对象进入老年代，年龄为是15是因为HotSpot会在对象头中的标记字段里记录年龄，分配到的空间只有4位，最多只能记录到15。    </li><li>堆内存分代后，会根据他们的不同特点来区别对待，进行垃圾回收的时候会使用不同的垃圾回收方式，针对新生代的垃圾回收器有如下三个：Serial、Parallel Scavenge、Parallel New，他们采用的都是标记-复制的垃圾回收算法。</li><li>针对老年代的垃圾回收器有如下三个：Serial Old 、Parallel Old 、CMS，他们使用的都是标记-压缩的垃圾回收算法。</li><li>TLAB（Thread Local Allocation Buffer）-这个技术是用于解决多线程竞争堆内存分配问题的，核心原理是对分配一些连续的内存空间。  </li><li>卡表是为了处理minor gc时老年代对新生代的引用，为了避免整堆扫描而提出了卡表的概念。</li></ul><p>如有问题，我们可以邮件联系：<a href="mailto:mee.gaoyang@OutLook.com" target="_blank" rel="noopener">mee.gaoyang@OutLook.com</a>  :)</p><h3 id="参考Blog"><a href="#参考Blog" class="headerlink" title="参考Blog"></a>参考Blog</h3><p>[1]<a href="https://blogs.oracle.com/dave/false-sharing-induced-by-card-table-marking" target="_blank" rel="noopener">https://blogs.oracle.com/dave/false-sharing-induced-by-card-table-marking</a>  </p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收(上)</title>
      <link href="/2019/04/15/JVM%20GC_1/"/>
      <url>/2019/04/15/JVM%20GC_1/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;茨威格在为路易十六的妻子玛丽·安托瓦内特写传记时曾无比感慨  <strong>“她那时候还太年轻，不知道所有命运馈赠的礼物，早已在暗中标好了价格”</strong>。<br>&emsp;&emsp;JVM的内存管理，将原本由开发人员手动管理的内存，交给垃圾回收器来自动的回收管理。虽然极大的减轻了开发者的负担，但既然是自定机制，肯定不会像手动回收那样精准，同时还带来了不少与垃圾回收相关的问题。  </p><h3 id="引用计数法与可达性分析"><a href="#引用计数法与可达性分析" class="headerlink" title="引用计数法与可达性分析"></a>引用计数法与可达性分析</h3><p>&emsp;&emsp;垃圾回收，顾名思义，便是将已经分配出去的，但却不再使用的内存回收回来，以便能够再次分配。<strong>在 Java 虚拟机的语境下，垃圾指的是死亡的对象所占据的堆空间。这里便涉及了一个关键的问题：如何辨别一个对象是存是亡？</strong><br>&emsp;&emsp;有一种古老的辨别方法：引用计数法（reference counting）。它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。<br>&emsp;&emsp;它的具体实现是这样子的：如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。也就是说，我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。<br>&emsp;&emsp;除了需要额外的空间来存储计数器，以及繁琐的更新操作，引用计数法还有一个重大的漏洞，那便是无法处理循环引用对象。<br>&emsp;&emsp;举个例子，假设对象 a 与 b 相互引用，除此之外没有其他引用指向 a 或者 b。在这种情况下，a 和 b 实际上已经死了，但由于它们的引用计数器皆不为 0，在引用计数法的心中，这两个对象还活着。因此，这些循环引用对象所占据的空间将不可回收，从而造成了内存泄露。<br>&emsp;&emsp;目前 Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。<br>&emsp;&emsp;那么什么是 GC Roots 呢？我们可以暂时理解为由堆外指向堆内的引用，一般而言，GC Roots 包括（但不限于）如下几种：  </p><ol><li>Java 方法栈桢中的局部变量；</li><li>已加载类的静态变量；</li><li>JNI handles；</li><li>已启动且未停止的 Java 线程。  </li></ol><p>&emsp;&emsp;可达性分析可以解决引用计数法所不能解决的循环引用问题。举例来说，即便对象 a 和 b 相互引用，只要从 GC Roots 出发无法到达 a 或者 b，那么可达性分析便不会将它们加入存活对象合集之中。虽然可达性分析的算法本身很简明，但是在实践中还是有不少其他问题需要解决的。比如说，在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）。误报并没有什么伤害，Java 虚拟机至多损失了部分垃圾回收的机会。漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 Java 虚拟机崩溃。  </p><h3 id="Stop-the-world-以及安全点"><a href="#Stop-the-world-以及安全点" class="headerlink" title="Stop-the-world 以及安全点"></a>Stop-the-world 以及安全点</h3><p>&emsp;&emsp;如何解决上面提到的漏报问题呢？在 Java 虚拟机里，传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是 Stop-the-world，停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了垃圾回收所谓的暂停时间（GC pause）。<br>&emsp;&emsp;Java 虚拟机中的 Stop-the-world 是通过安全点（safepoint）机制来实现的。当 Java 虚拟机收到 Stop-the-world 请求，它便会等待所有的线程都到达安全点，才允许请求 Stop-the-world 的线程进行独占的工作。<br>&emsp;&emsp;当然，安全点的初始目的并不是让其他线程停下，而是 <strong>找到一个稳定的执行状态</strong>。在这个执行状态下，Java 虚拟机的堆栈不会发生变化。这么一来，垃圾回收器便能够“安全”地执行可达性分析。<br>&emsp;&emsp;举个例子，当 Java 程序通过 JNI 执行本地代码时，如果这段代码不访问 Java 对象、调用 Java 方法或者返回至原 Java 方法，那么 Java 虚拟机的堆栈不会发生改变，也就代表着这段本地代码可以作为同一个安全点。<br>&emsp;&emsp;只要不离开这个安全点，Java 虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。<br>&emsp;&emsp;由于本地代码需要通过 JNI 的 API 来完成上述三个操作，因此 Java 虚拟机仅需在 API 的入口处进行安全点检测（safepoint poll），测试是否有其他线程请求停留在安全点里，便可以在必要的时候挂起当前线程。<br>&emsp;&emsp;除了执行 JNI 本地代码外，Java 线程还有其他几种状态：<strong>解释执行字节码、执行即时编译器生成的机器码和线程阻塞</strong>。阻塞的线程由于处于 Java 虚拟机线程调度器的掌控之下，因此属于安全点。<br>&emsp;&emsp;其他几种状态则是运行状态，需要虚拟机保证在可预见的时间内进入安全点。否则，垃圾回收线程可能长期处于等待所有线程进入安全点的状态，从而变相地提高了垃圾回收的暂停时间。<br>&emsp;&emsp;对于解释执行来说，字节码与字节码之间皆可作为安全点。Java 虚拟机采取的做法是，当有安全点请求时，执行一条字节码便进行一次安全点检测。<br>&emsp;&emsp;执行即时编译器生成的机器码则比较复杂。由于这些代码直接运行在底层硬件之上，不受 Java 虚拟机掌控，因此在生成机器码时，即时编译器需要插入安全点检测，以避免机器码长时间没有安全点检测的情况。HotSpot 虚拟机的做法便是在生成代码的方法出口以及非计数循环的循环回边（back-edge）处插入安全点检测。<br>&emsp;&emsp;那么为什么不在每一条机器码或者每一个机器码基本块处插入安全点检测呢？原因主要有两个。<br>&emsp;&emsp;第一，安全点检测本身也有一定的开销。不过 HotSpot 虚拟机已经将机器码中安全点检测简化为一个内存访问操作。在有安全点请求的情况下，Java 虚拟机会将安全点检测访问的内存所在的页设置为不可读，并且定义一个 segfault 处理器，来截获因访问该不可读内存而触发 segfault 的线程，并将它们挂起。<br>&emsp;&emsp;第二，即时编译器生成的机器码打乱了原本栈桢上的对象分布状况。在进入安全点时，机器码还需提供一些额外的信息，来表明哪些寄存器，或者当前栈帧上的哪些内存空间存放着指向对象的引用，以便垃圾回收器能够枚举 GC Roots。<br>&emsp;&emsp;由于这些信息需要不少空间来存储，因此即时编译器会尽量避免过多的安全点检测。不过，不同的即时编译器插入安全点检测的位置也可能不同。以 Graal 为例，除了上述位置外，它还会在计数循环的循环回边处插入安全点检测。其他的虚拟机也可能选取方法入口而非方法出口来插入安全点检测。<br>&emsp;&emsp;不管如何，其目的都是在可接受的性能开销以及内存开销之内，避免机器码长时间不进入安全点的情况，间接地减少垃圾回收的暂停时间。<br>&emsp;&emsp;除了垃圾回收之外，Java 虚拟机其他一些对堆栈内容的一致性有要求的操作也会用到安全点这一机制。  </p><h3 id="垃圾回收的三种方式"><a href="#垃圾回收的三种方式" class="headerlink" title="垃圾回收的三种方式"></a>垃圾回收的三种方式</h3><p>&emsp;&emsp;当标记完所有的存活对象时，我们便可以进行死亡对象的回收工作了。主流的基础回收方式可分为三种。<br>&emsp;&emsp;第一种是 <strong>标记-清除（Mark-Sweep）</strong>，即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。清除这种回收方式的原理及其简单，但是有两个缺点。<strong>一是会造成内存碎片。由于 Java 虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。另一个则是分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java 虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。</strong><br>&emsp;&emsp;第二种是<strong>标记-整理（Mark——Compact）</strong> （压缩compact）[根据老年代的特点设计]，即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。<br>&emsp;&emsp;第三种则是<strong>复制（copy）</strong> ，即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。<strong>现代虚拟机均使用copy算法来回收新生代，一块Eden两块Survivor，回收时将Eden与一块Survivor中存活的对象全部复制到另一块Survivor中，然后清空Eden与刚用过的Survivor，HotSpot默认Eden与一块Survivor大小比为8：1，当然我们不能假定每次存活的对象都不到10%，一般为2%，如果超过10%则需要依赖其它内存（老年代）进行分配担保（将对象通过分配担保机制直接进入到老年代）。</strong><br>&emsp;&emsp;当然，现代的垃圾回收器往往会综合上述几种回收方式，综合它们优点的同时规避它们的缺点。在下一篇中我们会详细介绍 Java 虚拟机中垃圾回收算法的具体实现。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM类加载机制</title>
      <link href="/2019/04/12/JVM%20ClassLoader/"/>
      <url>/2019/04/12/JVM%20ClassLoader/</url>
      
        <content type="html"><![CDATA[<ul><li>从大的方面讲，类加载的结果是把一段字节流变换成Class结构并写方法区，在加载阶段就已经生成class结构了，所以我认为在加载阶段应该已经写入了方法区，只是被标记为未链接而暂不能使用。</li><li>类的初始化只会发生一次，与new实例的初始化不是一个概念。  </li><li>JVM并不会直接使用.class文件，类加载链接的目的就是在JVM中创建相应的类结构，会存储在元空间（老说法就是方法区）。  </li><li>双亲委派呀，明明只给了父类加载所以应该是单亲的，并且英文中为parent不带s，照理应该翻译为单亲。但既然约定俗成翻译为双亲。</li><li>针对上一点，我认为还有另一种解释：在类加载的过程中，有一个委派模式，这里严格来说应该不是使用的继承方式，应该是组合。它委派的那个对象名字叫parent。可能翻译为双亲比较不容易混淆。  </li><li>加载阶段都加载哪些类呢，那么多类，全部加载吗？其实加载阶段是针对单个类的，一般用到的类才会被加载。大部分情况下，不同类的加载时机是不同的。</li><li>加载是类加载的一个过程。    </li></ul><p>&emsp;众所周知，Class文件描述了各种各样的信息，如果要使用的话，必须加载到虚拟机之中。虚拟机把数据Class文件加载到内存，并对数据进行校验、转换解析与初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程就称为JVM的类加载机制。  </p><p>从 class 文件到内存中的类，按先后顺序需要经过加载、链接以及初始化三大步骤。其中，链接过程中同样需要验证；而内存中的类没有经过初始化，同样不能使用。那么，是否所有的 Java 类都需要经过这几步呢？    </p><p>我们知道 Java 语言的类型可以分为两大类：基本类型（primitive types）和引用类型（reference types）。</p><p>对于引用类型，Java 将其细分为四种：<strong>类、接口、数组类和泛型参数</strong>。由于泛型参数会在编译过程中被擦除（转为Object），因此 Java 虚拟机实际上只有前三种。在类、接口和数组类中，数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。</p><blockquote><p>针对于<strong>字节流</strong>，最常见的形式要属由 Java 编译器生成的 class 文件。除此之外，我们也可以在程序内部直接生成，或者从网络中获取（例如网页中内嵌的小程序 Java applet）字节流。这些不同形式的字节流，都会被加载到 Java 虚拟机中，成为类或接口。为了叙述方便，下面我就用“类”来统称它们。</p></blockquote><p>实际上，无论是直接生成的数组类，还是加载的类，Java 虚拟机都需要对其进行链接和初始化。  </p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>&emsp;加载，是指查找字节流，并且据此创建类的过程。上面提到，对于数组类来说，它并没有对应的字节流，而是由 Java 虚拟机直接生成的。对于其他的类来说，Java 虚拟机则需要借助类加载器来完成查找字节流的过程。<br>&emsp; 类加载器有着不同的层次，不同层次的类加载器执行的优先级是不一样的。最高等级的类加载器，叫 <strong>启动类加载器（boot class loader）</strong>。启动类加载器是由 C++ 实现的，没有对应的 Java 对象，因此在 Java 中只能用 null 来指代。换句话说，等级高的类似乎看不起其它等级的类，所以非最高级的类加载器谁也没有启动类加载器的联系方式。<br>&emsp;除了启动类加载器之外，其他的类加载器都是 java.lang.ClassLoader 的子类，因此有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。<br>&emsp;在这个等级森严的类加载体系中有一个潜规则，就是接到单子自己不能着手干，得先给上一层次的类加载器过过目。一层次的类加载器不接手的情况下，才能自己来。在 Java 虚拟机中，这个潜规则有个特别的名字，叫 <strong>双亲委派模型</strong> 。每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。<strong>在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载</strong>。<br>&emsp;在 Java 9 之前，启动类加载器负责加载最为基础、最为重要的类，比如存放在 JRE 的 lib 目录下 jar 包中的类（以及由虚拟机参数 -Xbootclasspath 指定的类）。除了启动类加载器之外，另外两个重要的类加载器是扩展类加载器（extension class loader）和应用类加载器（application class loader），均由 Java 核心类库提供。<br>&emsp;<strong>扩展类加载器</strong> 的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。<br>&emsp;<strong>应用类加载器</strong> 的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。<br>&emsp;Java 9 引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。<br>&emsp;除了由 Java 核心类库提供的类加载器外，我们还可以加入 <strong>自定义的类加载器</strong>，来实现特殊的加载方式。举例来说，我们可以对 class 文件进行加密，加载时再利用自定义的类加载器对其解密。<br>&emsp;在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。 <strong>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</strong>  </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>&emsp;链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为 <strong>验证、准备以及解析</strong> 三个阶段。<br>&emsp;<strong>验证</strong> 阶段的目的，在于确保被加载类能够满足 Java 虚拟机的约束条件。通常而言，Java 编译器生成的类文件必然满足 Java 虚拟机的约束条件。<br>&emsp;<strong>准备</strong> 阶段的目的，则是为被加载类的静态字段分配内存。Java 代码中对静态字段的具体初始化，则会在稍后的初始化阶段中进行。过了这个阶段，咱们算是盖好了毛坯房。虽然结构已经完整，但是在没有装修之前是不能住人的。<br>&emsp;除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。<br>&emsp;在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。<br>&emsp;<strong>解析</strong> 阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）<br>&emsp;如果将这段话放在盖房子的语境下，那么符号引用就好比“Tony 的房子”这种说法，不管它存在不存在，我们都可以用这种说法来指代 Tony 的房子。实际引用则好比实际的通讯地址，如果我们想要与 Tony 通信，则需要知道其具体地址。  </p><blockquote><p>&emsp;Java虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。</p></blockquote><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>&emsp;在Java代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。<br>&emsp;如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 &lt; clinit &gt;。<br>&emsp;类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行 &lt; clinit &gt; 方法的过程。Java 虚拟机会通过加锁来确保类的 &lt; clinit &gt; 方法仅被执行一次。<br>&emsp;只有当初始化完成之后，类才正式成为可执行的状态。这放在我们盖房子的例子中就是，只有当房子装修过后，Tony 才能真正地住进去。<br>&emsp;那么，类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况：  </p><ol><li>当虚拟机启动时，初始化用户指定的主类；</li><li>当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；</li><li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li><li>当遇到访问静态字段的指令时，初始化该静态字段所在的类；</li><li>子类的初始化会触发父类的初始化；</li><li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；</li><li>使用反射 API 对某个类进行反射调用时，初始化这个类；</li><li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LazyHolder</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> LazyHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;上面这段代码是在著名的单例延迟初始化例子，只有当调用 Singleton.getInstance时，程序才会访问 LazyHolder.INSTANCE，才会触发对LazyHolder 的初始化（对应第 4 种情况），继而新建一个 Singleton 的实例。<br>&emsp;由于类初始化是线程安全的，并且仅被执行一次，因此程序可以确保多线程环境下有且仅有一个 Singleton 实例。    </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;本篇介绍了 Java 虚拟机将字节流转化为 Java 类的过程。这个过程可分为加载、链接以及初始化三大步骤。<br>&emsp;加载是指查找字节流，并且据此创建类的过程。加载需要借助类加载器，在 Java 虚拟机中，类加载器使用了双亲委派模型，即接收到加载请求时，会先将请求转发给父类加载器。<br>&emsp;链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。链接还分验证、准备和解析三个阶段。其中，解析阶段为非必须的。<br>&emsp;初始化，则是为标记为常量值的字段赋值，以及执行 &lt; clinit &gt; 方法的过程。类的初始化仅会被执行一次，这个特性被用来实现单例的延迟初始化。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="/2019/04/01/Java%20SortShell/"/>
      <url>/2019/04/01/Java%20SortShell/</url>
      
        <content type="html"><![CDATA[<h2 id="ShellSort"><a href="#ShellSort" class="headerlink" title="ShellSort"></a>ShellSort</h2><p>希尔排序又称为“缩小增量排序”(Diminishing Increment Sort),其实希尔排序也是一种属于<strong>插入类</strong>的方法，但是在时间效率上有着较大的改进。<br>希尔排序的基本思想是：先将整个待排序列分割为若干子序列分别进行直接插入排序，在整个序列中的数据“基本有序”时候，再对全体数据进行一次直接插入排序（即增量为1）。   </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">shell</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> pace <span class="token operator">=</span> length<span class="token operator">/</span><span class="token number">2</span> <span class="token punctuation">;</span> pace <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">;</span> pace <span class="token operator">=</span> pace <span class="token operator">/</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//设置一个步长（增量）pace，每隔这个增量就是一个子序列。</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> pace <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span> j <span class="token operator">=</span> i <span class="token operator">-</span> pace <span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">;</span> j  <span class="token operator">-=</span> pace<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//初始j为第一个子序列的第一个数据</span>                <span class="token comment" spellcheck="true">//保证已经比较过的子序列是有序的，在自序列中为递增</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    data<span class="token punctuation">[</span>j<span class="token operator">+</span>pace<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//data[j+pace] == data[i] == temp</span>                <span class="token punctuation">}</span><span class="token keyword">else</span>                    <span class="token comment" spellcheck="true">//已经遍历的子序列已经有序，data[j]已为最大值</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                                <span class="token punctuation">}</span>            data<span class="token punctuation">[</span>j<span class="token operator">+</span>pace<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> data<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Sort </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2019/03/25/Java%20SortSelect/"/>
      <url>/2019/03/25/Java%20SortSelect/</url>
      
        <content type="html"><![CDATA[<h2 id="SelectSort"><a href="#SelectSort" class="headerlink" title="SelectSort"></a>SelectSort</h2><p>选择排序的基本思想是：每一趟在 n-i+1 个数据中选出数值最小的记录，然后作为有序序列的第i个数据。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> null <span class="token operator">||</span> data<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> data<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//select min,set first</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> data<span class="token punctuation">.</span>length <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> min<span class="token punctuation">;</span>                min <span class="token operator">=</span>  data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Sort </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2019/03/20/Java%20SortInsert/"/>
      <url>/2019/03/20/Java%20SortInsert/</url>
      
        <content type="html"><![CDATA[<p>InsertSort操作基本操作是将一个记录插入到<strong>已排好的有序表</strong>中。即对于给定的一组数据，初始时候假设第一个数据自成一个有序序列，其余记录为无序序列。接着从第二个数据开始，按照数据的大小依次将当前将要处理的数据插入到<strong>之前的有序序列</strong>中，直到最后一个记录插入到有序序列中为止。<br>以下为直接插入排序。        </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InsertSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> null <span class="token operator">||</span> data<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> data<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//从第二个数组数据开始</span>            <span class="token keyword">int</span> j <span class="token operator">=</span>i <span class="token punctuation">;</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//和有序序列的最后一个data[i-1]比较，若比data[i-1]还小，</span>                <span class="token comment" spellcheck="true">// 就进行有序序列的比较--数据后移</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> temp <span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                    data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/*            while (j > 0 &amp;&amp; data[j-1] > temp) {                    data[j] = data[j-1];                    j--;               }*/</span>                data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>        <span class="token keyword">return</span> data<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>折半插入排序 – 对于直接插入排序也可以和折半查找相结合。可以在直接插入的基础上减少“比较”与“移动”的次数。  </p>]]></content>
      
      
      <categories>
          
          <category> Sort </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2019/03/15/Java%20SortMerge/"/>
      <url>/2019/03/15/Java%20SortMerge/</url>
      
        <content type="html"><![CDATA[<h2 id="MergingSort"><a href="#MergingSort" class="headerlink" title="MergingSort"></a>MergingSort</h2><p>归并排序与插入排序与起泡排序不同，“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表。<br>核心操作是将一维数组中前后相邻的两个有序序列归并为一个有序序列。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">,</span> n1<span class="token punctuation">,</span> n2<span class="token punctuation">;</span>    n1 <span class="token operator">=</span> q <span class="token operator">-</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    n2 <span class="token operator">=</span> r <span class="token operator">-</span> q<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> lPart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rPart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> p<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> k<span class="token operator">++</span><span class="token punctuation">)</span>        lPart<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n2<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> k<span class="token operator">++</span><span class="token punctuation">)</span>        rPart<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n1 <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n2<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lPart<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> rPart<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> lPart<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> rPart<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//寻找还有未融合完的部分序列</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n1<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">,</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> lPart<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n2<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> rPart<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Sort </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2019/03/10/Java%20SortQuick/"/>
      <url>/2019/03/10/Java%20SortQuick/</url>
      
        <content type="html"><![CDATA[<h2 id="QuickSort"><a href="#QuickSort" class="headerlink" title="QuickSort"></a>QuickSort</h2><p>快速排序其实是对起泡排序的一种改进，其基本思想是：通过一趟排序将待排数据分割成独立的两部分，其中一部分数据的关键字均比另一部分的关键字小，然后就可以对这两部分数据再进行排序，已达到整个序列有序。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quick</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">sort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token punctuation">,</span> <span class="token keyword">int</span> low <span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token punctuation">,</span> j <span class="token punctuation">;</span>    <span class="token keyword">int</span> index <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//pivot</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">>=</span> high <span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    i <span class="token operator">=</span> low<span class="token punctuation">;</span>    j <span class="token operator">=</span> high<span class="token punctuation">;</span>    index <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> index <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//use '>=' to be ensure stabilize</span>            j <span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>            data<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//data[i] = data[j] ; i++;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> index<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//not use '=' ensure stabilize</span>            i <span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>            data<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> index<span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span>low<span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// i = j</span>    <span class="token function">sort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Sort </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>起泡排序</title>
      <link href="/2019/03/08/Java%20SortBubble/"/>
      <url>/2019/03/08/Java%20SortBubble/</url>
      
        <content type="html"><![CDATA[<h2 id="BubbleSort"><a href="#BubbleSort" class="headerlink" title="BubbleSort"></a>BubbleSort</h2><p>起泡排序就是两两交换排序，可以将最大值或最小值放在一端，然后再从下个依次两两比较，将第二大或者第二小的放在一端第二个。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bubble</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                data<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> data<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Sort </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存模型</title>
      <link href="/2019/02/18/JVM%20MemoryModel/"/>
      <url>/2019/02/18/JVM%20MemoryModel/</url>
      
        <content type="html"><![CDATA[<h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><p><img src="/images/1.jpg" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DBUtils</title>
      <link href="/2019/01/04/Java%20Web%20%20DBUtils/"/>
      <url>/2019/01/04/Java%20Web%20%20DBUtils/</url>
      
        <content type="html"><![CDATA[<h3 id="DBUtils"><a href="#DBUtils" class="headerlink" title="DBUtils"></a>DBUtils</h3><p>Commons DbUtils是Apache提供的一个对JDBC进行简单封装的开源工具类库， 简化了CRUD，里面定义了通用的CRUD方法。同时也不会影响程序的性能。  </p><h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//dbutils 只是帮我们简化了CRUD 的代码， 但是连接的创建以及获取工作，不在他的工作范围，还需要我们自己动手。</span>QueryRunner queryRunner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryRunner</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//增加</span>queryRunner<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">"insert into account values (null , ? , ? )"</span><span class="token punctuation">,</span> <span class="token string">"aa"</span> <span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除</span>queryRunner<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">"delete from account where id = ?"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//更新</span>queryRunner<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">"update account set money = ? where id = ?"</span><span class="token punctuation">,</span> <span class="token number">10000000</span> <span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><strong>1. 直接new接口的匿名实现类</strong><br>查询结果为单个对象。  </p><pre class="line-numbers language-java"><code class="language-java">QueryRunner queryRunner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryRunner</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">Account  account <span class="token operator">=</span>  queryRunner<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"select * from account where id = ?"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ResultSetHandler</span><span class="token operator">&lt;</span>Account<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Account <span class="token function">handle</span><span class="token punctuation">(</span>ResultSet rs<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>        Account account  <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Account</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            String name <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> money <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"money"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            account<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            account<span class="token punctuation">.</span><span class="token function">setMoney</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> account<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>account<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 直接使用框架已经写好的实现类。</strong>    </p><ul><li>查询单个对象    </li></ul><pre class="line-numbers language-java"><code class="language-java">QueryRunner queryRunner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryRunner</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//查询单个对象</span>Account account <span class="token operator">=</span> queryRunner<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"select * from account where id = ?"</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">BeanHandler</span><span class="token operator">&lt;</span>Account<span class="token operator">></span><span class="token punctuation">(</span>Account<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>　　上面的代码段里使用了字节码文件Account.class，目的是与上面的匿名类相比，使用反射技术得到类的字节码相对象的实例，之前是new实现的。new关键字底层应该也是通过反射： 类名.class.newInstance()得到一个实例。</p><ul><li>查询多个对象  </li></ul><pre class="line-numbers language-java"><code class="language-java">QueryRunner queryRunner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryRunner</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>Account<span class="token operator">></span> list <span class="token operator">=</span> queryRunner<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"select * from account "</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">BeanListHandler</span><span class="token operator">&lt;</span>Account<span class="token operator">></span><span class="token punctuation">(</span>Account<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要熟练掌握  </p><pre class="line-numbers language-java"><code class="language-java">queryRunner<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>queryRunner<span class="token punctuation">.</span>query<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="ResultSetHandler-常用的实现类"><a href="#ResultSetHandler-常用的实现类" class="headerlink" title="ResultSetHandler 常用的实现类"></a>ResultSetHandler 常用的实现类</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//常用  是使用频率最高的</span>BeanHandler <span class="token comment" spellcheck="true">// 查询到的单个数据封装成一个对象</span>BeanListHandler <span class="token comment" spellcheck="true">// 查询到的多个数据封装 成一个List&lt;对象></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">ArrayHandler <span class="token comment" spellcheck="true">// 查询到的单个数据封装成一个数组</span>ArrayListHandler <span class="token comment" spellcheck="true">// 查询到的多个数据封装成一个集合 ，集合里面的元素是数组。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">MapHandler <span class="token comment" spellcheck="true">// 查询到的单个数据封装成一个map</span>MapListHandler <span class="token comment" spellcheck="true">// 查询到的多个数据封装成一个集合 ，集合里面的元素是map。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//不常用  </span>ColumnListHandler  KeyedHandler  ScalarHandler  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务</title>
      <link href="/2019/01/03/Java%20Web%20%20Transaction/"/>
      <url>/2019/01/03/Java%20Web%20%20Transaction/</url>
      
        <content type="html"><![CDATA[<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务指一组操作，要么全部执行，要么全都不执行。也就是最小的执行单位是定义的这一组事务。<br><strong>事务的作用</strong><br>　为了确保逻辑的成功执行。 例如：银行的转账。  </p><p> <strong>事务的特性 ACID</strong>  </p><ol><li>原子性  Atomicity<br>事务中包含的逻辑，不可分割。   </li><li>一致性  Consistency<br>事务执行前后。数据完整性  </li><li>隔离性  Isolation<br>事务在执行期间不应该受到其他事务的影响,两个事务的结果不应该相互影响。    </li><li>持久性  Durability<br>事务执行成功，那么数据应该持久保存到磁盘上。  </li></ol><h3 id="事务安全问题"><a href="#事务安全问题" class="headerlink" title="事务安全问题"></a>事务安全问题</h3><p><strong>读问题</strong><br>在读操作时可能会出现以下三种等级的错误 1.脏读 2.不可重读读 3.幻读  </p><ol><li>脏读<br>A事务读B事务还未提交的数据。  </li><li>不可重复读<br>A事务读到了B事务提交的数据，造成了A前后两次查询结果不一致。  </li><li>幻读<br>A事务读到了B事务insert的数据，造成了A前后两次查询结果不一致 。</li></ol><p>脏读是因为读到了未提交的还会回滚的数据导致的两次结果不一致（第一次脏数据，第二次正确数据），不可重复读是由于B提交而读到两次结果不一样（第一次未提交，第二次已提交正确数据）。  </p><p><strong>读问题的解决方案–隔离级别</strong>      </p><ol><li>读未提交   <strong>Read Uncommite</strong><br>　　A事务读到B事务未提交的事务，而B可能回滚，引起－－脏读问题。    </li><li>读已提交   <strong>Read Committed</strong><br>　　A事务第一次读到B事务未提交的数据，第二次读到B数据提交的数据，造成了A事务前后两次不同的结果。这个隔离级别能够屏蔽 <strong>脏读</strong> 的问题， 但是引发了另一个问题－－ <strong>不可重复读</strong>  。  </li><li>重复读  <strong>Repeatable Read</strong><br>　　AB两个事务，B事务进行了修改还未提交，A查询还是B事务修改之前的结果。B事务进行了提交，A查询结果仍是B事务修改之前的结果。也就是在可重复读的隔离级别中，AB是两个相互独立的互不影响。可重复读虽然解决了不可重复读的问题，但是这个隔离级别某种程度来说，在实际中的作用并不大。并且这个隔离级别还没有解决－－幻读的问题。</li><li>可串行化  <strong>Serializable</strong><br>　　解决了幻读问题。如果有一个连接的隔离级别设置为了串行化 ，那么谁先打开了事务， 谁就有了先执行的权利， 谁后打开事务，谁就只能得着，等前面的那个事务，提交或者回滚后，才能执行。例如：B先打开了一个事务，A又打开了一个事物，此时B不管是否已经修改，只要还没有提交，A的查询都会一直阻塞着，一直等B提交之后A才会有查询的结果。但是这种隔离级别一般比较少用。容易造成性能上的问题。效率比较低。</li></ol><ul><li><p>按效率划分，从高到低  </p><blockquote><p>读未提交  &gt; 读已提交  &gt; 可重复读  &gt; 可串行化</p></blockquote></li><li><p>按拦截程度 ，从高到底  </p><blockquote><p>可串行化 &gt; 可重复读 &gt; 读已提交 &gt;  读未提交  </p></blockquote></li></ul><p><strong>写问题</strong>  </p><ul><li>丢失更新<br>　　AB事务同时建立，A修改了一部分数据并提交，B修改了另外一部分数据进行提交，结果A的修改丢失了，最后的结果只有B自己修改的数据，A的修改被覆盖了，同时假设B在上面的过程中修改后被回滚，那么AB的修改都不会被保存。  </li></ul><p><strong>写问题的解决方案–锁</strong><br>悲观锁，认为一定会出现丢失更新。<br>乐观锁，认为一定不会出现丢失更新。</p><ol><li><p>悲观锁<br>　　<strong>for update</strong> 数据库的锁机制，也叫排他锁。A事务先建立，B事务后建立，和可串行化类似，B会等A提交后再进行操作（B可以在A修改的基础上进行修改）。</p></li><li><p>乐观锁<br>　　乐观锁需要开发者手动控制，可以加一个字段（可以为一个时间戳或者标志）。例如新加了一个字段version，AB两个事务的version都为0，当A修改后提交时候将version修改为1并保存，B要提交修改的时候比较自己的version与数据库里的version值，如果一样，可以直接将本次的提交存下来，否则就将再次获取数据库里的数据，重新进行修改、提交。  </p></li></ol><h3 id="代码里的事务"><a href="#代码里的事务" class="headerlink" title="代码里的事务"></a>代码里的事务</h3><p>作用：代码里面的事务，主要是用来数据库连接的。  </p><blockquote><p>通过conn.setAutoCommit（false ）来关闭自动提交的设置。<br>提交事务  conn.commit();<br>回滚事务 conn.rollback();  </p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Connection conn <span class="token operator">=</span> null<span class="token punctuation">;</span>    PreparedStatement ps <span class="token operator">=</span> null<span class="token punctuation">;</span>    ResultSet rs <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        conn <span class="token operator">=</span> JDBCUtil<span class="token punctuation">.</span><span class="token function">getConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//JDBCUtil是自己编写的JDBC工具类</span>        <span class="token comment" spellcheck="true">//连接，事务默认就是自动提交的。 关闭自动提交。</span>        conn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String sql <span class="token operator">=</span> <span class="token string">"update account set money = money - ? where id = ?"</span><span class="token punctuation">;</span>        ps <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//扣钱， 扣ID为1 的100块钱</span>        ps<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ps<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ps<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">/</span><span class="token number">0</span> <span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//加钱， 给ID为2 加100块钱</span>        ps<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ps<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ps<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//成功： 提交事务。</span>        conn<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//事变： 回滚事务</span>            conn<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e1<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        JDBCUtil<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> ps<span class="token punctuation">,</span> rs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="事务总结"><a href="#事务总结" class="headerlink" title="事务总结"></a>事务总结</h3><ol><li>事务只是针对连接连接对象，如果再开一个连接对象，那么那是默认的提交。</li><li>事务是会自动提交的。</li></ol><p><strong>隔离级别</strong><br>读未提交  </p><blockquote><p>引发问题： 脏读  </p></blockquote><p>读已提交  </p><blockquote><p>解决： 脏读 ， 引发： 不可重复读  </p></blockquote><p>可重复读  </p><blockquote><p>解决： 脏读 、 不可重复读 ， 未解决： 幻读   </p></blockquote><p>可串行化  </p><blockquote><p>解决： 脏读、 不可重复读 、 幻读。</p></blockquote><p>mySql 默认的隔离级别是 可重复读<br>Oracle 默认的隔离级别是  读已提交</p>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连接池</title>
      <link href="/2019/01/03/Java%20Web%20%20ConnectionPool/"/>
      <url>/2019/01/03/Java%20Web%20%20ConnectionPool/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><ol><li>数据库连接的对象创建，比较消耗性能。     </li><li>一开始现在内存中开辟一块空间（以集合存起来）， 一开先往Pool里面放置多个连接对象。以后需要连接的话，直接从Pool里面取。不需要自己用到时再重头开始建立了。使用完毕，需要归还连接，确保连接对象能循环利用。  </li></ol><p>常用的开源连接池有DBCP（Apache）与C3P0  </p><h4 id="DBCP"><a href="#DBCP" class="headerlink" title="DBCP"></a>DBCP</h4><p>首先导入jar文件。<br><strong>方式一 不使用配置文件：</strong>   </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDBCP01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Connection conn <span class="token operator">=</span> null<span class="token punctuation">;</span>    PreparedStatement ps <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//1. 构建数据源对象</span>        BasicDataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BasicDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//连的是什么类型的数据库， 访问的是哪个数据库 ， 用户名， 密码</span>        <span class="token comment" spellcheck="true">//jdbc:mysql://localhost/bank 主协议：子协议 ://地址/数据库</span>        dataSource<span class="token punctuation">.</span><span class="token function">setDriverClassName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost/bank"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//2. 得到连接对象</span>            conn <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String sql <span class="token operator">=</span> <span class="token string">"insert into account values(null , ? , ?)"</span><span class="token punctuation">;</span>            ps <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>            ps<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ps<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ps<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            JDBCUtil<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> ps<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>方式二 使用配置文件方式</strong>   </p><pre class="line-numbers language-java"><code class="language-java">#dbcpconfig<span class="token punctuation">.</span>properties 配置文件#连接设置driverClassName<span class="token operator">=</span>com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>Driverurl<span class="token operator">=</span>jdbc<span class="token operator">:</span>mysql<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">:</span><span class="token number">3306</span><span class="token operator">/</span>jdbcusername<span class="token operator">=</span>rootpassword<span class="token operator">=</span><span class="token number">123456</span>#<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 初始化连接 <span class="token operator">--</span><span class="token operator">></span>initialSize<span class="token operator">=</span><span class="token number">10</span>#最大连接数量maxActive<span class="token operator">=</span><span class="token number">50</span>#<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 最大空闲连接 <span class="token operator">--</span><span class="token operator">></span>maxIdle<span class="token operator">=</span><span class="token number">20</span>#<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 最小空闲连接 <span class="token operator">--</span><span class="token operator">></span>minIdle<span class="token operator">=</span><span class="token number">5</span>#<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 超时等待时间以毫秒为单位 <span class="token number">6000</span>毫秒<span class="token operator">/</span><span class="token number">1000</span>等于<span class="token number">60</span>秒 <span class="token operator">--</span><span class="token operator">></span>maxWait<span class="token operator">=</span><span class="token number">60000</span>#JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：<span class="token punctuation">[</span>属性名<span class="token operator">=</span>property<span class="token punctuation">;</span><span class="token punctuation">]</span>#注意：<span class="token string">"user"</span> 与 <span class="token string">"password"</span> 两个属性会被明确地传递，因此这里不需要包含他们。connectionProperties<span class="token operator">=</span>useUnicode<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>characterEncoding<span class="token operator">=</span>gbk#指定由连接池所创建的连接的自动提交（auto<span class="token operator">-</span>commit）状态。defaultAutoCommit<span class="token operator">=</span><span class="token boolean">true</span>#driver <span class="token keyword">default</span> 指定由连接池所创建的连接的事务级别（TransactionIsolation）。#可用值为下列之一：（详情可见javadoc。）NONE<span class="token punctuation">,</span>READ_UNCOMMITTED<span class="token punctuation">,</span> READ_COMMITTED<span class="token punctuation">,</span> REPEATABLE_READ<span class="token punctuation">,</span> SERIALIZABLEdefaultTransactionIsolation<span class="token operator">=</span>READ_UNCOMMITTED<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">Connection conn <span class="token operator">=</span> null<span class="token punctuation">;</span>PreparedStatement ps <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    BasicDataSourceFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BasicDataSourceFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    InputStream is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"src//dbcpconfig.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>    DataSource dataSource <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createDataSource</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2. 得到连接对象</span>    conn <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String sql <span class="token operator">=</span> <span class="token string">"insert into account values(null , ? , ?)"</span><span class="token punctuation">;</span>    ps <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    ps<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"liangchaowei"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ps<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ps<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>    JDBCUtil<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> ps<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="C3P0（重要）"><a href="#C3P0（重要）" class="headerlink" title="C3P0（重要）"></a>C3P0（重要）</h3><p>拷贝jar文件到lib目录。<br><strong>方式一 不使用配置文件方式</strong>（不常用）   </p><pre class="line-numbers language-java"><code class="language-java">Connection conn <span class="token operator">=</span> null<span class="token punctuation">;</span>PreparedStatement ps <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//1. 创建datasource</span>    ComboPooledDataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2. 设置连接数据库的信息</span>    dataSource<span class="token punctuation">.</span><span class="token function">setDriverClass</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dataSource<span class="token punctuation">.</span><span class="token function">setJdbcUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost/bank"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dataSource<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dataSource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2. 得到连接对象</span>    conn <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String sql <span class="token operator">=</span> <span class="token string">"insert into account values(null , ? , ?)"</span><span class="token punctuation">;</span>    ps <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    ps<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"admi234n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ps<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">103200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ps<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>    JDBCUtil<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> ps<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方式二 使用配置文件方式</strong><br>C3P0配置文件支持properties与XML（用的较多）两种方式。 xml配置文件具体的内容资料或者官网都有，直接复制内容<br>即可，但是名字必须叫 c3p0-config.xml。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//默认会找 xml 中的 default-config 分支。</span>ComboPooledDataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2. 设置连接数据的信息</span><span class="token comment" spellcheck="true">// dataSource.setDriverClass("com.mysql.jdbc.Driver");</span><span class="token comment" spellcheck="true">// dataSource.setJdbcUrl("jdbc:mysql://localhost/bank");</span><span class="token comment" spellcheck="true">// dataSource.setUser("root");</span><span class="token comment" spellcheck="true">// dataSource.setPassword("root");</span><span class="token comment" spellcheck="true">//2. 得到连接对象</span>conn <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String sql <span class="token operator">=</span> <span class="token string">"insert into account values(null , ? , ?)"</span><span class="token punctuation">;</span>ps <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>ps<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"admi234n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ps<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">103200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ps<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC基础</title>
      <link href="/2019/01/02/Java%20Web%20%20JDBC/"/>
      <url>/2019/01/02/Java%20Web%20%20JDBC/</url>
      
        <content type="html"><![CDATA[<p><strong>JDBC：</strong> JAVA Database Connectivity java 数据库连接。</p><h3 id="JDBC的基本使用步骤："><a href="#JDBC的基本使用步骤：" class="headerlink" title="JDBC的基本使用步骤："></a>JDBC的基本使用步骤：</h3><ol><li>注册驱动</li></ol><pre class="line-numbers language-java"><code class="language-java">DriverManager<span class="token punctuation">.</span><span class="token function">registerDriver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>Driver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Driver类里面有静态代码块，如果使用上面等于注册了两次，实际没有必要也没有影响。可使用以下：  </p><pre class="line-numbers language-java"><code class="language-java">Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>建立连接</li></ol><pre class="line-numbers language-java"><code class="language-java">   <span class="token comment" spellcheck="true">//DriverManager.getConnection("jdbc:mysql://localhost/test?user=monty&amp;password=greatsqldb");</span>   <span class="token comment" spellcheck="true">//2. 建立连接 参数一： 协议 + 访问的数据库 ， 参数二： 用户名 ， 参数三： 密码。</span>   Connection conn <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost/student"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li>创建statement</li></ol><pre class="line-numbers language-java"><code class="language-java"> <span class="token comment" spellcheck="true">//3. 创建statement，跟数据库打交道，一定需要这个对象</span>  Statement st <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="4"><li>执行sql ，得到ResultSet</li></ol><pre class="line-numbers language-java"><code class="language-java">   <span class="token comment" spellcheck="true">//4. 执行查询 ， 得到结果集</span>    String sql <span class="token operator">=</span> <span class="token string">"select * from t_stu"</span><span class="token punctuation">;</span>    Result rs <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="5"><li>遍历结果集</li></ol><pre class="line-numbers language-java"><code class="language-java">   <span class="token comment" spellcheck="true">//5. 遍历查询每一条记录</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> id <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String name <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> age <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"id="</span><span class="token operator">+</span>id <span class="token operator">+</span> <span class="token string">"===name="</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">"==age="</span><span class="token operator">+</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>释放资源  </li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>          rs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> sqlEx<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// ignore</span>      rs <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用properties配置文件"><a href="#使用properties配置文件" class="headerlink" title="使用properties配置文件"></a>使用properties配置文件</h3><ol><li>在src文件下建立xxx.properties文件，具体如下：</li></ol><pre class="line-numbers language-java"><code class="language-java">driverClass <span class="token operator">=</span> com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>Driverurl <span class="token operator">=</span> jdbc<span class="token operator">:</span>mysql<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span>studentname <span class="token operator">=</span> rootpassword <span class="token operator">=</span> <span class="token number">123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面的url在使用时如果遇到插入为汉字时会遇到乱码，也就是数据库里存的是乱码，需要在url后面再加上 <strong>?useUnicode=true&amp;characterEncoding=utf-8</strong> 。也就是：</p><pre class="line-numbers language-java"><code class="language-java">url <span class="token operator">=</span> jdbc<span class="token operator">:</span>mysql<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span>student<span class="token operator">?</span>useUnicode<span class="token operator">=</span><span class="token boolean">true</span><span class="token operator">&amp;</span>characterEncoding<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>在JDBC工具类里面，使用静态代码块，读取xxx.properties</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span><span class="token punctuation">{</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//1. 创建一个属性配置对象</span>    Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    InputStream is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"jdbc.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//对应文件位于工程根目录</span>    <span class="token comment" spellcheck="true">//使用类加载器，去读取src底下的资源文件。 后面在servlet  //对应文件位于src目录下</span>    <span class="token comment" spellcheck="true">//InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream("jdbc.properties");</span>    <span class="token comment" spellcheck="true">//导入输入流。</span>    properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//读取属性</span>    driverClass <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"driverClass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    url <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    name <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    password <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据库的基本CRUD"><a href="#数据库的基本CRUD" class="headerlink" title="数据库的基本CRUD"></a>数据库的基本CRUD</h3><ol><li>insert  </li></ol><pre class="line-numbers language-java"><code class="language-java">INSERT INTO <span class="token function">t_stu</span> <span class="token punctuation">(</span>NAME <span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token function">VALUES</span> <span class="token punctuation">(</span><span class="token string">'wangqiang'</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token punctuation">)</span>INSERT INTO t_stu <span class="token function">VALUES</span> <span class="token punctuation">(</span>NULL<span class="token punctuation">,</span><span class="token string">'wangqiang2'</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. 获取连接对象</span>    conn <span class="token operator">=</span> JDBCUtil<span class="token punctuation">.</span><span class="token function">getConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. 根据连接对象，得到statement</span>    st <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3. 执行添加</span>    String sql <span class="token operator">=</span> <span class="token string">"insert into t_stu values(null , 'aobama' , 59)"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//影响的行数， ，如果大于0 表明操作成功。 否则失败</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>result <span class="token operator">></span><span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"添加成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"添加失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>delete</li></ol><pre class="line-numbers language-java"><code class="language-java">  DELETE FROM t_stu WHERE id <span class="token operator">=</span> <span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. 获取连接对象</span>    conn <span class="token operator">=</span> JDBCUtil<span class="token punctuation">.</span><span class="token function">getConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. 根据连接对象，得到statement</span>    st <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3. 执行添加</span>    String sql <span class="token operator">=</span> <span class="token string">"delete from t_stu where name='aobama'"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//影响的行数， ，如果大于0 表明操作成功。 否则失败</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>result <span class="token operator">></span><span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>query</li></ol><pre class="line-numbers language-java"><code class="language-java">  SELECT <span class="token operator">*</span> FROM t_stu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 1. 获取连接对象</span>    conn <span class="token operator">=</span> JDBCUtil<span class="token punctuation">.</span><span class="token function">getConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. 根据连接对象，得到statement</span>    st <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3. 执行sql语句，返回ResultSet</span>    String sql <span class="token operator">=</span> <span class="token string">"select * from t_stu"</span><span class="token punctuation">;</span>    rs <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 4. 遍历结果集</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String name <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> age <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">"   "</span> <span class="token operator">+</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>update</li></ol><pre class="line-numbers language-java"><code class="language-java">  UPDATE t_stu SET age <span class="token operator">=</span> <span class="token number">38</span> WHERE id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. 获取连接对象</span>    conn <span class="token operator">=</span> JDBCUtil<span class="token punctuation">.</span><span class="token function">getConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. 根据连接对象，得到statement</span>    st <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3. 执行添加</span>    String sql <span class="token operator">=</span> <span class="token string">"update t_stu set age = 26 where name ='qyq'"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//影响的行数， ，如果大于0 表明操作成功。 否则失败</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>result <span class="token operator">></span><span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"更新成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"更新失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用简单的单元测试"><a href="#使用简单的单元测试" class="headerlink" title="使用简单的单元测试"></a>使用简单的单元测试</h3><p>　　平时测试时都是在public static void main方法里面，可以使用单元测试而直接测试一个方法。在eclipse中可以add library添加Junit4的包，在idea可直接使用。<br>　　首先定义一个类，TestXXX,里面定义方法testXXX（XXX为要测试的方法）。在testXXX上面使用 <strong>@test</strong> 进行测试。   </p><h3 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h3><p>Data Access Object 数据访问对象  </p><ol><li>新建一个dao的接口， 里面声明数据库访问规则(面向接口编程，定义了接口里的规则（要实现的方法）之后，进行具体的实现）。</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//定义操作数据库的方法</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserDao</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//查询所有     </span><span class="token keyword">void</span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>新建一个dao的实现类，具体实现早前定义的规则     </li></ol><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserDao</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Connection conn <span class="token operator">=</span> null<span class="token punctuation">;</span>        Statement st <span class="token operator">=</span> null<span class="token punctuation">;</span>        ResultSet rs <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//1. 获取连接对象</span>            conn <span class="token operator">=</span> JDBCUtil<span class="token punctuation">.</span><span class="token function">getConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//2. 创建statement对象</span>            st <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String sql <span class="token operator">=</span> <span class="token string">"select * from t_user"</span><span class="token punctuation">;</span>            rs <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                String userName <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                String password <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userName<span class="token operator">+</span><span class="token string">"="</span><span class="token operator">+</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            JDBCUtil<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> st<span class="token punctuation">,</span> rs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>可以使用单元测试进行测试   </li></ol><pre class="line-numbers language-java"><code class="language-java">  <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFindAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        UserDao dao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dao<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>##Statement安全问题<br>Statement执行 ，其实是拼接sql语句的。  先拼接sql语句，然后在一起执行。   </p><pre class="line-numbers language-java"><code class="language-java">    String sql <span class="token operator">=</span> <span class="token string">"select * from t_user where username='"</span><span class="token operator">+</span> username  <span class="token operator">+</span><span class="token string">"' and password='"</span><span class="token operator">+</span> password <span class="token operator">+</span><span class="token string">"'"</span><span class="token punctuation">;</span>    UserDao dao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dao<span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">,</span> <span class="token string">"100234khsdf88' or '1=1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    SELECT <span class="token operator">*</span> FROM t_user WHERE username<span class="token operator">=</span><span class="token string">'admin'</span> AND PASSWORD<span class="token operator">=</span><span class="token string">'100234khsdf88'</span> or <span class="token string">'1=1'</span>    前面先拼接sql语句， 如果变量里面带有了 数据库的关键字，那么一并认为是关键字。 不认为是普通的字符串。    rs <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="PrepareStatement"><a href="#PrepareStatement" class="headerlink" title="PrepareStatement"></a>PrepareStatement</h3><p>PrepareStatement对象就是替换前面的statement对象。<br>优点：</p><ul><li>安全性  </li><li>使用简单，不用拼接字符串  </li></ul><p> 相比较以前的statement， 预先处理给定的sql语句，对其执行语法检查。 在sql语句里面使用 <strong>?</strong> 占位符来替代后续要传递进来的变量。 后面进来的变量值，将会被看成是字符串，不会产生任何的关键字。</p><pre class="line-numbers language-java"><code class="language-java">    String sql <span class="token operator">=</span> <span class="token string">"insert into t_user values(null , ? , ?)"</span><span class="token punctuation">;</span>     ps <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//给占位符赋值 从左到右数过来，1 代表第一个问号， 永远你是1开始。</span>     ps<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> userName<span class="token punctuation">)</span><span class="token punctuation">;</span>     ps<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​   </p>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java内部类</title>
      <link href="/2018/12/20/Java%20InnerClass/"/>
      <url>/2018/12/20/Java%20InnerClass/</url>
      
        <content type="html"><![CDATA[<p>众所周知，每一个Java类都生成一个class文件。内部类是在一个类中再定义一个类，被包含着的类就称为内部类，包含内部类的相比之下就称为外部类。内部类与外部类之间有着紧密的联系，而内部类与其它的类关系不大。这也是内部类的一个优点：被完全隐藏起来，有着更好的封装性（可以声明为private对外界完全隐藏），减少了代码量（可轻松访问外部类的私有变量），使其更为简洁。<br>虽然内部类被包含在外部类中，看起来是一个类，但这只是从java编译器的角度来看的，在java虚拟机层面看到的（与泛型类似）其实还是两个类，也就是说，每个内部类最后都会被编译为一个独立的类，生成一个独立的字节码文件。下面的一段代码中实际会生成两个类：Outer与Outer$StaticInner。<br><strong>内部类可以被定义为private，仅外部类可以实例化该内部类与使用其方法，仅有内部类可以被定义为private、static</strong><br>分为静态内部类、成员内部类、方法（局部）内部类与匿名内部类。  </p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><h4 id="特征：-带有static关键字。"><a href="#特征：-带有static关键字。" class="headerlink" title="特征： 带有static关键字。"></a><strong>特征：</strong> 带有<strong>static</strong>关键字。</h4><p>在java中，只有一种情况类前可以加static关键字–静态内部类。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//定义外部类</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> outInt <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//定义外部类的静态变量，类变量</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    StaticInner si <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticInner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    si<span class="token punctuation">.</span><span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StaticInner</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//定义静态内部类</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"inner :"</span> <span class="token operator">+</span> outInt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="静态内部类使用方式"><a href="#静态内部类使用方式" class="headerlink" title="静态内部类使用方式"></a>静态内部类使用方式</h4><ol><li>一个静态内部类可以拥有 <strong>静态变量，静态方法，成员变量，成员方法，构造方法等。</strong>    </li><li>静态内部类只能只能访问外部类的静态（类）变量与静态（类）方法，不能访问实例变量与实例方法。  </li><li>在一个外部类中可以像往常使用一个类一样（如上面代码段的test方法中所示），可以很方便的去使用静态内部类。</li><li>对于其它的类，也可以使用一个类中的静态内部类的public成员。规则为<strong>“外部类.静态内部类”</strong> ，具体如下：  <blockquote><p>Outer.StaticInner si = new Outer.StaticInner();<br>si.innerMethod();</p></blockquote></li></ol><h4 id="静态内部类细节"><a href="#静态内部类细节" class="headerlink" title="静态内部类细节"></a>静态内部类细节</h4><p>既然是生成了两个类，那么为何能访问到另一个类的私有成员呢？例如上面的outInt变量。<br>java的解决方案是：自动为Outer类生成一个非私有的访问方法access$0,这个方法返回私有静态变量outInt。  </p><h4 id="静态内部类的使用场景"><a href="#静态内部类的使用场景" class="headerlink" title="静态内部类的使用场景"></a>静态内部类的使用场景</h4><p>当一个类与外部类关系紧密且不依赖外部类实例的时候，可以考虑定义为静态内部类，例如要返回多个返回值，可以考虑使用内部类。<br><strong>LinkedList</strong><br>1、非静态内部类是不可以声明静态成员的（属性和方法），使用静态类就可以声明静态成员，而这招体现在实际的工作中，也许可以让你避免绕许多圈子。<br>2、非静态内部类，可以随意的访问外部类中的成员变量与成员方法，即便它们是私有的也可以（这是它活下来的重要手段之一，呵呵）。<br>     但静态内部类对外部类的访问是有局限的，如不能访问外部类的非静态成员与变量（这是它的最大限制，也是使用频率上输给普通内部类的原因）<br>3、普通内部类把它理解为与外部类绑定了，创建普通内部类对象一定要通过外部类的对象new才行。而静态内部类是不需要的。</p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><h4 id="特点：-相比静态内部类，没有static修饰。"><a href="#特点：-相比静态内部类，没有static修饰。" class="headerlink" title="特点： 相比静态内部类，没有static修饰。"></a>特点： 相比静态内部类，没有static修饰。</h4><p>虽然成员内部类与静态内部类在定义上只差了一个static修饰符，但具体的含义与使用有着巨大的不同。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//定义外部类</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> outInt <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//定义外部类的静态变量，类变量</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is Outer`s action"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Inner inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    inner<span class="token punctuation">.</span><span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//定义内部类</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"outInt :"</span> <span class="token operator">+</span> outInt<span class="token punctuation">)</span><span class="token punctuation">;</span>      Outer<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//内部类调用外部类的非静态方法</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="成员内部类使用方式"><a href="#成员内部类使用方式" class="headerlink" title="成员内部类使用方式"></a>成员内部类使用方式</h4><ol><li>与静态内部类不同，一个成员内部类拥有 <strong>成员变量、成员方法、构造方法</strong>    </li><li>在静态内部类中，内部类只能访问外部类的静态变量与静态方法。但是在成员内部类中，除了可以访问外部类的静态变量与静态方法，还可以直接访问外部类的实例变量与实例方法。例如：在Inner类中的innerMethod方法可以直接访问外部类的私有实例变量outInt，在成员内部类Inner中可以通过 <strong>“外部类.this.xxx”</strong> 的方式来使用外部类的实例变量与实例方法，例如 <strong>“Outer.this.action();”</strong> 。既然要用  <strong>“外部类.this.xxx”</strong> 这种形式来访问外部类的实例变量与实例方法，那么在上面的代码中，在Inner类中为什么只用访问外部类的action方法时才用这种方法，而访问实例变量outInt时确直接就访问了呢？因为在不引起异议的前提下，可以省略 <strong>“外部类.this”</strong>  而直接使用外部类的实例变量或实例方法即可，也就是说内部类使用action方法时，其前面的 <strong>“Outer.this”</strong> 也可省略。    </li><li>在外部类里使用内部类的成员时，成员内部类与静态内部类的使用方式是一样， <strong>直接使用即可</strong> 如test（）方法所示。</li><li>与静态内部类所不同的是 <strong>成员内部类对象总是与一个外部类对象相连，在外部使用时（外部类之外），它不能通过 new Outer.Inner() 的方式创建对象，而是要先创建一个Outer对象。</strong>    </li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//外部（外部类之外）使用内部类的方式    </span>Outer outer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Outer<span class="token punctuation">.</span>Inner inner <span class="token operator">=</span> outer<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>inner<span class="token punctuation">.</span><span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如上面代码段所示，在外部使用成员内部类的方式。  </p><h4 id="成员内部类细节"><a href="#成员内部类细节" class="headerlink" title="成员内部类细节"></a>成员内部类细节</h4><p>静态内部类可以定义静态变量与静态方法，但是在成员内部类中不可以定义这两个（final除外，因为它等同于常量）。并且在方法内部类与匿名内部类也不可以定义静态变量与静态方法。我们可以这样理解：之所以不让定义，是因为这些内部类不应该单独使用，不应该定义类的变量与方法。</p><h4 id="成员内部类使用场景与源码举例"><a href="#成员内部类使用场景与源码举例" class="headerlink" title="成员内部类使用场景与源码举例"></a>成员内部类使用场景与源码举例</h4><p>当内部类与外部类关系密切，需要访问外部类的实例变量与实例方法时，可以考虑定义为成员内部类。这个内部类还可以定义为private，对外部完全隐藏。例如LinkedList中的listIterator方法，其返回值为接口Iterator，listIterator内部使用了成员内部类ListItr。<br>LinkedList  </p><hr><h3 id="方法内部类"><a href="#方法内部类" class="headerlink" title="方法内部类"></a>方法内部类</h3><h4 id="方法内部类特征"><a href="#方法内部类特征" class="headerlink" title="方法内部类特征"></a>方法内部类特征</h4><p>在一个方法中定义一个类。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//定义外部类</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> test<span class="token punctuation">{</span><span class="token keyword">final</span> <span class="token keyword">int</span> param<span class="token punctuation">}</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//在方法中定义一个内部类</span>    <span class="token keyword">final</span> String str <span class="token operator">=</span> <span class="token string">"xiaomi"</span><span class="token punctuation">;</span>    Inner inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//使用内部类</span>    inner<span class="token punctuation">.</span>innerMethod<span class="token punctuation">;</span>    <span class="token keyword">class</span> <span class="token class-name">Inner</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//定义内部类</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"outer a:"</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"param:"</span> <span class="token operator">+</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"test str:"</span> <span class="token operator">+</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法内部类的使用方式"><a href="#方法内部类的使用方式" class="headerlink" title="方法内部类的使用方式"></a>方法内部类的使用方式</h4><ol><li>在Outer类中的test方法中定义一个内部类Inner， <strong>方法内部类只能在定义的方法内被使用。</strong>    </li><li>方法内部类可以直接访问方法的方法参数与方法中的局部变量，  <strong>但是这些方法里的局部变量必须被声明为final，如上面的innerMethod方法所示，可直接访问param与final的str。</strong>  </li><li>如果方法是一个实例方法，则 <strong>方法内部类可以直接访问外部类的静态变量、静态方法、实例变量，实例方法。</strong>  </li><li>如果方法是一个静态方法，则 <strong>方法内部类 只能 访问外部类的静态变量、静态方法。</strong>   </li></ol><h4 id="方法内部类的思考"><a href="#方法内部类的思考" class="headerlink" title="方法内部类的思考"></a>方法内部类的思考</h4><p>似乎方法内部类有些多余，因为方法内部类能做的成员内部类也可以做到，至于方法参数也可以作为参数传递给成员内部类，我个人认为方法内部类的设计可能是出于能更好封装的目的，只能在被定义的方法中使用。  </p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><h4 id="匿名内部类的特征"><a href="#匿名内部类的特征" class="headerlink" title="匿名内部类的特征"></a>匿名内部类的特征</h4><p>与静态内部类、成员内部类、方法内部类不同，匿名内部类没有单独的定义，它在创建对象的同时定义类。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">new</span> 父类（参数列表）｛<span class="token comment" spellcheck="true">//匿名内部类的实现</span>｝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者如下使用：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">new</span> 父接口（）｛<span class="token comment" spellcheck="true">//匿名内部类的实现</span>｝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="匿名内部类的使用方式"><a href="#匿名内部类的使用方式" class="headerlink" title="匿名内部类的使用方式"></a>匿名内部类的使用方式</h4><p>匿名内部类是与new相关联的，在创建对象的时候定义类，new + 父类/父接口 +（） +｛｝，其中圆括号是传递给父类构造方法的参数，大括号里为类的定义。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">final</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>  Point p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//匿名内部类，其父类是Point。  </span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">distance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建Point对象的时候，定义了一个匿名内部类，这个类的父类是Point，创建对象的时候，给父类构造方法传递了参数2与参数3，重写了distance方法，在方法中访问了外部方法final参数x与y。   </p><ol><li>匿名内部类只能被使用一次,用来创建一个对象。</li><li>匿名内部类没有名字,没有构造方法,但可以根据参数列表,调用对应的父类构造方法。  </li><li>匿名内部类可以定义实例变量和方法,可以有初始化代码块,初始化代码块可以起到构造方法的作用,只是构造方法可以有多个,而初始化代码块只能有一份。  </li><li>匿名内部类因为没有构造方法,它自己无法接受参数,如果必须要参数,则应该使用其他内部类。与方法内部类一样,匿名内部类也可以访问外部类的所有变量和方法,可以访问方法中的final参数和局部变量。  </li></ol><h4 id="匿名内部类实现原理"><a href="#匿名内部类实现原理" class="headerlink" title="匿名内部类实现原理"></a>匿名内部类实现原理</h4><p>匿名内部类也都被生成为一个独立的类，只是类的名字以外部类加数字编号，是一个没有什么具体意义的名字。上面的代码段会产生两个类Outer和Outer$1，代码大概如下所示：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>        Point p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer</span>$<span class="token function">1</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>                                                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">distance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span>$<span class="token number">1</span> <span class="token keyword">extends</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x2<span class="token punctuation">;</span>    <span class="token keyword">int</span> y2<span class="token punctuation">;</span>    Outer outer<span class="token punctuation">;</span>    Outer$<span class="token function">1</span><span class="token punctuation">(</span>Outer outer<span class="token punctuation">,</span> <span class="token keyword">int</span> x1<span class="token punctuation">,</span> <span class="token keyword">int</span> y1<span class="token punctuation">,</span> <span class="token keyword">int</span> x2<span class="token punctuation">,</span> <span class="token keyword">int</span> y2<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span>y1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>outer <span class="token operator">=</span> outer<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x2 <span class="token operator">=</span> x2<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y2 <span class="token operator">=</span> y2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>                                  <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                     <span class="token keyword">return</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x2<span class="token punctuation">,</span>y2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与方法内部类类似，外部实例this，方法参数x和y都作为参数传递给了内部类构造方法。此外，new时的参数2和3也传递给了构造方法，内部类构造方法又将它们传递给了父类构造方法。</p><h4 id="匿名内部类使用场景"><a href="#匿名内部类使用场景" class="headerlink" title="匿名内部类使用场景"></a>匿名内部类使用场景</h4><p>匿名内部类能做的，方法内部类都能做。但如果对象只会创建一次，且不需要构造方法来接受参数，则可以使用匿名内部类，代码书写上更为简洁。<br>在调用方法时，很多方法需要一个接口参数，比如说Arrays.sort方法，它可以接受一个数组，以及一个Comparator接口参数，Comparator有一个方法compare用于比较两个对象。<br>比如说，我们要对一个字符串数组不区分大小写排序，可以使用Arrays.sort方法，但需要传递一个实现了Comparator接口的对象，这时就可以使用匿名内部类，代码如下所示：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sortIgnoreCase</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> strs<span class="token punctuation">)</span><span class="token punctuation">{</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strs<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>String o1<span class="token punctuation">,</span> String o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> o1<span class="token punctuation">.</span><span class="token function">compareToIgnoreCase</span><span class="token punctuation">(</span>o2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Comparator后面的<stirng>与泛型有关，表示比较的对象是字符串类型，后续文章会讲解泛型。<br>匿名内部类还经常用于事件处理程序中，用于响应某个事件，比如说一个Button，处理点击事件的代码可能类似如下：</stirng></p><pre class="line-numbers language-java"><code class="language-java">Button bt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Button</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bt<span class="token punctuation">.</span><span class="token function">addActionListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ActionListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span>ActionEvent e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//处理事件</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用addActionListener将事件处理程序注册到了Button对象bt中，当事件发生时，会调用actionPerformed方法，并传递事件详情ActionEvent作为参数。<br>以上Arrays.sort和Button都是上节提到的一种针对接口编程的例子，另外，它们也都是一种回调的例子。所谓回调是相对于一般的正向调用而言，平时一般都是正向调用，但Arrays.sort中传递的Comparator对象，它的compare方法并不是在写代码的时候被调用的，而是在Arrays.sort的内部某个地方回过头来调用的。Button中的传递的ActionListener对象，它的actionPerformed方法也一样，是在事件发生的时候回过头来调用的。<br>将程序分为保持不变的主体框架，和针对具体情况的可变逻辑，通过回调的方式进行协作，是计算机程序的一种常用实践。匿名内部类是实现回调接口的一种简便方式。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet（二）</title>
      <link href="/2018/12/08/Java%20Web%20%20Servlet2/"/>
      <url>/2018/12/08/Java%20Web%20%20Servlet2/</url>
      
        <content type="html"><![CDATA[<p>提要：Servlet配置路径、ServletConfig、ServletContext、</p><h3 id="1-Servlet配置路径（xml或者注解）"><a href="#1-Servlet配置路径（xml或者注解）" class="headerlink" title="1. Servlet配置路径（xml或者注解）"></a>1. Servlet配置路径（xml或者注解）</h3><p>假设项目名称为a。  </p><ol><li><p><strong>全路径匹配</strong>  </p><blockquote><p>以 / 开始　/a/aa/bb<br>localhost:8080/项目名称/aa/bb  </p></blockquote></li><li><p><strong>路径匹配 , 前半段匹配</strong>   </p><blockquote><p> 以/ 开始 , 但是以 * 结束 　　   / a / */*<br>符号 * 其实是一个通配符，匹配任意文字<br>localhost:8080/项目名称/aa/bb</p></blockquote></li><li><p><strong>以扩展名匹配</strong>    </p><blockquote><p>写法： 没有/　以 * 开始　　*.扩展名　　*.aa　　*.bb</p></blockquote></li></ol><h3 id="2-ServletConfig"><a href="#2-ServletConfig" class="headerlink" title="2. ServletConfig"></a>2. ServletConfig</h3><p>单个Servlet类的配置对象，通过这个对象，可以获取servlet在配置的时候一些信息  </p><h4 id="2-1-ServletConfig作用"><a href="#2-1-ServletConfig作用" class="headerlink" title="2.1 ServletConfig作用"></a>2.1 ServletConfig作用</h4><p>可以获取、设置单个servlet类的配置参数。例如当使用jar文件（class）放在自己的servlet类里面时，配置参数不固定，就可以使用ServletConfig方便的设置配置参数。  </p><h4 id="2-2-使用方法"><a href="#2-2-使用方法" class="headerlink" title="2.2 使用方法"></a>2.2 使用方法</h4><pre class="line-numbers language-java"><code class="language-java">  <span class="token comment" spellcheck="true">//1. 得到servlet配置对象 专门用于在配置servlet的信息  </span>  ServletConfig config <span class="token operator">=</span> <span class="token function">getServletConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取到的是配置servlet里面servlet-name 的文本内容  </span>  String servletName <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getServletName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"servletName="</span><span class="token operator">+</span>servletName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2、 可以获取具体的某一个参数。  </span>  String address <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getInitParameter</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"address="</span><span class="token operator">+</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3.获取所有的参数名称  </span>  Enumeration<span class="token operator">&lt;</span>String<span class="token operator">></span> names <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getInitParameterNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//遍历取出所有的参数名称  </span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String key <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> names<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String value <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getInitParameter</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"key==="</span><span class="token operator">+</span>key <span class="token operator">+</span> <span class="token string">"   value="</span><span class="token operator">+</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-ServletContext"><a href="#3-ServletContext" class="headerlink" title="3. ServletContext"></a>3. ServletContext</h3><p>每个web工程都只有一个ServletContext对象。也就是不管在哪个servlet里面，获取到的这个类的对象都是同一个。  </p><h4 id="3-1-ServletContext的作用"><a href="#3-1-ServletContext的作用" class="headerlink" title="3.1 ServletContext的作用"></a>3.1 ServletContext的作用</h4><ol><li>获取全局配置参数</li><li>获取web工程中的资源</li><li>存取数据，servlet间共享数据域对象  </li></ol><h5 id="3-1-1-ServletContext获取全局配置参数的方法"><a href="#3-1-1-ServletContext获取全局配置参数的方法" class="headerlink" title="3.1.1 ServletContext获取全局配置参数的方法()"></a>3.1.1 ServletContext获取全局配置参数的方法()</h5><pre class="line-numbers language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>  web<span class="token punctuation">.</span>xml文件里面 全局参数 ： 任何servlet都可以用，ServletContext <span class="token operator">--</span><span class="token operator">></span> <span class="token operator">&lt;</span>context<span class="token operator">-</span>param<span class="token operator">></span>   <span class="token operator">&lt;</span>param<span class="token operator">-</span>name<span class="token operator">></span>address<span class="token operator">&lt;</span><span class="token operator">/</span>param<span class="token operator">-</span>name<span class="token operator">></span>   <span class="token operator">&lt;</span>param<span class="token operator">-</span>value<span class="token operator">></span>深圳宝安<span class="token operator">&lt;</span><span class="token operator">/</span>param<span class="token operator">-</span>value<span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">/</span>context<span class="token operator">-</span>param<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取全局参数</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>    <span class="token function">doGet</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//1. 获取对象</span>    ServletContext context <span class="token operator">=</span> <span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String address <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getInitParameter</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是01获取的数据：：address="</span><span class="token operator">+</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-1-2-可以获取Web应用中的资源"><a href="#3-1-2-可以获取Web应用中的资源" class="headerlink" title="3.1.2 可以获取Web应用中的资源"></a>3.1.2 可以获取Web应用中的资源</h5><ol><li>获取资源在tomcat里面的绝对路径<br> 先得到路径，然后自己new InpuStream  <pre><code>   context.getRealPath(&quot;&quot;) //这里得到的是项目在tomcat里面的根目录。   D:\tomcat\apache-tomcat-7.0.52\apache-tomcat-7.0.52\wtpwebapps\Demo03\     String path = context.getRealPath(&quot;file/config.properties&quot;);   D:\tomcat\apache-tomcat-7.0.52\apache-tomcat-7.0.52\wtpwebapps\Demo03\file\config.properties</code></pre></li></ol><ol start="2"><li>getResourceAsStream 获取资源流对象。<br>直接给相对的路径，然后获取流对象。  </li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//获取web工程下的资源，转化为流对象。</span>InputStream is <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getResouceAsStream</span><span class="token punctuation">(</span><span class="token string">"file/config.properties"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-2-ServletContext周期"><a href="#3-2-ServletContext周期" class="headerlink" title="3.2 ServletContext周期"></a>3.2 ServletContext周期</h4><p>服务器启动的时候，会为托管的每一个web应用程序，创建一个ServletContext对象。<br>销毁该对象的方法：从服务器移除托管，或者是关闭服务器。   </p><h4 id="3-3-ServletContext的作用范围"><a href="#3-3-ServletContext的作用范围" class="headerlink" title="3.3 ServletContext的作用范围"></a>3.3 ServletContext的作用范围</h4><p>只要在同一个web项目里面，也就是同一个ServletContext对象，都可以取。</p><h3 id="4-HttpServletRequset"><a href="#4-HttpServletRequset" class="headerlink" title="4. HttpServletRequset"></a>4. HttpServletRequset</h3><p>HttpServletRequset类对象封装了客户端提交的一切数据。  </p><h4 id="4-1-可以获取客户端请求头信息"><a href="#4-1-可以获取客户端请求头信息" class="headerlink" title="4.1. 可以获取客户端请求头信息"></a>4.1. 可以获取客户端请求头信息</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//得到一个枚举集合  </span>Enumeration<span class="token operator">&lt;</span>String<span class="token operator">></span> headerNames <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeaderNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>headerNames<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      String name <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> headerNames<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      String value <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token operator">+</span><span class="token string">"="</span><span class="token operator">+</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-获取客户端提交过来的数据"><a href="#4-2-获取客户端提交过来的数据" class="headerlink" title="4.2. 获取客户端提交过来的数据"></a>4.2. 获取客户端提交过来的数据</h4><pre class="line-numbers language-java"><code class="language-java">String name <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String address <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name="</span><span class="token operator">+</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"address="</span><span class="token operator">+</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//-------------------------------------------------</span><span class="token comment" spellcheck="true">//name=zhangsan&amp;name=lisi&amp;name=wangwu 一个key可以对应多个值。</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> map <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameterMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set<span class="token operator">&lt;</span>String<span class="token operator">></span> keySet <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> iterator <span class="token operator">=</span> keySet<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String key <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"key="</span><span class="token operator">+</span>key <span class="token operator">+</span> <span class="token string">"--的值总数有："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        String value <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        String value1 <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        String value2 <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token operator">+</span><span class="token string">" ======= "</span><span class="token operator">+</span> value <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value1 <span class="token operator">+</span> <span class="token string">"="</span><span class="token operator">+</span> value2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-request获取中文数据乱码"><a href="#5-request获取中文数据乱码" class="headerlink" title="5. request获取中文数据乱码"></a>5. request获取中文数据乱码</h3><p>客户端提交数据给服务器端，如果数据中带有中文的话，有可能会出现乱码情况。  </p><ul><li><p><strong>GET方式</strong>  </p><ol><li>转码代码</li></ol></li></ul><pre class="line-numbers language-java"><code class="language-java">            String username <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String password <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"userName="</span><span class="token operator">+</span>username<span class="token operator">+</span><span class="token string">"==password="</span><span class="token operator">+</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//get请求过来的数据，在url地址栏上就已经经过编码了，所以我们取到的就是乱码，</span>            <span class="token comment" spellcheck="true">//tomcat收到了这批数据，getParameter 默认使用ISO-8859-1去解码</span>            <span class="token comment" spellcheck="true">//先让文字回到ISO-8859-1对应的字节数组 ， 然后再按utf-8组拼字符串</span>            username <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>username<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"userName="</span><span class="token operator">+</span>username<span class="token operator">+</span><span class="token string">"==password="</span><span class="token operator">+</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>2. 可以在tomcat里面做设置处理，以后get请求过来的数据永远都是用UTF-8编码。</code></pre><p>  conf/server.xml 加上URIEncoding=”utf-8”</p><pre class="line-numbers language-java"><code class="language-java">          <span class="token operator">&lt;</span>Connector connectionTimeout<span class="token operator">=</span><span class="token string">"20000"</span> port<span class="token operator">=</span><span class="token string">"8080"</span> protocol<span class="token operator">=</span><span class="token string">"HTTP/1.1"</span>  redirectPort<span class="token operator">=</span><span class="token string">"8443"</span> URIEncoding<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">/</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>POST方式</strong><br>需要设置请求体里面的文字编码。<br><strong>request.setCharacterEncoding(“UTF-8”);</strong><br>这行设置一定要写在getParameter方法之前之前。  </li></ul><h3 id="6-HttpServletResponse"><a href="#6-HttpServletResponse" class="headerlink" title="6. HttpServletResponse"></a>6. HttpServletResponse</h3><p>负责返回数据给客户端。</p><ul><li>输出数据到页面上</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//以字符流的方式写数据</span>response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"&lt;h1>hello response...&lt;/h1>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//以字节流的方式写数据</span>response<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"hello response2222..."</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="响应的数据中有中文，则有可能出现中文乱码情况"><a href="#响应的数据中有中文，则有可能出现中文乱码情况" class="headerlink" title="响应的数据中有中文，则有可能出现中文乱码情况"></a>响应的数据中有中文，则有可能出现中文乱码情况</h4><ul><li>以字符流输出    <blockquote><p>response.getWriter()<br><code>`</code>java<br>//1. 指定输出到客户端的时候，这些文字使用UTF-8编码<br>response.setCharacterEncoding(“UTF-8”);</p></blockquote></li></ul><p>//2. 直接规定浏览器看这份数据的时候，使用什么编码来看。<br>response.setHeader(“Content-Type”, “text/html; charset=UTF-8”);</p><p>response.getWriter().write(“响应…”);</p><pre><code>+ 以字节流输出&gt; response.getOutputStream()```java  //1. 指定浏览器看这份数据使用的码表response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;);//2. 指定输出的中文用的码表response.getOutputStream().write(&quot;响应..&quot;.getBytes(&quot;UTF-8&quot;));</code></pre><p><strong>不管是字节流还是字符流，直接使用下面一行代码就可以了。</strong><br><strong>response.setContentType(“text/html;charset=UTF-8”);</strong> 然后在写数据即可。</p>]]></content>
      
      
      <categories>
          
          <category> Servlet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet（一）</title>
      <link href="/2018/12/08/Java%20Web%20%20Servlet1/"/>
      <url>/2018/12/08/Java%20Web%20%20Servlet1/</url>
      
        <content type="html"><![CDATA[<p>提要：Servlet执行过程、执行周期。  </p><p>在java中，JVM是java程序唯一认识的“操作系统”，其可执行文件为 <strong>.class</strong> 。<br>在Servlet/JSP中，web容器（Container）是Servlet/JSP唯一认识的HTTP服务器。我们需要知道Servlet/JSP与web容器是如何沟通的，web容器如何管理Servlet/JSP的各种对象等问题。  </p><h3 id="Hello-Servlet"><a href="#Hello-Servlet" class="headerlink" title="Hello Servlet"></a>Hello Servlet</h3><ol><li>新建一个类， 实现Servlet接口</li><li>配置Servlet ， 用意： 告诉服务器，我们的应用有这么些个servlet。<br>在webContent/WEB-INF/web.xml里面写上以下内容。  </li></ol><pre class="line-numbers language-java"><code class="language-java">  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 向tomcat报告， 这个应用里面有这个servlet， 名字叫做HelloServlet <span class="token punctuation">,</span> 具体的路径是com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>HelloServlet <span class="token operator">--</span><span class="token operator">></span>  <span class="token operator">&lt;</span>servlet<span class="token operator">></span>      <span class="token operator">&lt;</span>servlet<span class="token operator">-</span>name<span class="token operator">></span>HelloServlet<span class="token operator">&lt;</span><span class="token operator">/</span>servlet<span class="token operator">-</span>name<span class="token operator">></span>      <span class="token operator">&lt;</span>servlet<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">></span>com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>HelloServlet<span class="token operator">&lt;</span><span class="token operator">/</span>servlet<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>servlet<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 注册servlet的映射。  servletName <span class="token operator">:</span> 找到上面注册的具体servlet，  url<span class="token operator">-</span>pattern<span class="token operator">:</span> 在地址栏上的path 一定要以<span class="token operator">/</span>打头 <span class="token operator">--</span><span class="token operator">></span>  <span class="token operator">&lt;</span>servlet<span class="token operator">-</span>mapping<span class="token operator">></span>      <span class="token operator">&lt;</span>servlet<span class="token operator">-</span>name<span class="token operator">></span>HelloServlet<span class="token operator">&lt;</span><span class="token operator">/</span>servlet<span class="token operator">-</span>name<span class="token operator">></span>      <span class="token operator">&lt;</span>url<span class="token operator">-</span>pattern<span class="token operator">></span><span class="token operator">/</span>a<span class="token operator">&lt;</span><span class="token operator">/</span>url<span class="token operator">-</span>pattern<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>servlet<span class="token operator">-</span>mapping<span class="token operator">></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>在地址栏上输入 <a href="http://localhost:8080/项目名称/a" target="_blank" rel="noopener">http://localhost:8080/项目名称/a</a></li></ol><h3 id="Servlet执行过程（xml方式）"><a href="#Servlet执行过程（xml方式）" class="headerlink" title="Servlet执行过程（xml方式）"></a>Servlet执行过程（xml方式）</h3><p><a href="http://localhost:8080/HelloServlet/a" target="_blank" rel="noopener">http://localhost:8080/HelloServlet/a</a></p><ol><li>tomcat应用</li><li>找到具体项目</li><li>找到web.xml，在Servlet-mapping部分找url-pattern与a相对应的servlet-name。</li><li>在servlet部分找到servlet-name相对应的servlet-class</li><li>找到具体的类后创建该类实例</li><li>执行Servlet中的service方法  </li></ol><h3 id="Servlet的通用写法"><a href="#Servlet的通用写法" class="headerlink" title="Servlet的通用写法"></a>Servlet的通用写法</h3><blockquote><pre><code>   Servlet (接口)        |        |    GenericServlet        |        |    HttpServlet （用于处理http的请求）  </code></pre></blockquote><p>例如： 定义一个类，继承HttpServlet 复写doGet 和 doPost</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloServlet02</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//Get请求会来这个方法</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest req<span class="token punctuation">,</span> HttpServletResponse resp<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"get---"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//POST请求会来这个方法</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span>HttpServletRequest req<span class="token punctuation">,</span> HttpServletResponse resp<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"post----"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在service方法中的主要工作是判断是该使用doGet方法、doPost方法或者其他方法。  </p><h3 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h3><ul><li>生命周期</li></ul><blockquote><p>从创建到销毁的一段时间</p></blockquote><ul><li>生命周期方法</li></ul><blockquote><p>从创建到销毁，所调用的那些方法。</p></blockquote><ul><li><p>init方法</p><pre><code>  在创建该servlet的实例时，就执行该方法。  一个servlet只会初始化一次， init方法只会执行一次  默认情况下是 ： 初次访问该servlet，才会创建实例。</code></pre></li><li><p>service方法</p><pre><code>  只要客户端来了一个请求，那么就执行这个方法了。    该方法可以被执行很多次。 一次请求，对应一次service方法的调用</code></pre></li><li><p>destroy方法<br>servlet销毁的时候，就会执行该方法</p><pre><code>1. 该项目从tomcat的里面移除。2. 正常关闭tomcat就会执行 shutdown.bat</code></pre></li></ul><blockquote><p>doGet 和 doPost不算生命周期方法，所谓的生命周期方法是指，从对象的创建到销毁一定会执行的方法， 但是这两个方法，不一定会执行。</p></blockquote><h3 id="让Servlet创建实例的时机提前。"><a href="#让Servlet创建实例的时机提前。" class="headerlink" title="让Servlet创建实例的时机提前。"></a>让Servlet创建实例的时机提前。</h3><ol><li><p>默认情况下，只有在初次访问servlet的时候，才会执行init方法。 有的时候，我们可能需要在这个方法里面执行一些初始化工作，甚至是做一些比较耗时的逻辑。</p></li><li><p>那么这个时候，初次访问，可能会在init方法中逗留太久的时间。 那么改变思路，使用其他办法可以让这个初始化的时机提前一点。</p></li><li><p>在配置的时候， 使用load-on-startup元素来指定， 给定的数字越小，启动的时机就越早。 一般不写负数， 从2开始即可。</p></li></ol><pre class="line-numbers language-java"><code class="language-java">        <span class="token operator">&lt;</span>servlet<span class="token operator">></span>              <span class="token operator">&lt;</span>servlet<span class="token operator">-</span>name<span class="token operator">></span>HelloServlet04<span class="token operator">&lt;</span><span class="token operator">/</span>servlet<span class="token operator">-</span>name<span class="token operator">></span>              <span class="token operator">&lt;</span>servlet<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">></span>com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>HelloServlet04<span class="token operator">&lt;</span><span class="token operator">/</span>servlet<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">></span>              <span class="token operator">&lt;</span>load<span class="token operator">-</span>on<span class="token operator">-</span>startup<span class="token operator">></span><span class="token number">2</span><span class="token operator">&lt;</span><span class="token operator">/</span>load<span class="token operator">-</span>on<span class="token operator">-</span>startup<span class="token operator">></span>          <span class="token operator">&lt;</span><span class="token operator">/</span>servlet<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Servlet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java源码-剖析HashSet</title>
      <link href="/2018/11/30/Java%20HashSet/"/>
      <url>/2018/11/30/Java%20HashSet/</url>
      
        <content type="html"><![CDATA[<p>Map接口中的keySet方法与entrySet方法返回值类型的都是Set。  </p><h3 id="HashSet的Set接口"><a href="#HashSet的Set接口" class="headerlink" title="HashSet的Set接口"></a>HashSet的Set接口</h3><p><strong>Set表示的是没有重复元素、且不保证顺序的容器接口</strong> ，它扩展了Collection接口，Set接口虽然没有再定义一些自己的新的方法，但是Set接口对于Collection接口中的一些方法，它有自己的规范。<br>Set接口的定义为：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span><span class="token punctuation">;</span>    Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">containsAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">retainAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">removeAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与Collection接口中定义的方法是一样的，不过，一些方法有一些不同的规范要求。</p><h4 id="添加元素-add（E-e）方法"><a href="#添加元素-add（E-e）方法" class="headerlink" title="添加元素 add（E e）方法"></a>添加元素 add（E e）方法</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只会添加集合中不存在的元素并返回true，否则直接返回false。  </p><h4 id="批量添加"><a href="#批量添加" class="headerlink" title="批量添加"></a>批量添加</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只添加不重复的，如果集合有变化，返回true，没变化返回false。  </p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><pre class="line-numbers language-java"><code class="language-java">Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>遍历时，元素之间没有特别的顺序。  </p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>与HashMap类似，HashSet的构造方法有：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HashSet的平常用法如下：</p><pre class="line-numbers language-java"><code class="language-java">Set<span class="token operator">&lt;</span>String<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token string">"java"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>String s <span class="token operator">:</span> set<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//输出为：</span>hello java world<span class="token string">"hello"</span>被添加了两次，但只会保存一份。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="hashCode与equals"><a href="#hashCode与equals" class="headerlink" title="hashCode与equals"></a>hashCode与equals</h4><p>与HashMap类似，HashSet要求元素重写hashCode和equals方法，且对两个对象，equals相同，则hashCode也必须相同，如果元素是自定义的类，需要注意这一点。<br>比如说，有一个表示规格的类Spec，有大小和颜色两个属性：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Spec</span> <span class="token punctuation">{</span>    String size<span class="token punctuation">;</span>    String color<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Spec</span><span class="token punctuation">(</span>String size<span class="token punctuation">,</span> String color<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"[size="</span> <span class="token operator">+</span> size <span class="token operator">+</span> <span class="token string">", color="</span> <span class="token operator">+</span> color <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//看一个Spec的Set：</span>Set<span class="token operator">&lt;</span>Spec<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>Spec<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Spec</span><span class="token punctuation">(</span><span class="token string">"M"</span><span class="token punctuation">,</span><span class="token string">"red"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Spec</span><span class="token punctuation">(</span><span class="token string">"M"</span><span class="token punctuation">,</span><span class="token string">"red"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token punctuation">[</span>size<span class="token operator">=</span>M<span class="token punctuation">,</span> color<span class="token operator">=</span>red<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>size<span class="token operator">=</span>M<span class="token punctuation">,</span> color<span class="token operator">=</span>red<span class="token punctuation">]</span><span class="token punctuation">]</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同一个规格输出了两次，为避免这一点，需要为Spec重写hashCode和equals方法，利用IDE开发工具往往可以自动生成这两个方法，比如Eclipse中，可以通过”Source”-&gt;”Generate hashCode() and equals() …”。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>HashSet有很多应用场景，比如说：</p><ol><li>排重，如果对排重后的元素没有顺序要求，则HashSet可以方便的用于排重。</li><li>保存特殊值，Set可以用于保存各种特殊值，程序处理用户请求或数据记录时，根据是否为特殊值，进行特殊处理，比如保存IP地址的黑名单或白名单。</li><li>集合运算，使用Set可以方便的进行数学集合中的运算，如交集、并集等运算，这些运算有一些很现实的意义。比如用户标签计算，每个用户都有一些标签，两个用户的标签交集就表示他们的共同特征，交集大小除以并集大小可以表示他们的相似长度。  </li></ol><h3 id="HashSet实现原理"><a href="#HashSet实现原理" class="headerlink" title="HashSet实现原理"></a>HashSet实现原理</h3><h4 id="内部组成"><a href="#内部组成" class="headerlink" title="内部组成"></a>内部组成</h4><p>HashSet内部是用HashMap实现的，它内部有一个HashMap实例变量，如下所示：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">transient</span> HashMap<span class="token operator">&lt;</span>E<span class="token punctuation">,</span>Object<span class="token operator">></span> map<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>Map有键和值，HashSet相当于只有键(要存的元素、对象)，值都是相同的固定值</strong>，这个值的定义为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>HashSet的构造方法，主要就是调用了对应的HashMap的构造方法，比如：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接受Collection参数的构造方法稍微不一样，代码为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token number">75f</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>也很容易理解，</p><pre class="line-numbers language-java"><code class="language-java">c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token number">75f</span>用于计算initialCapacity，<span class="token number">0.75f</span>是loadFactor的默认值。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>我们看add方法的代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>就是调用map的put方法，元素e用于键，值就是那个固定值PRESENT，put返回null表示原来没有对应的键，添加成功了。HashMap中一个键只会保存一份，所以重复添加HashMap不会变化。</p><h4 id="检查是否包含元素"><a href="#检查是否包含元素" class="headerlink" title="检查是否包含元素"></a>检查是否包含元素</h4><p>代码为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>就是检查map中是否包含对应的键。</p><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>代码为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token operator">==</span>PRESENT<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>就是调用map的remove方法，返回值为PRESENT表示原来有对应的键且删除成功了。</p><p>迭代器</p><p>代码为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>就是返回map的keySet的迭代器。</p><h3 id="HashSet总结"><a href="#HashSet总结" class="headerlink" title="HashSet总结"></a>HashSet总结</h3><p>HashSet实现了Set接口，内部是通过HashMap实现的，这决定了它有如下特点：</p><ol><li>没有重复元素</li><li>可以高效的添加、删除元素、判断元素是否存在，效率都为O(1)。</li><li>没有顺序<br>如果需求正好符合这些特点，那HashSet就是一个理想的选择。  </li></ol><p>HashSet实现了Set接口，不含重复元素，内部实现利用了HashMap，可以方便高效地实现如去重、集合运算等功能。同HashMap一样，HashSet<strong>没有顺序</strong>，如果要保持添加的顺序，可以使用<strong>HashSet的一个子类LinkedHashSet</strong>。Set还有一个重要的实现类，<strong>TreeSet</strong>，它可以排序。HashMap和HashSet的共同实现机制是哈希表，Map和Set还有一个重要的共同实现机制，<strong>树</strong>，实现类分别是<strong>TreeMap</strong>和<strong>TreeSet</strong> 。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> java源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java源码-剖析HashMap</title>
      <link href="/2018/11/25/Java%20HashMap/"/>
      <url>/2018/11/25/Java%20HashMap/</url>
      
        <content type="html"><![CDATA[<p>ArrayList与LinkedList的缺点就是按元素内容查找值时，查找元素的时间复杂度都较高，而HashMap查找元素的时间复杂度可以达到O(1)!<br>Map在这里是映射的关系，K-V之间相互映射，计算K的hashCode值，根据这个值去计算（取模 数组的长度）HashMap内部所维护数组的索引i，当然，这个i值可能会重复，对于重复的值，在java7中使用链表继续存储。<strong>数组里存的内容也是一个Entry对象。</strong><br>取值时要通过K来取，若K的hash值所找到的位置发生了hash碰撞（有链表），就使用equal方法比较具体的K值。  </p><h3 id="HashMap所实现的Map接口"><a href="#HashMap所实现的Map接口" class="headerlink" title="HashMap所实现的Map接口"></a>HashMap所实现的Map接口</h3><p>Map有键（Key）与V（value），并且这俩是相对应的，由键间接的得到要存储与访问的地址，所以键（Key）是不能重复的，如果重复了，其所对应的值也会被覆盖掉。在以下场景中使用Map会很方便：  </p><blockquote><ol><li>一个词典应用，键可以为单词，值可以为单词信息类，包括含义、发音、例句等。  </li><li>统计和记录一本书中所有单词出现的次数，可以以单词为键，出现次数为值。  </li><li>管理配置文件中的配置项，配置项是典型的键值对。  </li><li>根据身份证号查询人员信息，身份证号为键，人员信息为值。    </li></ol></blockquote><p>其实从一一对应的角度来说，array、ArrayList、LinkedList也可以看作为一种特殊的Map，将他们的索引看做键（Key），将元素内容（对象）看做值。<br>Map接口：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">containsKey</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">containsValue</span><span class="token punctuation">(</span>Object value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">putAll</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Set<span class="token operator">&lt;</span>K<span class="token operator">></span> <span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span><span class="token punctuation">;</span>    V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span><span class="token punctuation">;</span>    V <span class="token function">remove</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span><span class="token punctuation">;</span>    Collection<span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Set<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">>></span> <span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">interface</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>        K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        V <span class="token function">setValue</span><span class="token punctuation">(</span>V value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Map接口中的方法都比较简单，其中put方法中，判断Key是否重复的依据是要么为null（存在索引为0的位置）要么equal返回false。  </p><h3 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h3><p>HashMap内部主要维护了以下成员变量：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">transient</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table <span class="token operator">=</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> EMPTY_TABLE<span class="token punctuation">;</span><span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//实际键值对的个数</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>数组table初始化为EMPTY_TABLE，而EMPTY_TABLE定义为一个静态常量的空表。table会随着实际情况（与threshold有关）进行长度的增加，类似于ArrayList，不过添加第一个元素时默认分配长度为16（ArrayList初始长度不为空表，长度为10）。threshold表示阈值，当键值对个数size大于等于threshold时考虑进行扩展,threshold = table.length*loadFactor。loadFactor是负载因子，<strong>表示整体上table能被占用的程度</strong> ，默认值为0.75，可以通过构造方法修改。<br>HashMap里面也有一个内部类Entry，它实现了Map接口的内部接口Entry&lt;K,V&gt;。上面的table是一个HashMap内部类Entry类型的数组，数组的每个元素指向一个单链表（索引重复时放链表），并且这个链表的每个节点表示一个键值对。 HashMap中的内部类Entry主要如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">final</span> K key<span class="token punctuation">;</span>  V value<span class="token punctuation">;</span>  Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>  <span class="token keyword">int</span> hash<span class="token punctuation">;</span>  <span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> K k<span class="token punctuation">,</span> V v<span class="token punctuation">,</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>      value <span class="token operator">=</span> v<span class="token punctuation">;</span>      next <span class="token operator">=</span> n<span class="token punctuation">;</span>      key <span class="token operator">=</span> k<span class="token punctuation">;</span>      hash <span class="token operator">=</span> h<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p>其中int型的hash记录每个Key的哈希值，减少了哈希值的计算次数。Entry型的next指向下一个Entry节点。<br>以下是使用put方法进行键值对保存的过程：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> EMPTY_TABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是第一次保存键值对（初始为空表），就会调用inflateTable()方法给table分配空间，inflateTable方法主要如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inflateTable</span><span class="token punctuation">(</span><span class="token keyword">int</span> toSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Find a power of 2 >= toSize</span>    <span class="token keyword">int</span> capacity <span class="token operator">=</span> <span class="token function">roundUpToPowerOf2</span><span class="token punctuation">(</span>toSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>capacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认情况下，capacity的值为16，threshold会变为12，table会分配一个长度为16的Entry数组。然后若key是否为null调用putForNullKey单独处理（后面再说），否则调用hash（）方法计算key的哈希值，hash（）方法的代码为：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">0</span>    h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>基于key自身的hashCode方法的返回值，又进行了一些位运算，目的是为了随机和均匀性。  </p></blockquote><p>有了hash值之后，调用indexFor方法，计算应该将这个键值对要放到数组table的索引，代码为：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>HashMap中，<strong>length为2的幂次方</strong>，<strong>h&amp;(length-1)</strong> 等同于求模运算：<strong>h%length</strong>。<br>找到了保存位置i，table[i]指向一个单向链表，接下来，就是在这个链表中逐个查找是否已经有这个键了，遍历代码为：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>而比较的时候，是先比较hash值，hash相同的时候，再使用equals方法进行比较，代码为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>先比较hash是因为hash是整数，比较的性能一般要比equals比较高很多，如果连hash都不同，就没有必要调用equals方法了，这样整体上可以提高比较性能。如果能找到，直接修改Entry中的value即可。modCount++的意义与ArrayList和LinkedList中的一样，记录修改次数，以方便在迭代中检测结构性变化。如果没找到，则调用addEntry方法在给定的位置添加一条，代码为：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果空间是够的，不需要resize，则调用createEntry添加，createEntry的代码为：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码比较直接，新建一个Entry对象，并插入单向链表的头部，并增加size。<br>如果空间不够，即size已经要超过阈值threshold了，并且对应的table位置已经插入过对象了，具体检查代码为：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>则调用resize方法对table进行扩展，扩展策略是乘2，resize的主要代码为：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">,</span> <span class="token function">initHashSeedAsNeeded</span><span class="token punctuation">(</span>newCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分配一个容量为原来两倍的Entry数组</strong>，调用transfer方法将原来的键值对移植过来，然后更新内部的table变量，以及threshold的值。<strong>transfer</strong> 方法的代码为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>null <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span>hash <span class="token operator">=</span> null <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//重新计算在新数组里的i值</span>            e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            e <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数rehash一般为false。这段代码遍历原来的每个键值对，计算新位置，并保存到新位置。<br>以上，就是保存键值对的主要代码，简单总结一下，基本步骤为：</p><ol><li>计算键的哈希值</li><li>根据哈希值得到保存位置（取模）</li><li>插到对应位置的链表头部或更新已有值</li><li>根据需要扩展table大小   </li></ol><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">getForNullKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> entry <span class="token operator">=</span> <span class="token function">getEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null <span class="token operator">==</span> entry <span class="token operator">?</span> null <span class="token operator">:</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>HashMap的key可以为null</strong> ，key为null的时候，放在table[0]，调用getForNullKey()获取值，如果key不为null，则调用getEntry()获取键值对节点entry，然后调用节点的getValue()方法获取值。getEntry方法的代码是：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getEntry</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         e <span class="token operator">!=</span> null<span class="token punctuation">;</span>         e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> e<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本思想如下：  </p><ol><li>计算键的hash值；</li><li>根据hash找到table中的对应链表；</li><li>在链表中遍历查找；</li><li>逐个比较，先通过hash快速比较，hash相同再通过equals比较；</li></ol><h4 id="方法containsValue-查看是否包含某些值"><a href="#方法containsValue-查看是否包含某些值" class="headerlink" title="方法containsValue()  查看是否包含某些值"></a>方法containsValue()  查看是否包含某些值</h4><p>HashMap可以方便高效的按照键进行操作，但如果要根据值进行操作，则需要遍历，containsValue方法的代码为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsValue</span><span class="token punctuation">(</span>Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">containsNullValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tab<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">;</span> e <span class="token operator">!=</span> null <span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要查找的值为null，则调用containsNullValue单独处理，我们看不为null的情况，遍历的逻辑也很简单，就是从table的第一个链表开始，从上到下，从左到右逐个节点进行访问，通过equals方法比较值，直到找到为止。  </p><h4 id="方法remove-根据键删除键值对"><a href="#方法remove-根据键删除键值对" class="headerlink" title="方法remove()  根据键删除键值对"></a>方法remove()  根据键删除键值对</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">remove</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> <span class="token function">removeEntryForKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>removeEntryForKey()方法的代码为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">removeEntryForKey</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> prev <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            modCount<span class="token operator">++</span><span class="token punctuation">;</span>            size<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> e<span class="token punctuation">)</span>                table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token keyword">else</span>                prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordRemoval</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> e<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        prev <span class="token operator">=</span> e<span class="token punctuation">;</span>        e <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本逻辑为：</p><ol><li>计算hash，根据hash找到对应的table索引;</li><li>遍历table[i]，查找待删节点，使用变量prev指向前一个节点，next指向下一个节点，e指向当前节点，遍历结构代码为：</li></ol><blockquote><pre class="line-numbers language-java"><code class="language-java">Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> prev <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> prev<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>找到了<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//删除</span>       <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    prev <span class="token operator">=</span> e<span class="token punctuation">;</span>    e <span class="token operator">=</span> next<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ol start="3"><li>判断是否找到，依然是先比较hash，hash相同时再用equals方法比较;  </li><li>删除的逻辑就是让长度减小，然后让待删节点的前后节点连起来，如果待删节点是第一个节点，则让table[i]直接指向后一个节点;<br>e.recordRemoval(this);在HashMap中代码为空，主要是为了HashMap的子类扩展使用。  <h4 id="实现原理小结"><a href="#实现原理小结" class="headerlink" title="实现原理小结"></a>实现原理小结</h4>HashMap内部有一个数组table，<strong>每个元素table[i]指向一个单向链表</strong> ，根据键存取值，用键算出hash，取模得到数组中的索引位置buketIndex，然后操作table[buketIndex]指向的单向链表。<br>存取的时候依据键的hash值，只在对应的链表中操作，不会访问别的链表，在对应链表操作时也是先比较hash值，相同的话才用equals方法比较，这就要求，相同的对象其hashCode()返回值必须相同，如果键是自定义的类，就特别需要注意这一点。这也是hashCode和equals方法的一个关键约束，这个约束我们在介绍包装类的时候也提到过。</li></ol><h3 id="HashMap总结"><a href="#HashMap总结" class="headerlink" title="HashMap总结"></a>HashMap总结</h3><p>HashMap实现了Map接口，内部使用数组链表和哈希的方式进行实现，这决定了它有如下特点：</p><ol><li>根据键保存和获取值的效率都很高，为O(1)，每个单向链表往往只有一个或少数几个节点，根据hash值就可以直接快速定位。</li><li>HashMap中的键值对没有顺序，因为hash值是随机的。  </li></ol><p>如果经常需要根据键存取值，而且不要求顺序，那HashMap就是理想的选择。<br>根据哈希值存取对象、比较对象是计算机程序中一种重要的思维方式，它使得存取对象主要依赖于自身哈希值，而不是与其他对象进行比较，存取效率也就与集合大小无关，高达O(1)，即使进行比较，也利用哈希值提高比较性能。不过HashMap没有顺序，如果要保持添加的顺序，可以使用<strong>HashMap的一个子类LinkedHashMap</strong>，子类LinkedHashMap可以排序。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> java源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java泛型</title>
      <link href="/2018/11/22/Java%20Generic/"/>
      <url>/2018/11/22/Java%20Generic/</url>
      
        <content type="html"><![CDATA[<h3 id="泛型来源"><a href="#泛型来源" class="headerlink" title="泛型来源"></a>泛型来源</h3><p>前面用到了集合，可以存储自定义的对象然后进行遍历操作，由于可存储的对象可以是任意类型的，因此就可能在转换时出现类型转换异常，Java为了解决这个问题，提出了一种机制 – 泛型（Generic）。<br>泛型把明确具体类型的工作提前到了编译时期。<br>集合都是基于泛型的，泛型的基本思想与概念是简单的，但是泛型有一些比较令人费解的语法，细节和局限性。本文主要阐述泛型的基本概念与原理、通配符、泛型需要注意的一些细节与局限性。  </p><h3 id="泛型基本概念与原理"><a href="#泛型基本概念与原理" class="headerlink" title="泛型基本概念与原理"></a>泛型基本概念与原理</h3><p>泛型的字面意思就是广泛的类型。类、接口与方法都可以应用于很广泛的类型。 <strong>代码与他们能够操作的数据类型不再紧密的绑定在一起</strong>，同一段代码可以处理不同的数据类型，有代码复用、降低耦合、提高代码的可读性与安全性的优点。  </p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类（Generic Class）时，我们只关注泛型，而不用专注于数据存储的细节。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>  T first<span class="token punctuation">;</span>  T second<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token function">Pair</span><span class="token punctuation">(</span>T first<span class="token punctuation">,</span> T second<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> T <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> first<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> T <span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> second<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所定义的泛型类Pair与普通类有以下区别：  </p><ul><li>类名后加了<t>;  </t></li><li>成员变量first与second的类型为T；  </li></ul><p>T表示 <strong>类型参数</strong> ，<strong>泛型就是类型参数化，处理的数据类型不是固定的，而是可以作为参数传入。</strong><br>需要注意的是，T只是一个符号，编译器会把T统一的进行修改。T也可以替换为Ti，s等等，只要一致就可以。但是对于泛型的类型参数一般使用大写字母，并且比较短，在Java的标准类库中变量E表示集合的元素，符号K与V分别表示表的关键字与关键字与值的类型，字母T或者U、S表示任意类型。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//java泛型类的具体使用</span>Pair<span class="token operator">&lt;</span>Integer<span class="token operator">></span> minmax <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//后面尖括号里的类型可以省略</span>Integer min <span class="token operator">=</span> minmax<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer max <span class="token operator">=</span> minmax<span class="token punctuation">.</span><span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当然在定义泛型类时候也可以定义多个类型参数，例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span>S<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//......</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>泛型的类型参数T到底是什么？为什么不直接定义一个Object类（在对象里使用时再使用向下转型也就是强制类型转换）而要再次定义类型参数呢？<br>实际上，Java泛型的内部原理是这样的：</p><blockquote><p>众所周知，编译器将Java源代码转换为.class问文件，虚拟机加载并运行.class问文件。而对于泛型类，编译器会将泛型类的代码转换为普通的非泛型代码</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java源码-剖析LinkedList</title>
      <link href="/2018/11/20/Java%20LinkedList/"/>
      <url>/2018/11/20/Java%20LinkedList/</url>
      
        <content type="html"><![CDATA[<p>ArrayLis通过索引值随机访问的效率很高，但是插入与删除的性能比较低；LinkedList也实现了List接口，而LIst接口扩展了Collection接口，Collection接口又扩展了Iterable接口。同时LinkedList还实现了队列接口Queue，就是平时说的队列，两个操作点，尾部加元素，头部删元素，先进先出。<br>但是LinkedList与ArrayList的特点几乎刚好相反。  </p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>LinkedList的构造方法有两个，与ArrayList类似。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">LinkedList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Queue接口：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Queue</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">{</span>  <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//尾部添加元素  队满 抛出异常</span>  <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//尾部添加元素  队满 返回false</span>  E <span class="token function">romove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//删除头部元素  队为空 抛出异常</span>  E <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//删除头部元素  队为空 返回null</span>  E <span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//查看头部元素  队为空 抛出异常</span>  E <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//查看头部元素  队为空 返回null</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，LinkedList可以使用上面Queue的接口去当做栈使用。<br>其实，LinkedList是直接实现了Deque<e>接口，而Deque接口扩展了Queue接口。Deque接口有着更为通用的方法，包含了栈的操作方法。<br>Deque接口：  </e></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Deque</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Queue</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">{</span>  <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">boolean</span> <span class="token function">offerFirst</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">boolean</span> <span class="token function">offerLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>  E <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  E <span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  E <span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  E <span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  E <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  E <span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  E <span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  E <span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>xxxFirst操作头部，xxxLast操作尾部。每种操作两种方法，也是因为队满或者队空时处理方法不同。addXXX/getXXX/removeXXX抛异常，peekXXX/pollXXX返回null，offerXXX返回false。<br>综上，LinkedList由于实现了Duque接口，所以可以把它看做队列、栈、双端队列。  </p><h3 id="实现原理（java7）"><a href="#实现原理（java7）" class="headerlink" title="实现原理（java7）"></a>实现原理（java7）</h3><h4 id="内部组成"><a href="#内部组成" class="headerlink" title="内部组成"></a>内部组成</h4><p>ArrayList内部是数组，元素在内存中是连续存放的。但是LinkedList的内部实现是 <strong>双向链表</strong> ，其每个元素在内存中都是单独存放的，元素之间通过链接连在一起。<br>数据结构链表中的节点Node在java中由静态内部类实现。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">{</span>  E item<span class="token punctuation">;</span>  Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span>  Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">;</span>  <span class="token function">Node</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span>prev<span class="token punctuation">,</span>E element<span class="token punctuation">,</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LinkedList主要就是操作以下三个成员变量。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> first<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//头结点</span><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> last<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//尾节点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>add（）方法的主要步骤：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>last <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span> first <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token keyword">else</span> l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>size<span class="token operator">++</span><span class="token punctuation">;</span>modCount<span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1)  创建一个新的节点newNode。l与last指向原来的尾节点，如果原来链表为空，则为null。<br>2） 修改尾节点last，指向最新的最后节点newNode。<br>3） 修改前节点的向后链接，如果原来链表为空，则让头结点指向新节点，否则让前一个节点next指向新节点。<br>4） 增加链表大小。<br>注意：modCount++的目的与在ArrayList中是一样的，记录修改次数，便于迭代过程中检测结构性变化。<br><strong>LinkedList的内存是按需分配的。</strong><br>add（）方法是在尾部插入，当然也可以在头部或者中间插入元素 public void add(int index, E element)。具体过程如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span>        <span class="token function">linkLast</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">linkBefore</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">linkBefore</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> succ<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// assert succ != null;</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> pred <span class="token operator">=</span> succ<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> e<span class="token punctuation">,</span> succ<span class="token punctuation">)</span><span class="token punctuation">;</span>    succ<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">==</span> null<span class="token punctuation">)</span>        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token keyword">else</span>        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>succ：后继节点，pred：前驱节点。在这两个节点中间插入一个节点。步骤如下：<br>1）创建一个newNode节点。<br>2) succ的前驱指向新节点newNode。<br>3) pred的前驱指向新节点newNode，若前驱为null，将头结点first指向新节点newNode。<br>4）增加长度。<br>通过索引删除元素的主要过程如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//通过Node（）方法找到节点后，调用unlink（Node&lt;E> x）方法</span>E <span class="token function">unlink</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// assert x != null;</span>    <span class="token keyword">final</span> E element <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        first <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        last <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        next<span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    x<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>    size<span class="token operator">--</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> element<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>基本思路就是让x的前驱和后继直接链接起来，next是x的后继，prev是x的前驱，具体分为两步：  </p><ol><li>让x的前驱的后继指向x的后继。如果x没有前驱，说明删除的是头节点，则修改头节点指向x的后继。</li><li>让x的后继的前驱指向x的前驱。如果x没有后继，说明删除的是尾节点，则修改尾节点指向x的前驱。  </li></ol></blockquote><p>其它常用方法还有按索引值访问元素get（int i）与按内容查找元素indexOf（Object o）。其中get方法主要调用node方法返回第i个节点，节点的item变量就是其元素值。 indexOf方法直接从first开始查找，若要查找的内容不是null，则使用equal方法进行比较。   </p><h3 id="特点分析"><a href="#特点分析" class="headerlink" title="特点分析"></a>特点分析</h3><p>LinkedList内部是用双向链表实现的，维护了长度、头节点和尾节点，这决定了它有如下特点：</p><ol><li>按需分配空间，不需要预先分配很多空间。</li><li>不可以随机访问，<strong>按照索引位置访问</strong>效率比较低，必须从头或尾顺着链接找，效率为O(N/2)[如果索引位置在前部分：<strong>index&lt;(size&gt;&gt;1)</strong> ，则从first节点开始，否则从last节点开始]。  </li><li>只要是按照内容查找元素，不管LinkedList的列表是否已排序，效率都比较低，因为必须逐个的进行比较，时间复杂度为O(N)。  </li><li>由于有first与last节点所以在两端添加、删除元素的效率很高，时间复杂度为O(1)。  </li><li>在中间插入、删除元素，要先定位，效率比较低，为O(N)，但修改本身的效率很高，效率为O(1)。   </li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用法上，LinkedList是一个List，但也实现了Deque接口，可以作为队列、栈和双端队列使用。实现原理上，内部是一个双向链表，并维护了长度、头节点和尾节点。<br>根据LinkedList和ArrayList的特点，我们就可以根据实际情况进行选择，如果列表长度未知，添加、删除操作比较多，尤其经常从两端进行操作，而按照索引位置访问相对比较少，则LinkedList是比较理想的选择。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> java源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java源码-剖析ArrayList</title>
      <link href="/2018/11/17/Java%20ArrayList/"/>
      <url>/2018/11/17/Java%20ArrayList/</url>
      
        <content type="html"><![CDATA[<p>容器类(集合)，顾名思义就是用来容纳其它数据的类。在泛型的那篇笔记中，实现了一个简单的动态数组的容器类–DynamicArray,本篇主要阐述Java中真正的动态数组（数组列表）容器类ArrayList（Java 7）的基本用法、迭代操作、实现的一些Interface（Collection、List与RandAccess）、特点与应用场景。  </p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ArrayList是一个泛型类，使用时需要实例化泛型参数，比如  </p><pre class="line-numbers language-java"><code class="language-java">ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> intList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//new ArrayList&lt;Integer>()中尖括号的类型Java7后可以省略  </span>ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span>  strList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ArrayList常用的方法有：  </p><pre class="line-numbers language-Java"><code class="language-Java">public boolean add(E e)  //将新元素添加到末尾public boolean isEmpty() //判断数组列表是否为空public int size()  //获取当前的长度public E get(int index)  // 访问（获取）指定位置元素public int indexOf(Object o)  //查找给定元素，找到返回索引值，否之返回-1public int lastIndexOf(Object o)  //从后往前查找public boolean contain(Object o)  //是否包含指定元素，依据时equals方法的返回值public E remove(int index)  //删除指定位置元素，返回被删的元素  public boolean remove(Object o)  //删除指定元素，只删除一个相同的元素，返回值表示是否删除了元素//如果o为null，则删除值为null的元素public void clean()  //删除所有元素public vod add(int index, E element)  //在指定位置插入元素，index=0表示插在最前面(如果在中间插入，原有的将会整体往后顺移)publi  E set (int index, E element)   //修改指定位置的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>ArrayList原理与我们之前写的DynamicArray类似，其内部有一个数组elementData，整数size记录实际的元素个数。如下所示：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">transient</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>类中各种public方法的内部操作其实都是对这个数组与整型的操作，elementData会根据实际元素的个数的增加而动态的<strong>重新</strong>分配，整数size记录实际的元素个数。<br>以下是add方法实现的主要代码：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>  elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先调用ensureCapacityInternal方法的目的是确保这次添加元素时候，数组的容量是足够的。ensureCapacityInternal的代码如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>    minCapacity <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ensureCapacityInternal方法首先判断数组elementData是否为空，DEFAULT_CAPACITY的值为10，然后调用ensureExplicitCapacity方法，主要代码如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>  modCount<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// overflow-conscious code</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>modCount表示内部的修改次数，如果需要的长度大于当前数组elementData的长度，则调用grow()，主要代码如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// overflow-conscious code</span>  <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>     newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>      newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>  elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>grow（）的作用就是先确定扩容的长度，然后使用copyOf方法。里面需要注意的时移位运算，newCapacity相当于1.5倍的oldCapacity。<br>以下为remove方法的代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>  modCount<span class="token operator">++</span><span class="token punctuation">;</span>  E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//计算要移动的元素个数</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>      System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>  elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work 将size减1，同时释放引用以便原对象被垃圾回收</span>  <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>remove方法里也有一个modCount变量，然后numMoved计算要移动的元素个数，从index往后的元素都往前移动一位，调用了 System.arraycopy 方法来移动元素。 elementData[–size] = null; 这行代码将size减1（索引0开始），同时将最后一个位置设为null，因为设为null之后也就不再继续引用原来的对象，其就可以被垃圾回收。<br>其它的方法大多也比较简单。 　　</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>迭代是ArrayList常见的操作，以下是一个迭代操作的例子，循环打印ArrayList的每个元素（ArrayList因为底层操作是数组所以支持foreach语法,增强for循环适用与各种容器，相比普通for循环，更为通用）：</p><pre class="line-numbers language-java"><code class="language-java">ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> intList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>intList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>intList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>intList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>Integer a<span class="token operator">:</span>intList<span class="token punctuation">)</span><span class="token punctuation">{</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的foreach语法背后是怎么实现的呢？其实编译器会将它转换为类似下面的代码：</p><pre class="line-numbers language-java"><code class="language-java">Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> it <span class="token operator">=</span> intList<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="迭代器接口"><a href="#迭代器接口" class="headerlink" title="迭代器接口"></a>迭代器接口</h4><p>ArrayList实现了Iterable接口，在Java7中，Iterable如下定义：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterable</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>  Iterator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，iterator返回一个实现了Iterator接口的对象，在Java7中，Iterator接口的定义如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">boolean</span> <span class="token function">hashNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  E next<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，hasNext（）判断是否还有元素未访问，next（）返回下一个元素，remove（）删除最后返回的元素，只读访问的基本模式类似于：  </p><pre class="line-numbers language-java"><code class="language-java">Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> it <span class="token operator">=</span> intList<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong> foreach也就是增强for循环可以与任何实现了接口Iterable（只包含抽象方法itrrator（） ）的对象一起工作。<br><strong>接口Iterable的注意：</strong>   </p><ul><li>Iterable表示对象可以被迭代，并返回Iterator对象。ArrayList中，因为接口Collection继承了接口Iterable，在ArrayList中实现了接口Collection。所以ArrayList可以使用迭代器的方法进行遍历。同时标准类库中的任何容器类也因此都可以使用foreach。  </li><li>对象如果要使用增强for循环，就必须要实现接口Iterable。</li></ul><blockquote><p>ArrayList通过内部类实现接口Iterator。  </p></blockquote><h4 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h4><p>接口ListIterator扩展了接口Iterator，使其增加了向前遍历，添加、修改元素，返回索引元素等方法。  </p><h4 id="迭代器使用的常见错误"><a href="#迭代器使用的常见错误" class="headerlink" title="迭代器使用的常见错误"></a>迭代器使用的常见错误</h4><p>在使用迭代器时候，有一种常见的错误，就是在迭代的中间调用容器（集合）的删除方法。比如要删除整型ArrayList中所有的负数，直觉上可以这样写：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>Integer a <span class="token operator">:</span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是运行时会抛出如下异常：</p><blockquote><p>java.util.ConcurrentModificationException    </p></blockquote><p>为何会发生并发修改异常呢？</p><blockquote><p>因为迭代器内部会维护一些与索引位置相关的数据，要求在迭代过程中，容器（集合）不能发生结构性改变，否则这些索引位置就失效了。结构性变化就是指： 插入、删除元素，而只修改元素的内容不算结构性变化。    </p></blockquote><p><strong> 如何避免并发修改异常？ </strong> 可以使用迭代器的remove方法，具体如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>ArrayList<span class="token operator">&lt;</span>Ingeter<span class="token operator">></span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>  Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> it <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span>next <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="迭代器实现原理"><a href="#迭代器实现原理" class="headerlink" title="迭代器实现原理"></a>迭代器实现原理</h4><p>迭代器是如何知道发生了结构性改变，然后抛出了异常呢？为何自己的remove方法又能使用呢？<br>以下为ArrayList中Iterator方法的实现：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Itr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong> Itr  </strong>  是一个成员内部类，实现了接口Iterator，声明如下：  </p><blockquote><p>private class Itr <strong>implements</strong> Iterator   </p></blockquote><p>它有三个实例成员变量：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> cursor<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//下一个要返回的元素位置</span><span class="token keyword">int</span> lastTRet <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 最后一个返回的索引位置，如果没有为 -1</span><span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>expectedModCount*</strong> 变量表示期望的修改次数，初始化为外部类当前的修改次数 <strong>modCount</strong> （成员内部类可以直接访问外部类的实例成员变量）。每次发生<strong>结构性变化</strong>的时候modCount都会增加，而每次迭代器操作的时候都会检查expectedModCount是否与modCount，这样就能检测出是否发生了结构性变化。  </p><p>以下将会阐述内部类 <strong>Itr</strong> 如何实现接口Iterator接口中的每个方法的。hasNext()方法的代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> cursor <span class="token operator">!=</span> size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//cursor与size比较，很简单</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>next()方法代码如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> cursor<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> size<span class="token punctuation">)</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData <span class="token operator">=</span> ArrayList<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>elementData<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  cursor <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> elementData<span class="token punctuation">[</span>lastRet <span class="token operator">=</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先调用了checkForComodification，它的代码为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>     <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所以，next()前面部分主要目的就是在检查是否发生了结构性变化，如果没有变化，就更新cursor和lastRet的值，以保持其语义，然后返回对应的元素。<br>remove（）方法的代码如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>lastRet <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>     <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        ArrayList<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>lastRet<span class="token punctuation">)</span><span class="token punctuation">;</span>        cursor <span class="token operator">=</span> lastRet<span class="token punctuation">;</span>        lastRet <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IndexOutOfBoundsException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它调用了ArrayList的remove方法，但同时更新了cursor, lastRet和expectedModCount的值，所以它可以正确删除。不过，需要注意的是，调用remove方法前必须先调用next，比如，通过迭代器删除所有元素，直觉上，可以这么写：  </p><pre class="line-numbers language-Java"><code class="language-Java">public static void removeAll(ArrayList<Integer> list){  Iterator<Integer> it = list.iterator();  while(it.hasNext()){        it.remove();      }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际运行，会抛出异常：</p><blockquote><p>java.lang.IllegalStateException</p></blockquote><p>正确写法是：  </p><pre class="line-numbers language-Java"><code class="language-Java">public static void removeAll(ArrayList<Integer> list){  Iterator<Integer> it = list.iterator();  while(it.hasNext()){        it.next();        it.remove();  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，如果只是要删除所有元素，ArrayList有现成的方法clear()。<br>listIterator()的实现使用了另一个内部类ListItr，它继承自Itr，基本思路类似。  </p><h4 id="迭代器的优点"><a href="#迭代器的优点" class="headerlink" title="迭代器的优点"></a>迭代器的优点</h4><p>使用普通的for（int i = 0；i &lt; arrs.size()； i++）再加上ArrayList的get（）方法虽然在一些场景中与使用迭代器（增强for循环）效果并没有什么区别，但是使用迭代器（增强for）可以增强可读性，更重要的是更为通用，可以适用于所有的容器（集合）类。<br>此外，迭代器表示了一种关注点相分离的思想，将数据的实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。需要访问容器元素的代码只需要一个Iterator接口，不需要关注数据的实际组织方式，可以使用一致与统一的方式进行访问。<br>而提供的Iterator接口的代码了解数据的组织方式，可以提供更高效的实现。在ArrayList中，size/get(index)语法与迭代器的性能是差不多的，但是在其他的容器类中则不一定，比如LinkedList，迭代器的性能则高许多。  </p><blockquote><p>从封装的思路来讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单和一致的接口。  </p></blockquote><h3 id="ArrayList实现的接口"><a href="#ArrayList实现的接口" class="headerlink" title="ArrayList实现的接口"></a>ArrayList实现的接口</h3><p>ArrayList实现了三个主要的接口： Collection、List、RandomAccess。<br>接口Collection继承了接口Iterable，表示一个数据集合，数据没有位置或者顺序的概念。<br>接口List表示有顺序或者位置的数据集合，它扩展了Collection。<br>接口RandomAccess没有定义任何的代码。这种没有代码的接口在Java中被称为<strong>标记接口</strong> ，用于声明类的一种属性。</p><h3 id="ArrayList的特点"><a href="#ArrayList的特点" class="headerlink" title="ArrayList的特点"></a>ArrayList的特点</h3><ol><li>可以随机访问（数组是一块连续的内存空间，可以根据索引随机访问），使用索引进行随机访问效率很高，时间复杂度为O(1)。  </li><li>普通未排序的ArrayList按内容查找的效率很低，时间复杂度为O(n)。  </li><li>末尾 <strong>添加</strong> 元素的效率还可以，重新分配与复制数组的开销可以被平摊了。 <strong>插入</strong> 与 <strong>删除</strong> 元素效率很低，因为还要移动元素，时间复杂度为O（n）。    </li><li>ArrayList <strong>不是线程安全</strong> 的，实现线程安全的一种方式是使用接口Collection提供的方法装饰ArrayList类。此外，还有一个类 <strong>Vector</strong> ，它是Java早期实现的容器（集合）类之一。也实现了接口List，但基本原理与ArrayList类似，内部使用了 <strong>synchronized</strong> 实现了线程安全。在不需要线程安全的情况下，可优先考虑使用ArrayList。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> java源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多态（向上转型、动态绑定、instanceof、抽象）</title>
      <link href="/2018/11/14/Java%20Polymorphic/"/>
      <url>/2018/11/14/Java%20Polymorphic/</url>
      
        <content type="html"><![CDATA[<h3 id="多态（向上转型）"><a href="#多态（向上转型）" class="headerlink" title="多态（向上转型）"></a>多态（向上转型）</h3><p>多态：意味着允许不同类的对象对同一消息做出不同的响应。<br>在Java中，按照广泛的范围来说，多态  可以分为 <strong>编译时多态</strong>（也叫设计时多态，<br>一般通过方法的重载来实现） 与 <strong>运行时多态</strong>（直到ｊａｖａ程序运行时候，系统才能根据调用方法的实例的类型来去决定去具体调用哪个方法）。<br>我们在Java中所说的多态就是<strong>运行时多态</strong>，在程序运行时动态决定调用哪个方法。<br>两个必要条件：  </p><ul><li>满足继承关系  </li><li>父类引用指向子类对象  </li></ul><p>定义父类Animal：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> month<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>  <span class="token keyword">public</span>  <span class="token function">Animal</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span><span class="token keyword">int</span> month<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>month <span class="token operator">=</span> month<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//name与month相对应的get、set方法</span>  <span class="token comment" spellcheck="true">//......</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"动物吃东西"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义子类Cat：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">double</span> weight；  <span class="token keyword">public</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token function">Cat</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span><span class="token keyword">int</span> month<span class="token punctuation">,</span><span class="token keyword">double</span> weight<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span>month<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//this.setMonth(month);</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//weight的get与set方法</span>  <span class="token comment" spellcheck="true">//......</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小猫在跑"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小猫吃鱼"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义子类Dog：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>  <span class="token keyword">private</span> String sex<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token function">Dog</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span><span class="token keyword">int</span> month<span class="token punctuation">,</span><span class="token keyword">double</span> sex<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setMonth</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//sex的get与set方法</span>  <span class="token comment" spellcheck="true">//......</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小狗睡觉"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小狗吃骨头"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写测试类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span> <span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    Animal one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Animal two <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//向上转型、隐式转型、自动转型》》父类引用指向子类实例，小类型转向大类型。</span>    Animal three <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    one<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    two<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    three<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><blockquote><p>动物吃东西<br>小猫吃鱼<br>小狗吃骨头  </p></blockquote><pre class="line-numbers language-java"><code class="language-java">Animal two <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此处为向上转型、隐式转型、自动转型 ———&gt;&gt; 父类引用指向子类实例，小类型转向大类型。可以调用子类重写父类的方法以及父类派生的方法。但是子类特有的方法无法使用。</p><p><strong>向上转型总结:</strong>  </p><blockquote><p>  向上转型是安全的,因为任何子类都继承并接受了父类的方法。从例子中也可以理解,所有的狗狗都属于狗的父类一动物 ,这是可行的,但是向下转型则不行,若说所有的动物都是狗狗就不成立了。(所以向下转型要通过强制类型转换)</p></blockquote><p><strong>向上转型应用：</strong>  </p><ol><li>当一个子类对象向上转型父类类型以后,就被当成了父类的对象,所能调用的方法会减少,只能调用子类重写了父类的方法以及父类派生的方法(如set、get方法),而不能调用子类独有的方法。</li><li>父类中的静态方法不允许被子类重写。<br>如父类Pen中含有静态方法draw()</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"笔可以画画"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当子类Pencil中也定义同名方法时，此时draw()算做Pencile类自己特有的方法：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"铅笔可以素描"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>测试类：</p><pre class="line-numbers language-java"><code class="language-java">Pen pc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pencil</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//向上转型</span>pc<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果如下，也就是实际上调用的是父类的静态方法deaw()</p><blockquote><p>笔可以画画  </p></blockquote><p>下面更改动物例子中测试类Test的编写：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span> <span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    Animal one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Animal two <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Animal three <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Cat temp <span class="token operator">=</span> <span class="token punctuation">(</span>Cat<span class="token punctuation">)</span>two<span class="token punctuation">;</span>    temp<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">Cat temp <span class="token operator">=</span> <span class="token punctuation">(</span>Cat<span class="token punctuation">)</span>two<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此处为向下转型、强制类型转换 ———&gt;&gt;子类引用指向父类对象，此处必须进行强转，可以调用子类特有的方法。<br>不能Dog temp = (Dog)two；  </p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>two在引用的时候，指向的是Dog的实例空间，所以Cat temp = (Cat)two;  相当于还原为原来的类型。为了避免编写程序时出现上面Dog temp = (Dog)two；这种情况，可以用<strong>instanceof</strong> 运算符。<br>instanceof：<strong>判断e对象是否是E类的实例</strong>。如果是返回true。使用如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>two <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  Cat temp <span class="token operator">=</span> <span class="token punctuation">(</span>Cat<span class="token punctuation">)</span>two<span class="token punctuation">;</span>  temp<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  temp<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  temp<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>多态的实现可以通过向上转型和动态绑定机制来完成，问上转型实现了将子类对象向上转型为父类类型,而动态绑定机制能识别出对象转型前的类型,从而自动调用该类的方法，两者相辅相成。<br><strong>动态绑定:</strong><br>绑定就是将一个方法调用同一个方法所在的类连接到一起就是绑定。绑定分为静态绑定和动态绑定两种。<br>静态绑定:在程序运行之前进行绑定(由编译器和链接程序完成的),也叫做前期绑定。<br>动态绑定:在程序运行期间由JVM根据对象的类型自动的判断应该调用哪个方法,也叫做后期绑定。<br><strong>静态绑定的例子:</strong> 如有一类Human,它派生出来三个子类Chinese类、American 类和British类,三个子类中都重写了父类中的方法speak( ),在测试类中用静态绑定的方式调用方法speak( )。  </p><pre class="line-numbers language-java"><code class="language-java">Chinese ch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Chinese</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ch<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>American am <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">American</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>am<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>British br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">British</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>br<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的调用方式是在代码里指定的，在编译时编译器就知道ch.speak()调用的是Chinese的speak（）。</p><p><strong>动态绑定的例子</strong>:对测试类进行修改如下。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//生成父类对象数组,数组长度为5  </span>Human<span class="token punctuation">[</span><span class="token punctuation">]</span> human<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Human</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>human<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  n<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//随机产生 从0到2中一个数</span>  <span class="token keyword">switch</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>human<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Chinese</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>human<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">American</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>human<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">British</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//循环输出，循环体中每个对象分别调用speak()方法</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span> human <span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  human<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时, Human类中随机生成Chinese类、American 类和British类的对象,编译器不能根据代码直接确定调用哪个类中的speak()方法,直到运行时才能根据产生的随机数n的值来确定humani到底代表哪一个子类的对象,这样才能最终确定调用的是哪个类中的speak()方法。  </p><h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p>最开始写的Animal类中的eat()方法真的有用吗，Animal类实例化有用吗？虽然语法本身没有问题，但是实例化的对象并没有意义， 程序逻辑存在一些问题。<br><strong>abstract</strong> 解决了上面的问题，使程序员编写符合实际意义的有效代码。(abstract 关键字位置可以与public位置交换）<br><strong>基本概念</strong><br>  在面向对象的概念中，所有的对象都是通过类来描述的，但不是所有的类都是用来描述对象的，当一个类中没有包含足够的信息以描述一个具体的对象时，这样的类就是抽象类。  </p><p><strong>特点</strong>    </p><ul><li>类设置为抽象类时，就不能再被实例化，只能作为其它类的父类，<strong>但可以改过向上转型，使其指向子类的实例</strong>。    </li><li>抽象方法只能有声明，不能有实现，即仅有方法头，而没有方法体与操作实现。（如：abstract double area(); ）   </li></ul><p><strong>定义抽象类的意义</strong></p><ul><li>为其子类提供一个公共的类型（父类引用指向子类对象，向上转型）</li><li>封装子类中的重复内容（成员变量与方法）  </li><li>将父类设置为抽象类后，既可以借由父子继承关系限制子类的设计随意性，在一定程度避免了无意义父类的实例化。  </li></ul><p><strong>注意</strong></p><ul><li>含有抽象方法的类，必须被定义为抽象类。  </li><li>抽象类不一定包含抽象方法。（抽象方法在子类中必须被实现）  </li><li>抽象类中的成员方法可以包含一般方法与抽象方法。  </li><li>即使抽象类中不包含抽象方法，抽象类也不能被实例化，抽象类的构造方法主要是用于被其子类调用。</li><li>一个类继承抽象类后，必须实现其所有抽象方法，否则要被定义为抽象类，不同子类对父类的抽象方法可以根据实际有不同的实现。  </li><li>即使父类是具体的， 但其子类也可以是抽象的。例如Object是具体的，但可以创建抽象子类。  </li><li>abstract方法不能用static、private修饰；对于abstract类，不能使用final修饰，因为final关键字使类不可继承，而abstract修饰的类如果不能被继承则没有意义。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java的非静态方法调用过程</title>
      <link href="/2018/11/13/Java%20CallFunction/"/>
      <url>/2018/11/13/Java%20CallFunction/</url>
      
        <content type="html"><![CDATA[<p>Java中非静态方法的调用过程，即通过对象来调用方法的过程主要有以下几个步骤。<br>假设要调用x.f(args), <strong>隐式参数</strong> x 声明为类C的一个对象。具体调用流程如下：</p><h3 id="1-编译器得到所有可能被调用的候选方法。"><a href="#1-编译器得到所有可能被调用的候选方法。" class="headerlink" title="1. 编译器得到所有可能被调用的候选方法。"></a>1. 编译器得到所有可能被调用的候选方法。</h3><p>编译器查看对象的声明类型与方法名。假设调用x.f(param)，且隐式参数x声明为C类的对象。需要注意的是方法的<strong>重载</strong>（Overload）即：有可能存在多个名字为f，但是<strong>参数类型不一样</strong>的方法。例如，可能存在f(int)和f(String)。编译器将会一一列举所有类C和其超类中访问属性为public且名为f的方法（超类的私有方法不可访问）。</p><h3 id="2-重载解析（编译器得到需要调用的具体的一个方法）"><a href="#2-重载解析（编译器得到需要调用的具体的一个方法）" class="headerlink" title="2. 重载解析（编译器得到需要调用的具体的一个方法）"></a>2. 重载解析（编译器得到需要调用的具体的一个方法）</h3><p>接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程称为重载解析。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。<br>需要注意的是int可以转换为double，子类可以转换为父类，</p><h3 id="3-静态绑定与动态绑定"><a href="#3-静态绑定与动态绑定" class="headerlink" title="3. 静态绑定与动态绑定"></a>3. 静态绑定与动态绑定</h3><p>如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为静态绑定。与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。</p><h3 id="4-使用动态绑定调用方法"><a href="#4-使用动态绑定调用方法" class="headerlink" title="4. 使用动态绑定调用方法"></a>4. 使用动态绑定调用方法</h3><p>当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实例类型最合适的那个类的方法。假设 x 的实际类型是D（子类），它是C类的子类，我们要调用f(String)。如果D类定义了方法f(String)，就直接调用它；否则将在D类的超类中寻找f(String)，以此类推。<br>每次调用方法都要进行方法搜索，时间开销相当大。因此，虚拟机预先为每个类创建一个方法表，其中列举了所有方法的签名和实际调用的方法。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。  </p><blockquote><p>动态绑定有一个很重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展。假设新增一个类E，并且变量e可能引用这个类的对象，我们不需要对包含调用e.f()方法进行重新编译。如果e引用了一个E类的对象，就会自动地调用E.f()方法。  </p></blockquote><blockquote><p>需要注意的是：在 <strong>覆盖</strong>（Override）一个方法的时候，子类方法的可见性不能低于超类方法的可见性。<strong>特别</strong>是如果超类的方法时public，那么子类方法一定要声明为public，否则编译器解释为默认的就会出错。  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java修饰符的限制范围</title>
      <link href="/2018/11/09/Java%20Modifier/"/>
      <url>/2018/11/09/Java%20Modifier/</url>
      
        <content type="html"><![CDATA[<p>以下为Java控制可见性的四个修饰符的总结  </p><ol><li>仅对本类可见 – private  </li><li>对本包可见 – 默认（无修饰符）</li><li>对本包及所有子类可见 – protected</li><li>对所有类可见 – public</li></ol><table><thead><tr><th>访问修饰符</th><th>本类</th><th>同包</th><th>子类</th><th>其它</th></tr></thead><tbody><tr><td>private</td><td>Y</td><td></td><td></td><td></td></tr><tr><td>默认</td><td>Y</td><td>Y</td><td></td><td></td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td></td></tr><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java为何没有引用传递？</title>
      <link href="/2018/11/07/Java%20CallByValueReference/"/>
      <url>/2018/11/07/Java%20CallByValueReference/</url>
      
        <content type="html"><![CDATA[<blockquote><p>值传递（值调用）（call by value）是指在调用函数式将实际参数<strong>复制</strong>一份传递到函数中,这样在函数中如果对参数进行修改，将不会影响到实际参数。<br>  引用传递（引用调用）（pass by reference）是指在调用函数时将实际参数的地址<strong>直接传递</strong>到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p></blockquote><h2 id="误解"><a href="#误解" class="headerlink" title="误解"></a>误解</h2><ul><li>错解一：Java有引用传递。</li><li>错解二：区分值传递和引用传递的依据是方法参数的内容，如果方法参数是值，就是值传递。如果方法参数引用，就是引用传递。</li><li>错解三：方法参数如果是普通数据类型，那就是值传递。如果是对象，那就是引用传递。</li></ul><h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p>  方法参数是基本类型时，方法接收的是调用者提供的值。方法不会修改传递给它的参数的参数变量的内容。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token function">doubleValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//该方法调用后，value值仍然为5.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面是一段最简单的代码，可以看出：一个方法不可能修改一个基于基本数据类型的参数。<br>下面的代码是修改员工工资，中将雇员的薪金提高一倍：  </p><pre class="line-numbers language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doubleSalary</span><span class="token punctuation">(</span>Employ x<span class="token punctuation">)</span><span class="token punctuation">{</span>  x<span class="token punctuation">.</span><span class="token function">raiseSalary</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//将工资提高二倍</span>  <span class="token punctuation">}</span>  xiaomi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span>······<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">doubleValue</span><span class="token punctuation">(</span>migaoyang<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>具体执行过程为：</p><ol><li>x被初始化为xiaomi值的<strong>拷贝</strong>，这里是一个对象的引用。  </li><li>raiseSalary方法将用于这个对象的引用。x与xiaomi同时引用的那个Employee对象的薪水提高一倍。  </li><li>方法结束后，参数变量x不再使用。对象变量xiaomi继续引用那个薪水提高一倍的雇员对象。  </li></ol></blockquote><p>结果确实是修改了被传入的对象，因此许多程序员认为Java对对象采用的是引用调用，实际上这种理解是不对的，下面是一个反例：<br>首先编写一个交换两个雇员对象的方法：  </p><pre class="line-numbers language-Java"><code class="language-Java">public static void swap(Employee x,Employee y){  employee temp = x;  x = y;  y = temp;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果Java对象采用的是按引用调用，那么上面的代码就能实现交换对象的效果。</p><pre class="line-numbers language-java"><code class="language-java">Employee a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"Alice"</span>······<span class="token punctuation">)</span><span class="token punctuation">;</span>Emplouee b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Emplouee</span><span class="token punctuation">(</span><span class="token string">"bob"</span>······<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但是，swap方法并没有改变a与b中的对象引用。swap方法的参数x与y被初始化为两个队下对象引用的拷贝，swap方法交换的是这两个拷贝。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//x reference to Alice,y to bob</span>Employee temp <span class="token operator">=</span> x<span class="token punctuation">;</span>x <span class="token operator">=</span> y<span class="token punctuation">;</span>y <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//now x reference to bob,y to Alice</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，在方法结束运行时参数变量x与y就被丢弃了，而被丢弃的这俩x与y是a与b引用地址的拷贝，通过x与y确实能找到被引用的对象，进而可以修改所指向对象的属性。但是swap方法结束后x与y就会被丢弃，之前变量a与b仍然引用swap方法调用之前所引用的对象。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>比较上面的三个例子，最重要的是后两个例子，为什么都是对象，一个被传进去的对象被改变了而另一并不改变呢？我想许多人对Java是否有引用传递的疑惑就在在这里。再根据值传递与引用传递的定义来看，区分这两者的根本就是被传进去的参数是否是被<strong>复制</strong>的，我们再传一个对象给方法时候，实际是将这个对象引用的值复制了一份，然后再传进方法，方法里是通过这个被复制的引用的值去找对象的（此时也就是有两个对象的引用共同指向一个对象），所以从值传递与引用传递的定义来看，传递对象也是值引用。  </p><p>再看开始的三个疑惑，其实区分值传递与引用传递的根本在于传递的参数是否有备份，Java里仅有值传递，方法参数是对象是也是值传递。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/11/06/hello-world/"/>
      <url>/2018/11/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>new article</title>
      <link href="/2018/10/10/mdyufa/"/>
      <url>/2018/10/10/mdyufa/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span>  os  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="命令面板"><a href="#命令面板" class="headerlink" title="命令面板"></a>命令面板</h5><blockquote><p>cmd-shift-P</p></blockquote><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><blockquote><p>在行末加两个空格 再回车</p></blockquote><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>两种语法形式 类Setext与类atx<br>类 Setext形式以底线形式,利用 = (最高阶标题) 和 - (第二阶标题)</p><h6 id="Setext-例"><a href="#Setext-例" class="headerlink" title="Setext 例:"></a>Setext 例:</h6><blockquote><h1 id="This-is-an-H1"><a href="#This-is-an-H1" class="headerlink" title="This is an H1"></a>This is an H1</h1></blockquote><h2 id="This-is-an-H2"><a href="#This-is-an-H2" class="headerlink" title="This is an H2"></a>This is an H2</h2><h6 id="atx-例-1-6级"><a href="#atx-例-1-6级" class="headerlink" title="atx 例: (1-6级)"></a>atx 例: (1-6级)</h6><blockquote><h1 id="atx"><a href="#atx" class="headerlink" title="atx"></a>atx</h1><h2 id="atx-1"><a href="#atx-1" class="headerlink" title="atx"></a>atx</h2><h3 id="atx-2"><a href="#atx-2" class="headerlink" title="atx"></a>atx</h3><h4 id="atx-3"><a href="#atx-3" class="headerlink" title="atx"></a>atx</h4><h5 id="atx-4"><a href="#atx-4" class="headerlink" title="atx"></a>atx</h5><h6 id="atx-5"><a href="#atx-5" class="headerlink" title="atx"></a>atx</h6></blockquote><h4 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h4><p>在每行前加 &gt; 区块引用  支持多重嵌套,只用多加&lt;即可</p><blockquote><p>区块引用</p><blockquote><p>123</p></blockquote></blockquote><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>+与-  无序<br>数字接一个英文句点  有序</p><ul><li>Red</li><li>Green</li></ul><ol><li>Red</li><li>Green</li></ol><h4 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h4><p>缩进4个字符即可<br>一个代码区块会一直持续到没有缩进的那一行</p><pre><p>private V getForNullKey() {<br>    if (size == 0) {<br>        return null;<br>    }<br>    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {<br>        if (e.key == null)<br>            return e.value;<br>    }<br>    return null;<br>}</p></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
