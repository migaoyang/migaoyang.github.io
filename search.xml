<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL锁--全局锁、表锁与行锁</title>
      <link href="/2020/08/26/MySQLLock/"/>
      <url>/2020/08/26/MySQLLock/</url>
      
        <content type="html"><![CDATA[<p>MySQL提供了不同等级的锁，按限制能力的划分，分为全局锁、表锁、行锁。本文会描述不同锁的应用场景与实现原理。  </p><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>全局锁就是对整个MySQL数据库加锁，MySQL中的命令是 Flush tables with read lock (FTWRL)。在执行这个命令之后，MySQL进入全局锁的状态，整个数据库会拒绝掉增删改这些请求。    </p><h3 id="为什么需要全局锁"><a href="#为什么需要全局锁" class="headerlink" title="为什么需要全局锁"></a>为什么需要全局锁</h3><p>全局锁的目标是为我们维护一个<strong>数据库的逻辑一致性</strong>。如下场景中：在进行逻辑备份（即备份的数据是SQL语句）的时候，没有开启全局锁，那么很可能会导致出现数据库的逻辑一致性错误，例如两个表，一个余额表、一个订单表，在购物时（减余额、生成订单）如果逻辑备份在这两个操作之间，也就是说减完余额之后，逻辑备份，拒绝生成订单，那么这个时候，我们进行的逻辑备份就是一个错误的逻辑一致性状态。以后使用这个逻辑备份进行数据恢复的时候，就会出现用户余额已经减少，但并没有订单这种问题。    </p><h3 id="全局锁的缺点"><a href="#全局锁的缺点" class="headerlink" title="全局锁的缺点"></a>全局锁的缺点</h3><ul><li>对主库使用全局锁进行逻辑备份时，会造成业务的停摆</li><li>对从库使用全局锁进行逻辑备份时，会造成主从延迟的问题  </li></ul><h3 id="FTWRL的替代方式"><a href="#FTWRL的替代方式" class="headerlink" title="FTWRL的替代方式"></a>FTWRL的替代方式</h3><p>全局锁解决的就是上面的问题，我们可以结合数据库中事务的隔离级别，使用可重复读（各个事务之间没有相互影响，基于mvcc）的隔离级别，获取数据库的逻辑一致性视图。MySQL官方自带的逻辑备份工具mysqldump，在备份数据之前，会启动一个事务，以此来获得一个逻辑一致性视图。   </p><p>但需要注意的是，虽然事务的可重复能解决FTWRL影响性能的问题，但事务并不是万能的，因为并不是所有的引擎都支持这个隔离级别，MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的逻辑一致性。    </p><h3 id="为什么不设置为全库只读？"><a href="#为什么不设置为全库只读？" class="headerlink" title="为什么不设置为全库只读？"></a>为什么不设置为全库只读？</h3><p>我们的目的是实现数据库的逻辑一致性，那么为什么不建议直接把数据库设置成只读状态呢？ <code>(set global readonly=true)</code><br>主要有一下原因：   </p><ol><li>FTWRL与readonly的异常机制不太一样。客户端（相对于MySQL）发生异常，FTWRL命令下会自动释放MySQL的全局锁。而readonly会一直停留在readonly状态，数据库长期处于不可写状态。  </li><li>readonly会被一些逻辑判断使用，例如使用readonly判断是主库或者备库。  </li></ol><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁也分为两类： <strong>表锁</strong> 、 <strong>元数据锁（meta data lock，MDL）</strong>。<br>业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。  </p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>在还没有更细粒度的行锁的时候，表锁是最长用的处理并发的解决方式。但是对于当前支持行锁的引擎例如innodb，都优先使用行锁来控制并发，以此来避免因为锁住整个表的影响。  </p><h5 id="表锁的语法"><a href="#表锁的语法" class="headerlink" title="表锁的语法"></a>表锁的语法</h5><p>加锁 <code>lock tables … read/write</code>、主动释放锁<code>unlock tables</code> 。同时表锁也可以在客户端断开连接的时候自动释放。  </p><h5 id="读锁（共享锁）"><a href="#读锁（共享锁）" class="headerlink" title="读锁（共享锁）"></a>读锁（共享锁）</h5><p>事务A对数据d加上共享锁S，那么事务A只能对d进行都操作，并且后面的事务B、C、D都可以加锁S进行只读操作。在释放完S锁之前不能对数据d进行修改。</p><h5 id="写锁（排它锁）"><a href="#写锁（排它锁）" class="headerlink" title="写锁（排它锁）"></a>写锁（排它锁）</h5><p>事务A对数据d加上排它锁X，那么事务A可以对数据d进行访问、修改，并且拒绝其他事务对数据d的读、写。</p><h5 id="表锁需要注意的地方"><a href="#表锁需要注意的地方" class="headerlink" title="表锁需要注意的地方"></a>表锁需要注意的地方</h5><p><code>lock tables</code>语法不仅会限制别的线程（事务）读写操作，也限定了本线程（事务）的<strong>操作对象</strong>以及<strong>操作方式</strong>。即本线程只能按照加锁语句中规定的方式（读或者写）访问特定的资源（table1、table2）。例如：线程 Thread1 中执行 <code>lock tables table1 write, table2 read</code>;其他线程<strong>读、写 table1</strong>、<strong>写 table2</strong> 的语句都会被 <strong>阻塞</strong>。同时，线程 Thread1 在执行 <code>unlock tables</code> 之前，也只能执行读、写 table1、读 table2 的操作。连写 table2 都不允许，并且也不能访问其他表。    </p><h3 id="元数据锁-metadata-lock-MDL"><a href="#元数据锁-metadata-lock-MDL" class="headerlink" title="元数据锁 metadata lock MDL"></a>元数据锁 metadata lock MDL</h3><p>元数据在这里其实指的就是表结构，MDL锁定的也就是我们表结构。防止出现一个线程A在执行表查询操作时候，线程B删除了一个字段，导致查询的结果与表结构不符合这种情况的出现。<br>所以为了解决上述问题，MDL分为了<code>读锁</code>与<code>写锁</code>。  </p><ul><li>在进行表的<strong>增删改查</strong>时候，会对表<strong>自动</strong>加上读锁，读锁之间不会互斥，所以多个线程可以对同一个表进行增删改查。  </li><li>在进行<strong>表结构更改</strong>时候，会对表<strong>自动</strong>加上写锁，写锁是互斥，多个线程能依次对表结构进行修改，然后再加上读锁进行增删改查。  </li></ul><p>表锁并不是现在优先考虑使用的锁，应该尽量的使用行锁，如果在项目中遇到<code>lock table1</code>这样的SQL语句时，应该思考一下：</p><ul><li>是否使用了过老的引擎，例如MYISAM就不支持行锁，可以考虑升级一下引擎，然后把业务代码中的<code>lock table1</code> <code>unlock table1</code>替换为<code>begin</code> <code>commit</code>就OK啦。  </li></ul><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>行锁顾名思义就是对每一行的数据加锁，这是MySQL数据库中最细粒度的锁，右innodb引擎支持。对于不能支持行锁的引擎，对于并发操作的处理只能使用表锁锁定整个表，这也是MyISAM被innoDB所替代的重要原因之一。  </p><h3 id="行锁的使用过程"><a href="#行锁的使用过程" class="headerlink" title="行锁的使用过程"></a>行锁的使用过程</h3><p>使用行锁过程中，若一个事务A正在<strong>更新</strong>某一行数据d，这时候如果事务B也想对d进行<strong>更新</strong>操作，那么只能等A更新完毕然后再加自己的行锁对d进行<strong>更新</strong>操作。这其中就涉及到一个<strong>两阶段锁</strong>这个概念。</p><h3 id="行锁的两阶段锁协议"><a href="#行锁的两阶段锁协议" class="headerlink" title="行锁的两阶段锁协议"></a>行锁的两阶段锁协议</h3><blockquote><p>两阶段锁协议：在 InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。  </p></blockquote><p>其实就是规定了加锁与解锁的时机，两阶段锁协议不仅局限在行锁中。</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>begin  <br>update t1 set k=k+1 where id=1；<br>update t1 set k=k+1 where id=2；</td><td></td></tr><tr><td></td><td>begin<br>  update t1 set k=k+1 where id=1；</td></tr><tr><td>commit</td></tr></tbody></table><p>上面的两个事务AB执行时候就会使用到两段锁协议：事务A先开始执行，id=1时加锁这一行，id=2时加锁这一行，事务A的两条语句执行完了但是还没有commit，事务B开始执行，但是这个时候事务B的update id=1会被阻塞，因为id=1还被事务A加着行锁，虽然事务A的update执行完了，但是事务A还没有commit，意味着事务A所占据着的行锁都没有释放，只有等A执行commit之后，事务B才能继续获得id=1的行锁进行update。  </p><p>所以我们应该记住两段锁的特点：</p><ol><li>在行锁的引擎中，行锁是执行到具体某一行才加上的。</li><li>行锁在本本事务commit之后才会被释放。  </li></ol><p>所以根据两段锁协议的特点，我们在开发过程中，应该在事务中把并发大的表放到后面执行，让它被行锁锁定的时间最短。  </p><p>例如在减库存，生成订单这样的场景中，我们应该先在事务中生成订单，在减库存。因为库存的update并发量会大于订单insert的并发量，update需要使用行锁，如果先update库存，会使库存中的这一行一直被行锁锁定，在事务提交时候才能被释放，增加了许多无用的库存行锁锁定时间。    </p><h3 id="行锁中的死锁"><a href="#行锁中的死锁" class="headerlink" title="行锁中的死锁"></a>行锁中的死锁</h3><p> 数据库中死锁的概念很清晰，和我们操作系统中的一致：  </p><ol><li>资源必须互斥访问</li><li>请求并保持</li><li>不可抢占资源</li><li>形成一个环  </li></ol><p>如果一个项目要新上线一个新功能，如果新功能刚开始的时候MySQL 就挂了。登上服务器一看，CPU 消耗接近<br>100%，但整个数据库每秒就执行不到 100 个事务。原因很可能就是死锁。</p><h3 id="解决MySQL死锁策略"><a href="#解决MySQL死锁策略" class="headerlink" title="解决MySQL死锁策略"></a>解决MySQL死锁策略</h3><p>出现死锁以后，有两种解决策略：</p><ol><li>设置等待的超时时间。<code>innodb_lock_wait_timeout</code>   </li><li>主动发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。<code>innodb_deadlock_detect = on</code>，表示开启死锁检测。</li></ol><p><code>innodb_lock_wait_timeout</code>在innoDB引擎中的的默认值是<code>50s</code>，意味着如果发生死锁的情况，第一个被锁住的线程等待50s才会超时退出，然后其他线程才<code>有可能</code>继续执行。对于在线服务来说，这个等待时间往往是无法接受的。但是，我们又不可能直接把这个时间设置成一个很小的值，比如1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，通过设置超时时间通常不是一个好办法，这个更依赖经验值，也依赖不同项目的环境（请求并不均匀）。  </p><p>所以通常情况下会采用<strong>主动死锁检测</strong>的策略，<code>innodb_deadlock_detect</code>默认值就是on的状态。主动死锁检测能及时发现并解决死锁，但主动死锁检测会消耗硬件资源。  </p><blockquote><p><strong>主动死锁检测</strong> 流程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被<br>别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。  </p></blockquote><h5 id="主动死锁检测在热点行更新时产生的问题"><a href="#主动死锁检测在热点行更新时产生的问题" class="headerlink" title="主动死锁检测在热点行更新时产生的问题"></a>主动死锁检测在热点行更新时产生的问题</h5><p>上面我们提到更推荐使用主动死锁检测去解决死锁问题，但在这样的场景中：所有的事务都需要更新同一行的数据。使用主动死锁检测肯定能得出未死锁，但是这期间要消耗大量的cpu，导致虽然占用了大量cpu却实际没能执行几个事务。  </p><p>这种由这种热点行更新导致的性能问题的原因在于：主动死锁检测要耗费大量的 CPU 资源。</p><p>热点行更新导致的性能问题的解决思路：</p><ol><li>如果能保证某个业务不会出现死锁，可以临时关闭死锁检测，但本身可能存在风险，如果发生死锁，会发生事务等待超时时间。  </li><li>控制并发度。例如一行数据只能允许20个事务进行同时更新，那么可以极大的减缓死锁检测的压力。如何去控制并发度，大体也有两个思路一是通过业务代码在客户端进行访问MySQL的控制，但是MySQL不一定只有这一个客户端，所以这个思路优缺点；二是考虑使用中间间或者是修改MySQL源码，对于相同行的update，在进入引擎之前排队，里面只允许存在20个事务进行update，这样update时候就不会有太大的死锁检测压力。（死锁检测时间复杂度为O（n平方））。 但是这个需要数据库方面的专家。。。</li><li>可以考虑在业务层面减少对某一行的并发度。例如在收款这个场景中，我们把热点的某一行拆分出来，保证拆分出来的几行最后在收款的总数一致就可以了。如果分为20个，那么死锁的肯能性就变为了原来的20粉之一，与此同时由于不是同一行也减少了主动死锁检测cpu的消耗。这种方式需要在代码里做详细、严谨的逻辑分析。</li></ol><p><strong>综上：减少死锁的主要方向，就是控制访问相同资源的并发事务量。</strong></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型：看Java如何解决可见性和有序性问题</title>
      <link href="/2020/04/01/JMM%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9A%E7%9C%8BJava%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98/"/>
      <url>/2020/04/01/JMM%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9A%E7%9C%8BJava%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="Java内存模型：看Java如何解决可见性和有序性问题"><a href="#Java内存模型：看Java如何解决可见性和有序性问题" class="headerlink" title="Java内存模型：看Java如何解决可见性和有序性问题"></a>Java内存模型：看Java如何解决可见性和有序性问题</h3><p>&emsp; <strong>导致可见性的原因是缓存，导致有序性的原因是编译优化</strong> ，那解决可见性、有序性最直接的<br>办法就是禁用缓存和编译优化，但是这样问题虽然解决了，我们程序的性能可就堪忧了。<br>合理的方案应该是按需禁用缓存以及编译优化。那么，如何做到“按需禁用”呢？对于并发程序，<br>何时禁用缓存以及编译优化只有程序员知道，那所谓“按需禁用”其实就是指按照程序员的要求来禁用。<br>所以，为了解决可见性和有序性问题，只需要提供给程序员按需禁用缓存和编译优化的方法即可。<br>Java 内存模型是个很复杂的规范，可以从不同的视角来解读，站在我们这些程序员的视角，<br>本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。<br>具体来说，这些方法包括 volatile、synchronized 和 final 三个关键字，以及六项<br> Happens-Before 规则，这也正是本篇的重点内容。</p><p> &emsp;&emsp;多线程环境中存在因<strong>数据竞争</strong>而产生的同步问题，为了避免因数据竞争而产生同步问题，Java虚拟机规范（Java5）引入了<strong>happens-before</strong>这一概念来定义Java内存模型。<br> &emsp;&emsp;<strong>happens-before</strong> 描述了两个操作内存的可见性。例如<strong>X happens-before Y</strong>，那么 X 的结果对于 Y 可见。<br> &emsp;&emsp;<strong>happens-before</strong> 定义的可见性按照线程的划分可以分为单个线程内与多个线程间的操作可见性。单个线程内的happens-before规则叫做<strong>程序次序规则</strong>，这个规则其实指的就是解决指令重排序引起的数据竞争问题，当然程序次序规则并并没有明确禁止指令重排序，而是要求重排序后和我们的代码顺序一致。多个程序间的happens-before规则还有以下几种：  </p><ol><li>管理锁定规则： 【解锁操作】 happens-before 【之后（这里指时钟顺序先后）对同一把锁的加锁操作】。例如 thread1解锁了monitor a，接着thread2锁定了thread1已经解锁了的monitor a，那么，thread1解锁monitor a之前的写操作都对thread2可见（线程1和线程2可以是同一个线程）。</li><li>volatile变量规则：【volatile 字段的写操作】happens-before 【之后（这里指时钟顺序先后）对同一字段的读操作】。例如线程1对volatile变量a进行写操作之后，线程2一定能看到线程1对于a的操作，也就是线程2一定能读到更新后a的值。</li><li>线程启动规则：【Thread.start()方法】happen—before【调用start的线程前的每一个操作】。例如在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</li><li>线程终止规则：【线程的最后一个操作】 happens-before 【它的终止事件（即其他线程通过 Thread.isAlive() 或 Thread.join() 判断该线程是否中止）】。也就是在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。</li><li>线程中断规则：【线程对其他线程的中断操作】 happens-before 【被中断线程所收到的中断事件（即被中断线程的 InterruptedException 异常，或者第三个线程针对被中断线程的 Thread.interrupted 或者 Thread.isInterrupted 调用）】。也就是【对线程interrupt()的调用】 happen—before【 发生于被中断线程的代码检测到中断时事件的发生】；  </li><li>对象终结规则：【构造器中的最后一个操作】 happens-before 【析构器的第一个操作】；</li><li><p>传递规则： 如果操作 X happens-before 操作 Y，而操作 Y happens-before 操作 Z，那么操作 X happens-before 操作 Z。    </p><h4 id="Java-内存模型的底层实现"><a href="#Java-内存模型的底层实现" class="headerlink" title="Java 内存模型的底层实现"></a>Java 内存模型的底层实现</h4><p>该部分是学习郑雨迪老师在极客时间专栏《深入理解Java虚拟机》第13小节的理解。并且以下提到的缓存均指计算机组成原理中的CPU cache。<br>&emsp;&emsp;Java 内存模型是通过内存屏障（memory barrier）来禁止重排序的。<br>对于即时编译器来说，它会针对前面提到的每一个 happens-before 规则，向正在编译的目标方法中插入相应的读读、读写、写读以及写写内存屏障。<br>&emsp;&emsp;这些内存屏障会限制即时编译器的重排序操作。<strong>以 volatile 字段访问为例，所插入的内存屏障将不允许 volatile 字段写操作之前的内存访问被重排序至其之后；也将不允许 volatile 字段读操作之后的内存访问被重排序至其之前。</strong><br>&emsp;&emsp;然后，即时编译器将根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。以我们日常接触的 X86_64 架构来说，读读、读写以及写写内存屏障是空操作（no-op），只有写读内存屏障会被替换成具体指令。该具体指令的效果，可以简单理解为强制刷新处理器的写缓存。<br>&emsp;&emsp;写缓存是处理器用来加速内存存储效率的一项技术。在使用cpu缓存cache时，碰到内存写操作时，处理器并不会等待该指令结束，而是直接开始下一指令，并且依赖于写缓存将更改的数据同步至主内存（main memory）之中。<br>&emsp;&emsp;而强制刷新写缓存，将使得当前线程写入 volatile 字段的值（以及写缓存中已有的其他内存修改），同步至主内存之中。由于内存写操作同时会无效化其他处理器所持有的、指向同一内存地址的缓存行，因此可以认为其他处理器能够立即见到该 volatile 字段的最新值。  </p><h4 id="锁，volatile-字段，final-字段与安全发布"><a href="#锁，volatile-字段，final-字段与安全发布" class="headerlink" title="锁，volatile 字段，final 字段与安全发布"></a>锁，volatile 字段，final 字段与安全发布</h4><p>&emsp;&emsp;锁，volatile 字段，final 字段与安全发布均为Java 内存模型涉及的几个关键词。<br>&emsp;&emsp;上文提到，锁操作同样具备 happens-before 关系。具体来说，解锁操作 happens-before 之后对同一把锁的加锁操作。实际上，在解锁时，Java 虚拟机同样需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。<br>&emsp;&emsp;需要注意的是，锁操作的 happens-before 规则的关键字是同一把锁。也就意味着，如果编译器能够（通过逃逸分析）证明某把锁仅被同一线程持有，那么它可以移除相应的加锁解锁操作。因此也就不再强制刷新缓存。举个例子，即时编译后的 synchronized (new Object()) {}，可能等同于空操作，而不会强制刷新缓存。<br>&emsp;&emsp;volatile 字段可以看成一种轻量级的、不保证原子性的同步，其性能往往优于（至少不亚于）锁操作。然而，频繁地访问 volatile 字段也会因为不断地强制刷新缓存而严重影响程序的性能。<br>&emsp;&emsp;在 X86_64 平台上，只有 volatile 字段的写操作会强制刷新缓存。<strong>因此，理想情况下对 volatile 字段的使用应当多读少写，并且应当只有一个线程进行写操作。</strong><br>&emsp;&emsp;volatile 字段的另一个特性是即时编译器无法将其分配到寄存器里。换句话说，volatile 字段的每次访问均需要直接从内存中读写。<br>&emsp;&emsp;final 实例字段则涉及新建对象的发布问题。当一个对象包含 final 实例字段时，我们希望其他线程只能看到已初始化的 final 实例字段。因此，即时编译器会在 final 字段的写操作后插入一个写写屏障，以防某些优化将新建对象的发布（将实例对象写入一个共享引用中）重排序至 final 字段的写操作之前。在 X86_64 平台上，写写屏障是空操作。<br>&emsp;&emsp;新建对象的安全发布（safe publication）问题不仅仅包括 final 实例字段的可见性，还包括其他实例字段的可见性。<br>&emsp;&emsp;当发布一个已初始化的对象时，我们希望所有已初始化的实例字段对其他线程可见。否则，其他线程可能见到一个仅部分初始化的新建对象，从而造成程序错误。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li><li>Java 内存模型通过定义了一系列的 happens-before规则，让程序开发者能够轻易地表达不同线程的操作之间的内存可见性。  </li><li>Java 内存模型是通过内存屏障来禁止重排序的。对于即时编译器来说，内存屏障将限制它所能做的重排序优化。对于处理器来说，内存屏障会导致缓存的刷新操作，也就是令CPU缓存失效。volatile关键就是使用内存屏障来实现可见性与重排序的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可见性、原子性和有序性问题：并发编程Bug的源头</title>
      <link href="/2020/03/15/JMM%20%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8BBug%E7%9A%84%E6%BA%90%E5%A4%B4/"/>
      <url>/2020/03/15/JMM%20%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8BBug%E7%9A%84%E6%BA%90%E5%A4%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="可见性、原子性和有序性问题：并发编程Bug的源头"><a href="#可见性、原子性和有序性问题：并发编程Bug的源头" class="headerlink" title="可见性、原子性和有序性问题：并发编程Bug的源头"></a>可见性、原子性和有序性问题：并发编程Bug的源头</h3><p>注：有序性例子应与Java并发编程实战中的竞态条件（检查-执行）相互对比，本文中的有序性例子单例模式是使用synchronized加锁之后仍出现的问题，本质原因是编译器进行了优化。编译器的优化（例如第1行：a=6;  第9999行：a=a*6; 这个时候，把他们放到一起执行，能更好的利用缓存cache了）带来了有序性的问题。  </p><p>&emsp;&emsp;为了解决CPU与I/O设备速度不匹配的问题，引入了内存；为了更高效的利用CPU，又引入了寄存器与缓存（cache），寄存器与cache存在与CPU中，我们平时说的CPU的一级缓存二级缓存就是只得这个cache。<br>&emsp;&emsp;为了合理利用 CPU 的高性能，平衡这三者的速度差异，<strong>计算机体系机构、操作系统、编译程序</strong> 都做出了贡献，主要体现为：  </p><ol><li>CPU 增加了缓存，以均衡与内存的速度差异；  </li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。  </li></ol><p>并发程序很多诡异问题的根源也在这里。</p><h4 id="bug源头一：-内存可见性"><a href="#bug源头一：-内存可见性" class="headerlink" title="bug源头一： 内存可见性"></a>bug源头一： 内存可见性</h4><p>&emsp;&emsp;<strong>一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性。</strong><br>&emsp;&emsp;缓存导致了可见性问题。在单核时代，所有的线程都是在一颗 CPU 上执行，CPU 缓存与内存的数据一致性容易解决。因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。例如在下面的图中，线程 A 和线程 B 都是操作同一个 CPU 里面的缓存，所以线程 A 更新了变量 V 的值，那么线程 B 之后再访问变量 V，得到的一定是 V 的最新值（线程 A 写过的值）。</p><p>TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT</p><p>&emsp;&emsp;多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。图中，线程 A 操作的是 CPU-1 上的缓存，而线程 B 操作的是 CPU-2 上的缓存，很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了。  </p><p>&emsp;&emsp;下面的代码，每执行一次 add10K() 方法，都会循环 10000 次 count+=1 操作。在 calc() 方法中我们创建了两个线程，每个线程调用一次 add10K() 方法，那么执行 calc() 方法得到的结果应该是多少呢？</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>idx<span class="token operator">++</span> <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      count <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Test test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建两个线程，执行 add() 操作</span>    Thread th1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>      test<span class="token punctuation">.</span><span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread th2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>      test<span class="token punctuation">.</span><span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 启动两个线程</span>    th1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    th2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 等待两个线程执行结束</span>    th1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    th2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;直觉告诉我们应该是 20000，因为在单线程里调用两次 add10K() 方法，count 的值就是 20000，但实际上 calc() 的执行结果是个 10000 到 20000 之间的随机数。为什么呢？<br>&emsp;&emsp;我们假设线程 A 和线程 B 同时开始执行，那么第一次都会将 count=0 读到各自的 CPU 缓存里，执行完 count+=1 之后，各自 CPU 缓存里的值都是 1，同时写入内存后，我们会发现内存中是 1，而不是我们期望的 2。之后由于各自的 CPU 缓存里都有了 count 的值，两个线程都是基于 CPU 缓存里的 count 值来计算，所以导致最终 count 的值都是小于 20000 的。这就是缓存的可见性问题。</p><h4 id="bug源头之二：线程切换带来的原子性问题"><a href="#bug源头之二：线程切换带来的原子性问题" class="headerlink" title="bug源头之二：线程切换带来的原子性问题"></a>bug源头之二：线程切换带来的原子性问题</h4><p>&emsp;&emsp;由于 IO 太慢，早期的操作系统就发明了多进程，即便在单核的 CPU 上我们也可以一边听着歌，一边写 Bug，这个就是多进程的功劳。<br>&emsp;&emsp;操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行（我们称为“任务切换”），这个 50 毫秒称为“时间片”。<br>&emsp;&emsp;在一个时间片内，如果一个进程进行一个 IO 操作，例如读个文件，这个时候该进程可以把自己标记为“休眠状态”并出让 CPU 的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得 CPU 的使用权了。<br>这里的进程在等待 IO 时之所以会释放 CPU 使用权，是为了让 CPU 在这段等待时间里可以做别的事情，这样一来 CPU 的使用率就上来了；此外，如果这时有另外一个进程也读文件，读文件的操作就会排队，磁盘驱动在完成一个进程的读操作后，发现有排队的任务，就会立即启动下一个读操作，这样 IO 的使用率也上来了。<br>&emsp;&emsp;是不是很简单的逻辑？但是，虽然看似简单，支持多进程分时复用在操作系统的发展史上却具有里程碑意义，Unix 就是因为解决了这个问题而名噪天下的。<br>&emsp;&emsp;早期的操作系统基于进程来调度 CPU，不同进程间是不共享内存空间的，所以进程要做任务切换就要切换内存映射地址，而一个进程创建的所有线程，都是共享一个内存空间的，所以线程做任务切换成本就很低了。现代的操作系统都基于更轻量的线程来调度，<strong>现在我们提到的“任务切换”都是指“线程切换”</strong>。<br>&emsp;&emsp;Java 并发程序都是基于多线程的，自然也会涉及到任务切换，也许你想不到，任务切换竟然也是并发编程里诡异 Bug 的源头之一。任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成，例如count += 1，至少需要三条 CPU 指令。    </p><ol><li>指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；  </li><li>指令 2：之后，在寄存器中执行 +1 操作；  </li><li>指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。    </li></ol><p>&emsp;&emsp;操作系统做任务切换，可以发生在任何一条 <strong>CPU 指令</strong> 执行完，是的，是 CPU 指令，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设 count=0，如果线程 A 在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么我们会发现两个线程都执行了 count+=1 的操作，但是得到的结果不是我们期望的 2，而是 1。<br>&emsp;&emsp;我们潜意识里面觉得 count+=1 这个操作是一个不可分割的整体，就像一个原子一样，线程的切换可以发生在 count+=1 之前，也可以发生在 count+=1 之后，但就是不会发生在中间。我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性。CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符，这是违背我们直觉的地方。因此，很多时候我们需要在高级语言层面保证操作的原子性。</p><h4 id="源头之三：编译优化带来的有序性问题"><a href="#源头之三：编译优化带来的有序性问题" class="headerlink" title="源头之三：编译优化带来的有序性问题"></a>源头之三：编译优化带来的有序性问题</h4><p>&emsp;&emsp;有序性，顾名思义，有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序，例如程序中：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”，在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。不过有时候编译器及解释器的优化可能导致意想不到的 Bug。</p><p>&emsp;&emsp;在 Java 领域一个经典的案例就是利用双重检查创建单例对象，例如下面的代码：在获取实例 getInstance() 的方法中，我们首先判断 instance 是否为空，如果为空，则锁定 Singleton.class 并再次检查 instance 是否为空，如果还为空则创建 Singleton 的一个实例。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>  <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>  <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">synchronized</span><span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span>          instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 instance == null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。</p><p>这看上去一切都很完美，无懈可击，但实际上这个 getInstance() 方法并不完美。问题出在哪里呢？出在 new 操作上，我们以为的 new 操作应该是：</p><ol><li>分配一块内存 M；</li><li>在内存 M 上初始化 Singleton 对象；</li><li>然后 M 的地址赋值给 instance 变量。</li></ol><p>但是实际上优化后的执行路径却是这样的：</p><ol><li>分配一块内存 M；</li><li>将 M 的地址赋值给 instance 变量；</li><li>最后在内存 M 上初始化 Singleton 对象。</li></ol><p>&emsp;&emsp;优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 instance != null ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。<br>&emsp;&emsp;上面的例子中，A如果没有完成实例的初始化，锁应该不会释放的，B是拿不到锁的，怎么还会出问题呢？是因为线程切换到B时，线程B刚好执行到第一次判断instance==null，此时不为空，不用进入synchronized里，就将还未初始化的instance返回了。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微商城项目用户管理模块总结</title>
      <link href="/2020/02/15/mmall_user/"/>
      <url>/2020/02/15/mmall_user/</url>
      
        <content type="html"><![CDATA[<p>用户管理分为门户用户管理与后台用户管理，本篇先对门户用户管理进行总结。<br>要具体实现以下需求：  </p><ol><li>登录</li><li>注册</li><li>检查用户名、邮箱是否有效  </li><li>获取用户登录信息</li><li>忘记密码进行修改密码</li><li>登录状态进行修改密码</li><li>登录状态修改个人信息</li><li>获取当前用户的登录信息，并要求强制登录</li><li>退出当前登录</li></ol><h4 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h4><p>编写了高可用的类，用来存储不同的返回对象，有三个实例属性：int status; String msg; T data。</p><h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>登录会首先查询用户名是否存在（根据select（1）…），若用户名存在，再进行用户名与密码的查询，否则直接返回用户名不存在。将查询的User对象（去除password）存在session中：<code>session.setAttribute(Const.CURRENT_USER, serverResponse.getData());</code><br>需要注意的是，我们的数据库没用存密码明文，寸的是md5加密的密文，因为md5的算法是固定的，所以会有针对md5算法的密码库，所以为了减小密文被破解的可能性，对md5加密进行了加盐salt操作，即在需要加密的字符串后面再拼接一段固定的字符串。  </p><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>注册通过Spring MVC的数据绑定，使controller方法直接接收User对象，在填写注册信息时，可以对用户名、邮箱是否已经存在进行实时检测。<br>需要注意的是，尽管已经在页面对username、Email进行了实时的检测，但是在service层编写具体实现时，仍要进行username与Email的检测。因为恶意者可能会直接调用这个接口进行插入操作，从而插入重复username与Email。    </p><h4 id="检查用户名、邮箱是否有效"><a href="#检查用户名、邮箱是否有效" class="headerlink" title="检查用户名、邮箱是否有效"></a>检查用户名、邮箱是否有效</h4><p>username与Email的检测代码可以整合到一起，调用方法时使用一个参数进行控制。  </p><h4 id="获取用户登录信息"><a href="#获取用户登录信息" class="headerlink" title="获取用户登录信息"></a>获取用户登录信息</h4><p>直接在controller层中，在session中进行获取：<code>User user = (User) httpSession.getAttribute(Const.CURRENT_USER);</code>  </p><h4 id="忘记密码进行修改密码"><a href="#忘记密码进行修改密码" class="headerlink" title="忘记密码进行修改密码"></a>忘记密码进行修改密码</h4><p>这个过程主要有三步：1.获取密保问题 2.对密保问题进行验证 3.对密码进行更新<br>其中比较关键的是第三步，因为存在恶意者直接伪造相关参数调用步骤3的接口。<br>当然有个简单粗暴的方法：将验证问题与密码更新合为一步进行操作，但是这样用户体验极其不友好，如果密保答案不一定对，把更新的密码填进去也是没用的。<br>在这里，我的解决思路是：对第2步进行验证之后，若验证成功，会产生一个token存储在服务器中，同时该token值也会返回给前端，前端在调用步骤3的接口时需要提供该token值，后台会验证调用时传来的该token值与服务器中存储的token值，若一致才可继续执行。<br>需要注意的一些细节是，步骤1可以直接靠username进行密保问题的获取。步骤2验证时使用username、question、answer进行查询即可。产生的token可以存在redis、guava中，并设置失效的时间。目前项目使用guava进行存储，后期计划对项目进行进一步改造，使用redis代替guava。</p><h4 id="登录状态进行修改密码"><a href="#登录状态进行修改密码" class="headerlink" title="登录状态进行修改密码"></a>登录状态进行修改密码</h4><p>在controller层中，从session中取出当前用户。<br>防止横向越权,service要校验一下这个用户的旧密码,一定要指定是这个用户（…where password … and userId…）。加上一个本用户的userId避免遇到password一样的用户。</p><h4 id="登录状态修改个人信息"><a href="#登录状态修改个人信息" class="headerlink" title="登录状态修改个人信息"></a>登录状态修改个人信息</h4><p>需要注意的是，1.username是不能被更新的 。2.email也要进行一个校验,校验新的email是不是已经存在,并且存在的email如果相同的话,不能是我们当前的这个用户的。  </p><pre class="line-numbers language-java"><code class="language-java">  User updateUser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  updateUser<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  updateUser<span class="token punctuation">.</span><span class="token function">setEmail</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  updateUser<span class="token punctuation">.</span><span class="token function">setPhone</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  updateUser<span class="token punctuation">.</span><span class="token function">setQuestion</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getQuestion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  updateUser<span class="token punctuation">.</span><span class="token function">setAnswer</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getAnswer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> updateCount <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">updateByPrimaryKeySelective</span><span class="token punctuation">(</span>updateUser<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>updateCount <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> ServerResponse<span class="token punctuation">.</span><span class="token function">createBySuccess</span><span class="token punctuation">(</span><span class="token string">"更新个人信息成功"</span><span class="token punctuation">,</span>updateUser<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> ServerResponse<span class="token punctuation">.</span><span class="token function">createByErrorMessage</span><span class="token punctuation">(</span><span class="token string">"更新个人信息失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中，<code>user</code>是Spring MVC通过数据绑定生成的User对象，这个<code>user</code>对象存储的是页面更新的值。<br><code>userMapper.updateByPrimaryKeySelective(updateUser)</code>这个方法进行更新时，会对所有的字段进行判断，如果这个字段对应的属性是null，那么这个字段就不会进行更新（被覆盖为null，例如updateUser的password属性就为null，但是这个方法更新updateUser时，并不会覆盖原有已经存在值的password字段）。  </p><h4 id="获取当前用户的登录信息，并要求强制登录"><a href="#获取当前用户的登录信息，并要求强制登录" class="headerlink" title="获取当前用户的登录信息，并要求强制登录"></a>获取当前用户的登录信息，并要求强制登录</h4><p>先检查session中是否有用户，在service中去除password，返回给前端。  </p><h4 id="退出当前登录"><a href="#退出当前登录" class="headerlink" title="退出当前登录"></a>退出当前登录</h4><p>直接在controller中，将user从session中移除：<code>session.removeAttribute(Const.CURRENT_USER);</code>  </p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>开始时提到设计了一个高可用的类，它可以封装各种结果，方便的从service到controller，从controller到页面的数据封装传递。它将构造方法隐藏起来，调用静态方法。在设计时要注意方法参数有String与泛型时的问题。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@JsonSerialize</span><span class="token punctuation">(</span>include <span class="token operator">=</span>  JsonSerialize<span class="token punctuation">.</span>Inclusion<span class="token punctuation">.</span>NON_NULL<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//保证序列化json的时候,如果是null的对象,key也会消失</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServerResponse</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> status<span class="token punctuation">;</span>    <span class="token keyword">private</span> String msg<span class="token punctuation">;</span>    <span class="token keyword">private</span> T data<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">ServerResponse</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> status<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token function">ServerResponse</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">,</span> String msg<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> status<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token function">ServerResponse</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">,</span> T data<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> status<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token function">ServerResponse</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">,</span>String msg<span class="token punctuation">,</span> T data<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> status<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token comment" spellcheck="true">//Jackson忽略该方法</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">==</span> ResponseCode<span class="token punctuation">.</span>SUCCESS<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// success情况</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> ServerResponse<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">createBySuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span>  <span class="token class-name">ServerResponse</span><span class="token operator">&lt;</span><span class="token operator">></span> <span class="token punctuation">(</span>ResponseCode<span class="token punctuation">.</span>SUCCESS<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> ServerResponse<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">createBySuccessMessage</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span>  <span class="token class-name">ServerResponse</span><span class="token operator">&lt;</span><span class="token operator">></span> <span class="token punctuation">(</span>ResponseCode<span class="token punctuation">.</span>SUCCESS<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> ServerResponse<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">createBySuccess</span><span class="token punctuation">(</span>T data<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span>  <span class="token class-name">ServerResponse</span><span class="token operator">&lt;</span><span class="token operator">></span> <span class="token punctuation">(</span>ResponseCode<span class="token punctuation">.</span>SUCCESS<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> ServerResponse<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">createBySuccess</span><span class="token punctuation">(</span>String msg<span class="token punctuation">,</span> T data<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span>  <span class="token class-name">ServerResponse</span><span class="token operator">&lt;</span><span class="token operator">></span> <span class="token punctuation">(</span>ResponseCode<span class="token punctuation">.</span>SUCCESS<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Error情况</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> ServerResponse<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">createByError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ServerResponse</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>ResponseCode<span class="token punctuation">.</span>ERROR<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ResponseCode<span class="token punctuation">.</span>ERROR<span class="token punctuation">.</span><span class="token function">getDesc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> ServerResponse<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">createByErrorMessage</span><span class="token punctuation">(</span>String errorMessage<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ServerResponse</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>ResponseCode<span class="token punctuation">.</span>ERROR<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>errorMessage<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> ServerResponse<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">createByErrorCodeMessage</span><span class="token punctuation">(</span><span class="token keyword">int</span> errorCode<span class="token punctuation">,</span>String errorMessage<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ServerResponse</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>errorCode<span class="token punctuation">,</span>errorMessage<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> status<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> T <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> data<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> msg<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM类加载机制</title>
      <link href="/2019/12/29/JVM%20ClassLoader/"/>
      <url>/2019/12/29/JVM%20ClassLoader/</url>
      
        <content type="html"><![CDATA[<ul><li>从大的方面讲，类加载的结果是把一段字节流变换成Class结构并写方法区，在加载阶段就已经生成class结构了，所以我认为在加载阶段应该已经写入了方法区，只是被标记为未链接而暂不能使用。</li><li>类的初始化只会发生一次，与new实例的初始化不是一个概念。  </li><li>JVM并不会直接使用.class文件，类加载链接的目的就是在JVM中创建相应的类结构，会存储在元空间（老说法就是方法区）。  </li><li>双亲委派呀，明明只给了父类加载所以应该是单亲的，并且英文中为parent不带s，照理应该翻译为单亲。但既然约定俗成翻译为双亲。</li><li>针对上一点，我认为还有另一种解释：在类加载的过程中，有一个委派模式，这里严格来说应该不是使用的继承方式，应该是组合。它委派的那个对象名字叫parent。可能翻译为双亲比较不容易混淆。  </li><li>加载阶段都加载哪些类呢，那么多类，全部加载吗？其实加载阶段是针对单个类的，一般用到的类才会被加载。大部分情况下，不同类的加载时机是不同的。</li><li>加载是类加载的一个过程。    </li></ul><p>&emsp;众所周知，Class文件描述了各种各样的信息，如果要使用的话，必须加载到虚拟机之中。虚拟机把数据Class文件加载到内存，并对数据进行校验、转换解析与初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程就称为JVM的类加载机制。  </p><p>从 class 文件到内存中的类，按先后顺序需要经过加载、链接以及初始化三大步骤。其中，链接过程中同样需要验证；而内存中的类没有经过初始化，同样不能使用。那么，是否所有的 Java 类都需要经过这几步呢？    </p><p>我们知道 Java 语言的类型可以分为两大类：基本类型（primitive types）和引用类型（reference types）。</p><p>对于引用类型，Java 将其细分为四种：<strong>类、接口、数组类和泛型参数</strong>。由于泛型参数会在编译过程中被擦除（转为Object），因此 Java 虚拟机实际上只有前三种。在类、接口和数组类中，数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。</p><blockquote><p>针对于<strong>字节流</strong>，最常见的形式要属由 Java 编译器生成的 class 文件。除此之外，我们也可以在程序内部直接生成，或者从网络中获取（例如网页中内嵌的小程序 Java applet）字节流。这些不同形式的字节流，都会被加载到 Java 虚拟机中，成为类或接口。为了叙述方便，下面我就用“类”来统称它们。</p></blockquote><p>实际上，无论是直接生成的数组类，还是加载的类，Java 虚拟机都需要对其进行链接和初始化。  </p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>&emsp;加载，是指查找字节流，并且据此创建类的过程。上面提到，对于数组类来说，它并没有对应的字节流，而是由 Java 虚拟机直接生成的。对于其他的类来说，Java 虚拟机则需要借助类加载器来完成查找字节流的过程。<br>&emsp; 类加载器有着不同的层次，不同层次的类加载器执行的优先级是不一样的。最高等级的类加载器，叫 <strong>启动类加载器（boot class loader）</strong>。启动类加载器是由 C++ 实现的，没有对应的 Java 对象，因此在 Java 中只能用 null 来指代。换句话说，等级高的类似乎看不起其它等级的类，所以非最高级的类加载器谁也没有启动类加载器的联系方式。<br>&emsp;除了启动类加载器之外，其他的类加载器都是 java.lang.ClassLoader 的子类，因此有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。<br>&emsp;在这个等级森严的类加载体系中有一个潜规则，就是接到单子自己不能着手干，得先给上一层次的类加载器过过目。一层次的类加载器不接手的情况下，才能自己来。在 Java 虚拟机中，这个潜规则有个特别的名字，叫 <strong>双亲委派模型</strong> 。每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。<strong>在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载</strong>。<br>&emsp;在 Java 9 之前，启动类加载器负责加载最为基础、最为重要的类，比如存放在 JRE 的 lib 目录下 jar 包中的类（以及由虚拟机参数 -Xbootclasspath 指定的类）。除了启动类加载器之外，另外两个重要的类加载器是扩展类加载器（extension class loader）和应用类加载器（application class loader），均由 Java 核心类库提供。<br>&emsp;<strong>扩展类加载器</strong> 的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。<br>&emsp;<strong>应用类加载器</strong> 的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。<br>&emsp;Java 9 引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。<br>&emsp;除了由 Java 核心类库提供的类加载器外，我们还可以加入 <strong>自定义的类加载器</strong>，来实现特殊的加载方式。举例来说，我们可以对 class 文件进行加密，加载时再利用自定义的类加载器对其解密。<br>&emsp;在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。 <strong>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</strong>  </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>&emsp;链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为 <strong>验证、准备以及解析</strong> 三个阶段。<br>&emsp;<strong>验证</strong> 阶段的目的，在于确保被加载类能够满足 Java 虚拟机的约束条件。通常而言，Java 编译器生成的类文件必然满足 Java 虚拟机的约束条件。<br>&emsp;<strong>准备</strong> 阶段的目的，则是为被加载类的静态字段分配内存。Java 代码中对静态字段的具体初始化，则会在稍后的初始化阶段中进行。过了这个阶段，咱们算是盖好了毛坯房。虽然结构已经完整，但是在没有装修之前是不能住人的。<br>&emsp;除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。<br>&emsp;在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。<br>&emsp;<strong>解析</strong> 阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）<br>&emsp;如果将这段话放在盖房子的语境下，那么符号引用就好比“Tony 的房子”这种说法，不管它存在不存在，我们都可以用这种说法来指代 Tony 的房子。实际引用则好比实际的通讯地址，如果我们想要与 Tony 通信，则需要知道其具体地址。  </p><blockquote><p>&emsp;Java虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。</p></blockquote><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>&emsp;在Java代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。<br>&emsp;如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 &lt; clinit &gt;。<br>&emsp;类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行 &lt; clinit &gt; 方法的过程。Java 虚拟机会通过加锁来确保类的 &lt; clinit &gt; 方法仅被执行一次。<br>&emsp;只有当初始化完成之后，类才正式成为可执行的状态。这放在我们盖房子的例子中就是，只有当房子装修过后，Tony 才能真正地住进去。<br>&emsp;那么，类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况：  </p><ol><li>当虚拟机启动时，初始化用户指定的主类；</li><li>当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；</li><li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li><li>当遇到访问静态字段的指令时，初始化该静态字段所在的类；</li><li>子类的初始化会触发父类的初始化；</li><li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；</li><li>使用反射 API 对某个类进行反射调用时，初始化这个类；</li><li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LazyHolder</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> LazyHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;上面这段代码是在著名的单例延迟初始化例子，只有当调用 Singleton.getInstance时，程序才会访问 LazyHolder.INSTANCE，才会触发对LazyHolder 的初始化（对应第 4 种情况），继而新建一个 Singleton 的实例。<br>&emsp;由于类初始化是线程安全的，并且仅被执行一次，因此程序可以确保多线程环境下有且仅有一个 Singleton 实例。    </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;本篇介绍了 Java 虚拟机将字节流转化为 Java 类的过程。这个过程可分为加载、链接以及初始化三大步骤。<br>&emsp;加载是指查找字节流，并且据此创建类的过程。加载需要借助类加载器，在 Java 虚拟机中，类加载器使用了双亲委派模型，即接收到加载请求时，会先将请求转发给父类加载器。<br>&emsp;链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。链接还分验证、准备和解析三个阶段。其中，解析阶段为非必须的。<br>&emsp;初始化，则是为标记为常量值的字段赋值，以及执行 &lt; clinit &gt; 方法的过程。类的初始化仅会被执行一次，这个特性被用来实现单例的延迟初始化。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收（中）</title>
      <link href="/2019/12/21/JVM%20GC_2/"/>
      <url>/2019/12/21/JVM%20GC_2/</url>
      
        <content type="html"><![CDATA[<p>&emsp;大部分的 Java 对象只存活一小段时间，而存活下来的小部分 Java 对象则会存活很长一段时间。下图（Java 对象生命周期的直方图，红色的表示被逃逸分析优化掉的对象）是一些研究者对Java对象生命周期的动态分析的结果。 </p><p><img src="/images/JVM_GC.png" alt="Alt text">    </p><p>&emsp;&emsp;Java 虚拟机的分代回收思想。简单来说，就是将堆空间划分为两代，分别叫做新生代和老年代。新生代用来存储新建的对象。当对象存活时间够长时，则将其移动到老年代。<br>&emsp;&emsp;Java 虚拟机可以给不同代使用不同的回收算法。对于 <strong>于新生代</strong>，我们猜测大部分的 Java 对象只存活一小段时间，那么便可以频繁地采用耗时较短的垃圾回收算法，让大部分的垃圾都能够在新生代被回收掉。<br>&emsp;&emsp;对于 <strong>老年代</strong>，我们猜测大部分的垃圾已经在新生代中被回收了，而在老年代中的对象有大概率会继续存活。当真正触发针对老年代的回收时，则代表这个假设出错了，或者堆的空间已经耗尽了。<br>&emsp;&emsp;这时候，Java 虚拟机往往需要做一次全堆扫描，耗时也将不计成本。（当然，现代的垃圾回收器都在并发收集的道路上发展，来避免这种全堆扫描的情况。）<br>&emsp;&emsp;本文我们会首先关注一下针对新生代的 Minor GC。以下我们先探讨下Java 虚拟机中的堆具体是咋划分的。  </p><h3 id="Java-虚拟机的堆划分"><a href="#Java-虚拟机的堆划分" class="headerlink" title="Java 虚拟机的堆划分"></a>Java 虚拟机的堆划分</h3><p>&emsp;&emsp;众所周知，Java 虚拟机将堆划分为新生代和老年代。其中，新生代又被划分为 Eden 区，以及两个大小相同的 Survivor 区。<br>&emsp;&emsp;默认情况下，Java 虚拟机采取的是一种动态分配的策略（对应 Java 虚拟机参数 <strong>-XX:+UsePSAdaptiveSurvivorSizePolicy</strong>），根据生成对象的速率，以及 Survivor 区的使用情况动态调整 Eden 区和 Survivor 区的比例。<br>&emsp;&emsp;当然，我们也可以通过参数 <strong>-XX:SurvivorRatio</strong> 来固定这个比例。但是需要注意的是，其中一个 Survivor 区会一直为空，因此比例越低浪费的堆空间将越高。<br><img src="/images/JVM_GCFromTo.png" alt="Alt text"><br>&emsp;&emsp;通常来说，当我们调用 new 指令时，它会在 Eden 区中划出一块作为存储对象的内存。由于堆空间是线程共享的，因此直接在这里边划空间是需要进行同步的。<br>&emsp;&emsp;否则，将有可能出现两个对象共用一段内存的事故。这里就相当于两个司机（线程）同时将车停入同一个停车位，因而发生剐蹭事故。<br>&emsp;&emsp;Java 虚拟机的解决方法是为每个司机预先申请多个停车位，并且只允许该司机停在自己的停车位上。那么当司机的停车位用完了该怎么办呢（假设这个司机代客泊车）？<br>&emsp;&emsp;答案是：再申请多个停车位便可以了。这项技术被称之为 TLAB（Thread Local Allocation Buffer，对应虚拟机参数 -XX:+UseTLAB，默认开启）。<br>&emsp;&emsp;具体来说，每个线程可以向 Java 虚拟机申请一段连续的内存，比如 2048 字节，作为线程私有的 TLAB。<br>&emsp;&emsp;这个操作需要加锁，线程需要维护两个指针（实际上可能更多，但重要也就两个），一个指向 TLAB 中空余内存的起始位置，一个则指向 TLAB 末尾。<br>&emsp;&emsp;接下来的 new 指令，便可以直接通过指针加法（bump the pointer）来实现，即把指向空余内存位置的指针加上所请求的字节数。   </p><blockquote><p>至于什么不把 bump the pointer 翻译成指针碰撞。是因为在英语中我们通常省略了 bump up the pointer 中的 up。在这个上下文中 bump 的含义应为“提高”。另外一个例子是当我们发布软件的新版本时，也会说 bump the version number。  </p></blockquote><p>&emsp;&emsp;如果加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。否则，TLAB 已经没有足够的空间来满足本次新建操作。这个时候，便需要当前线程重新申请新的 TLAB。<br>&emsp;&emsp;当 Eden 区的空间耗尽了怎么办？这个时候 Java 虚拟机便会触发一次 Minor GC，来收集新生代的垃圾。存活下来的对象，则会被送到 Survivor 区。<br>&emsp;&emsp;前面提到，新生代共有两个 Survivor 区，我们分别用 from 和 to 来指代。其中 to 指向的 Survivior 区是空的。<br>&emsp;&emsp;<strong>当发生 Minor GC 时，Eden 区和 from 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。</strong><br>&emsp;&emsp;Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 -<strong>XX:+MaxTenuringThreshold</strong>），那么该对象将被晋升（promote）至老年代。另外，如果单个 Survivor 区已经被占用了 50%（对应虚拟机参数 <strong>-XX:TargetSurvivorRatio</strong>），那么较高复制次数的对象也会被晋升至老年代。<br>&emsp;&emsp;总而言之，当发生 Minor GC 时，我们应用了 <strong>标记 - 复制 (copy)</strong> 算法，将 Survivor 区中的老存活对象晋升到老年代，然后将剩下的存活对象和 Eden 区的存活对象复制到另一个 Survivor 区中。<strong>理想情况下，Eden 区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种标记 - 复制算法的效果极好。</strong><br>&emsp;&emsp;Minor GC 的另外一个好处是不用对整个堆进行垃圾回收。但是，它却有一个问题，那就是 <strong>老年代的对象可能引用新生代的对象</strong>。也就是说，在标记存活对象的时候，我们需要扫描老年代中的对象。如果该对象拥有对新生代对象的引用，那么这个引用也会被作为 GC Roots。<br>&emsp;&emsp;这样一来，岂不是又做了一次全堆扫描呢？   </p><h4 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h4><p>&emsp;&emsp;HotSpot 给出的解决方案是一项叫做卡表（Card Table）的技术。该技术 <strong>将整个堆划分为一个个大小为 512 字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。</strong> 这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。<br>&emsp;&emsp;在进行 Minor GC 的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。<br>&emsp;&emsp;由于 Minor GC 伴随着存活对象的复制，而复制需要更新指向该对象的引用。因此，在更新引用的同时，我们又会设置引用所在的卡的标识位。这个时候，我们可以确保脏卡中必定包含指向新生代对象的引用。<br>&emsp;&emsp;在 Minor GC 之前，我们并不能确保脏卡中包含指向新生代对象的引用。其原因和如何设置卡的标识位有关。首先，如果想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么 Java 虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。这个操作在解释执行器中比较容易实现。但是在即时编译器生成的机器码中，则需要插入额外的逻辑。这也就是所谓的写屏障（ <strong>write barrier，注意不要和 volatile 字段的写屏障混淆</strong>）。<br>&emsp;&emsp;写屏障需要尽可能地保持简洁。这是因为我们并不希望在每条引用型实例变量的写指令后跟着一大串注入的指令。<br>&emsp;&emsp;因此，写屏障并不会判断更新后的引用是否指向新生代中的对象，而是宁可错杀，不可放过，一律当成可能指向新生代对象的引用。<br>&emsp;&emsp;这么一来，写屏障便可精简为下面的伪代码。这里右移 9 位相当于除以 512，Java 虚拟机便是通过这种方式来从地址映射到卡表中的索引的。最终，这段代码会被编译成一条移位指令和一条存储指令。</p><pre class="line-numbers language-java"><code class="language-java">CARD_TABLE <span class="token punctuation">[</span><span class="token keyword">this</span> address <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> DIRTY<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&emsp;&emsp;虽然写屏障不可避免地带来一些开销，但是它能够加大 Minor GC 的　<strong>吞吐率（ 应用运行时间 /(应用运行时间 + 垃圾回收时间) ）</strong>。总的来说还是值得的。不过，在高并发环境下，写屏障又带来了 <strong>虚共享（false sharing）</strong> 问题。<br>&emsp;&emsp;在对象内存布局中遇到的虚共享问题，讲的是几个 volatile 字段出现在同一缓存行里造成的虚共享。这里的虚共享则是卡表中不同卡的标识位之间的虚共享问题。<br>&emsp;&emsp;在 HotSpot 中，卡表是通过 byte 数组来实现的。对于一个 64 字节的缓存行来说，如果用它来加载部分卡表，那么它将对应 64 张卡，也就是 32KB 的内存。<br>&emsp;&emsp;如果同时有两个 Java 线程，在这 32KB 内存中进行引用更新操作，那么也将造成存储卡表的同一部分的缓存行的写回、无效化或者同步操作，因而间接影响程序性能。<br>&emsp;&emsp;为此，HotSpot 引入了一个新的参数 <strong>-XX:+UseCondCardMark</strong>，来尽量减少写卡表的操作。其伪代码如下所示：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>CARD_TABLE <span class="token punctuation">[</span><span class="token keyword">this</span> address <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">!=</span> DIRTY<span class="token punctuation">)</span>CARD_TABLE <span class="token punctuation">[</span><span class="token keyword">this</span> address <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> DIRTY<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;本文介绍了 Java 虚拟机中垃圾回收具体实现的一些通用知识。<br>&emsp;&emsp;Java 虚拟机将堆分为新生代和老年代，并且对不同代采用不同的垃圾回收算法。其中，新生代分为 Eden 区和两个大小一致的 Survivor 区，并且其中一个 Survivor 区是空的。<br>&emsp;&emsp;在只针对新生代的 Minor GC 中，Eden 区和非空 Survivor 区的存活对象会被复制到空的 Survivor 区中，当 Survivor 区中的存活对象复制次数超过一定数值时，它将被晋升至老年代。<br>&emsp;&emsp;因为 Minor GC 只针对新生代进行垃圾回收，所以在枚举 GC Roots 的时候，它需要考虑从老年代到新生代的引用。为了避免扫描整个老年代，Java 虚拟机引入了名为卡表的技术，大致地标出可能存在老年代到新生代引用的内存区域。  </p><p>Java 虚拟机的分代垃圾回收是基于大部分对象只存活一小段时间，小部分对象却存活一大段时间的假设的。<br>然而，现实情况中并非每个程序都符合前面提到的假设。如果一个程序拥有中等生命周期的对象，并且刚移动到老年代便不再使用，那么将给默认的垃圾回收策略造成极大的麻烦。</p><ul><li>JVM分代收集新生代对象进入老年代，年龄为是15是因为HotSpot会在对象头中的标记字段里记录年龄，分配到的空间只有4位，最多只能记录到15。    </li><li>堆内存分代后，会根据他们的不同特点来区别对待，进行垃圾回收的时候会使用不同的垃圾回收方式，针对新生代的垃圾回收器有如下三个：Serial、Parallel Scavenge、Parallel New，他们采用的都是标记-复制的垃圾回收算法。</li><li>针对老年代的垃圾回收器有如下三个：Serial Old 、Parallel Old 、CMS，他们使用的都是标记-压缩的垃圾回收算法。</li><li>TLAB（Thread Local Allocation Buffer）-这个技术是用于解决多线程竞争堆内存分配问题的，核心原理是对分配一些连续的内存空间。  </li><li>卡表是为了处理minor gc时老年代对新生代的引用，为了避免整堆扫描而提出了卡表的概念。</li></ul><p>如有问题，我们可以邮件联系：<a href="mailto:mee.gaoyang@OutLook.com" target="_blank" rel="noopener">mee.gaoyang@OutLook.com</a>  :)</p><h3 id="参考Blog"><a href="#参考Blog" class="headerlink" title="参考Blog"></a>参考Blog</h3><p>[1]<a href="https://blogs.oracle.com/dave/false-sharing-induced-by-card-table-marking" target="_blank" rel="noopener">https://blogs.oracle.com/dave/false-sharing-induced-by-card-table-marking</a>  </p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收(上)</title>
      <link href="/2019/12/15/JVM%20GC_1/"/>
      <url>/2019/12/15/JVM%20GC_1/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;<em>茨威格在为路易十六的妻子玛丽·安托瓦内特写传记时曾无比感慨 “她那时候还太年轻，不知道所有命运馈赠的礼物，早已在暗中标好了价格”。</em>     </p><p>&emsp;&emsp;JVM的内存管理，将原本由开发人员手动管理的内存，交给垃圾回收器来自动的回收管理。虽然极大的减轻了开发者的负担，但既然是自定机制，肯定不会像手动回收那样精准，同时还带来了不少与垃圾回收相关的问题，我们所要关注的就是该如何解决、缓解这些问题。  </p><h3 id="引用计数法与可达性分析"><a href="#引用计数法与可达性分析" class="headerlink" title="引用计数法与可达性分析"></a>引用计数法与可达性分析</h3><p>&emsp;&emsp;垃圾回收，顾名思义，便是将已经分配出去的，但却不再使用的内存回收回来，以便能够再次分配。<strong>在 Java 虚拟机的语境下，垃圾指的是死亡的对象所占据的堆空间。这里便涉及了一个关键的问题：如何辨别一个对象是存是亡？</strong>  </p><p>&emsp;&emsp;有一种古老的辨别方法：引用计数法（reference counting）。它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。  </p><p>&emsp;&emsp;它的具体实现是这样子的：如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。也就是说，我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。  </p><p>&emsp;&emsp;除了需要额外的空间来存储计数器，以及繁琐的更新操作，引用计数法还有一个重大的漏洞，那便是无法处理循环引用对象。  </p><p>&emsp;&emsp;举个例子，假设对象 a 与 b 相互引用，除此之外没有其他引用指向 a 或者 b。在这种情况下，a 和 b 实际上已经死了，但由于它们的引用计数器皆不为 0，在引用计数法的心中，这两个对象还活着。因此，这些循环引用对象所占据的空间将不可回收，从而造成了内存泄露。  </p><p>&emsp;&emsp;目前 Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。  </p><p>&emsp;&emsp;那么什么是 GC Roots 呢？我们可以暂时理解为由堆外指向堆内的引用，一般而言，GC Roots 包括（但不限于）如下几种：  </p><ol><li>Java 方法栈桢中的局部变量；</li><li>已加载类的静态变量；</li><li>JNI handles；</li><li>已启动且未停止的 Java 线程。  </li></ol><p>&emsp;&emsp;可达性分析可以解决引用计数法所不能解决的循环引用问题。举例来说，即便对象 a 和 b 相互引用，只要从 GC Roots 出发无法到达 a 或者 b，那么可达性分析便不会将它们加入存活对象合集之中。虽然可达性分析的算法本身很简明，但是在实践中还是有不少其他问题需要解决的。比如说，在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）。误报并没有什么伤害，Java 虚拟机至多损失了部分垃圾回收的机会。漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 Java 虚拟机崩溃。  </p><h3 id="Stop-the-world-以及安全点"><a href="#Stop-the-world-以及安全点" class="headerlink" title="Stop-the-world 以及安全点"></a>Stop-the-world 以及安全点</h3><p>&emsp;&emsp;如何解决上面提到的漏报问题呢？在 Java 虚拟机里，传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是 Stop-the-world，停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了垃圾回收所谓的暂停时间（GC pause）。</p><p>&emsp;&emsp;Java 虚拟机中的 Stop-the-world 是通过安全点（safepoint）机制来实现的。当 Java 虚拟机收到 Stop-the-world 请求，它便会等待所有的线程都到达安全点，才允许请求 Stop-the-world 的线程进行独占的工作。</p><p>&emsp;&emsp;当然，安全点的初始目的并不是让其他线程停下，而是 <strong>找到一个稳定的执行状态</strong>。在这个执行状态下，Java 虚拟机的堆栈不会发生变化。这么一来，垃圾回收器便能够“安全”地执行可达性分析。 </p><p>&emsp;&emsp;举个例子，当 Java 程序通过 JNI 执行本地代码时，如果这段代码不访问 Java 对象、调用 Java 方法或者返回至原 Java 方法，那么 Java 虚拟机的堆栈不会发生改变，也就代表着这段本地代码可以作为同一个安全点。</p><p>&emsp;&emsp;只要不离开这个安全点，Java 虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。</p><p>&emsp;&emsp;由于本地代码需要通过 JNI 的 API 来完成上述三个操作，因此 Java 虚拟机仅需在 API 的入口处进行安全点检测（safepoint poll），测试是否有其他线程请求停留在安全点里，便可以在必要的时候挂起当前线程。</p><p>&emsp;&emsp;除了执行 JNI 本地代码外，Java 线程还有其他几种状态：<strong>解释执行字节码、执行即时编译器生成的机器码和线程阻塞</strong>。阻塞的线程由于处于 Java 虚拟机线程调度器的掌控之下，因此属于安全点。<br>&emsp;&emsp;其他几种状态则是运行状态，需要虚拟机保证在可预见的时间内进入安全点。否则，垃圾回收线程可能长期处于等待所有线程进入安全点的状态，从而变相地提高了垃圾回收的暂停时间。 </p><p>&emsp;&emsp;对于解释执行来说，字节码与字节码之间皆可作为安全点。Java 虚拟机采取的做法是，当有安全点请求时，执行一条字节码便进行一次安全点检测。  </p><p>&emsp;&emsp;执行即时编译器生成的机器码则比较复杂。由于这些代码直接运行在底层硬件之上，不受 Java 虚拟机掌控，因此在生成机器码时，即时编译器需要插入安全点检测，以避免机器码长时间没有安全点检测的情况。HotSpot 虚拟机的做法便是在生成代码的方法出口以及非计数循环的循环回边（back-edge）处插入安全点检测。<br>&emsp;&emsp;那么为什么不在每一条机器码或者每一个机器码基本块处插入安全点检测呢？原因主要有两个。<br>&emsp;&emsp;第一，安全点检测本身也有一定的开销。不过 HotSpot 虚拟机已经将机器码中安全点检测简化为一个内存访问操作。在有安全点请求的情况下，Java 虚拟机会将安全点检测访问的内存所在的页设置为不可读，并且定义一个 segfault 处理器，来截获因访问该不可读内存而触发 segfault 的线程，并将它们挂起。  </p><p>&emsp;&emsp;第二，即时编译器生成的机器码打乱了原本栈桢上的对象分布状况。在进入安全点时，机器码还需提供一些额外的信息，来表明哪些寄存器，或者当前栈帧上的哪些内存空间存放着指向对象的引用，以便垃圾回收器能够枚举 GC Roots。 </p><p>&emsp;&emsp;由于这些信息需要不少空间来存储，因此即时编译器会尽量避免过多的安全点检测。不过，不同的即时编译器插入安全点检测的位置也可能不同。以 Graal 为例，除了上述位置外，它还会在计数循环的循环回边处插入安全点检测。其他的虚拟机也可能选取方法入口而非方法出口来插入安全点检测。  </p><p>&emsp;&emsp;不管如何，其目的都是在可接受的性能开销以及内存开销之内，避免机器码长时间不进入安全点的情况，间接地减少垃圾回收的暂停时间。  </p><p>&emsp;&emsp;除了垃圾回收之外，Java 虚拟机其他一些对堆栈内容的一致性有要求的操作也会用到安全点这一机制。  </p><h3 id="垃圾回收的三种方式"><a href="#垃圾回收的三种方式" class="headerlink" title="垃圾回收的三种方式"></a>垃圾回收的三种方式</h3><p>&emsp;&emsp;当标记完所有的存活对象时，我们便可以进行死亡对象的回收工作了。主流的基础回收方式可分为三种。  </p><p>&emsp;&emsp;第一种是 <strong>标记-清除（Mark-Sweep）</strong>，即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。清除这种回收方式的原理及其简单，但是有两个缺点。<strong>一是会造成内存碎片。由于 Java 虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。另一个则是分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java 虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。</strong></p><p>&emsp;&emsp;第二种是<strong>标记-整理（Mark——Compact）</strong> （压缩compact）[根据老年代的特点设计]，即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。 </p><p>&emsp;&emsp;第三种则是<strong>复制（copy）</strong> ，即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。<strong>现代虚拟机均使用copy算法来回收新生代，一块Eden两块Survivor，回收时将Eden与一块Survivor中存活的对象全部复制到另一块Survivor中，然后清空Eden与刚用过的Survivor，HotSpot默认Eden与一块Survivor大小比为8：1，当然我们不能假定每次存活的对象都不到10%，一般为2%，如果超过10%则需要依赖其它内存（老年代）进行分配担保（将对象通过分配担保机制直接进入到老年代）。</strong>  </p><p>&emsp;&emsp;当然，现代的垃圾回收器往往会综合上述几种回收方式，综合它们优点的同时规避它们的缺点。在下一篇中我们会详细介绍 Java 虚拟机中垃圾回收算法的具体实现。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis使用总结</title>
      <link href="/2019/12/09/mybatis/"/>
      <url>/2019/12/09/mybatis/</url>
      
        <content type="html"><![CDATA[<h4 id="1-MyBatis-编程步骤"><a href="#1-MyBatis-编程步骤" class="headerlink" title="1. MyBatis 编程步骤"></a>1. MyBatis 编程步骤</h4><ol><li>创建 SqlSessionFactory 对象。构建者模式</li><li>通过 SqlSessionFactory 获取 SqlSession 对象。工厂模式</li><li>通过 SqlSession 获得 Mapper 代理对象。代理模式</li><li>通过 Mapper 代理对象，执行数据库操作。</li><li>执行成功，则使用 SqlSession 提交事务。</li><li>执行失败，则使用 SqlSession 回滚事务。</li><li>最终，关闭会话。<pre class="line-numbers language-java"><code class="language-java"> <span class="token comment" spellcheck="true">//1.读取配置文件</span> InputStream in <span class="token operator">=</span> Resources<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"SqlMapConfig.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//2.创建SqlSessionFactory工厂</span> SqlSessionFactoryBuilder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> SqlSessionFactory factory <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//3.使用工厂创建dao对象</span> IUserDao userDao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserDaoImpl</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//4.使用代理对象执行方法</span> List<span class="token operator">&lt;</span>User<span class="token operator">></span> users <span class="token operator">=</span> userDao<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span>User user <span class="token operator">:</span> users<span class="token punctuation">)</span><span class="token punctuation">{</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//5.手动提交事务、释放资源</span> session<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{} 和 ${} 的区别"></a><code>#{}</code> 和 <code>${}</code> 的区别</h4><p>&ensp;&ensp;&ensp;&ensp;  <code>${}</code> 是 Properties 文件中的变量占位符，它可以用于 XML 标签属性值和 SQL 内部，属于<strong>字符串替换</strong>。例如将 <code>${driver}</code> 会被静态替换为 <code>com.mysql.jdbc.Driver</code> ：  </p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">--</span>用于xml标签，进行属性值（字符串）替换<span class="token operator">--</span><span class="token operator">></span>  <span class="token operator">&lt;</span>dataSource type<span class="token operator">=</span><span class="token string">"UNPOOLED"</span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">--</span>未使用连接池<span class="token operator">--</span><span class="token operator">></span>     <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"driver"</span> value<span class="token operator">=</span><span class="token string">"${driver}"</span><span class="token operator">/</span><span class="token operator">></span>         <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"url"</span> value<span class="token operator">=</span><span class="token string">"${url}"</span><span class="token operator">/</span><span class="token operator">></span>       <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"username"</span> value<span class="token operator">=</span><span class="token string">"${username}"</span><span class="token operator">/</span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>dataSource<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">--</span>用于SQL拼接 ，直接字符串拼接<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">"getSubject"</span> parameterType<span class="token operator">=</span><span class="token string">"Integer"</span> resultType<span class="token operator">=</span><span class="token string">"Subject"</span><span class="token operator">></span>      SELECT <span class="token operator">*</span> FROM subject  WHERE id <span class="token operator">=</span> $<span class="token punctuation">{</span>id<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">></span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>实际场景不应该使用 <code>${id}</code> ,因为直接拼接字符串可能有 SQL 注入的风险。  </li></ul><p>&ensp;&ensp;&ensp;&ensp;  <code>#{}</code> 是 SQL 的<code>参数占位符</code>，Mybatis 会将 SQL语句中的 <code>#{}</code> 替换为 <code>?</code> 号，在 SQL 执行前会使用 PreparedStatement 的参数设置方法，按序给 SQL 的 <code>?</code> 号占位符设置参数值，比如 <code>ps.setInt(0, parameterValue)</code> 。 所以，<code>#{}</code>是 <strong>预编译处理</strong> ，可以有效防止 SQL 注入，提高系统安全性。<br>&ensp;&ensp;&ensp;&ensp;  另外，由于mybatis采用了OGNL表达式的标准，可直接以<code>.</code>的形式进行属性的取值，<code>#{}</code> 和 <code>${}</code> 的取值方式非常方便。例如：<code>#{item.name}</code> 的取值方式，使用反射从参数对象中，获取 <code>item</code> 对象的 <code>name</code> 属性值，相当于 <code>param.getItem().getName()</code> 代替了<code>bject.getName()</code>。</p><h4 id="实体类中的属性名和表中的字段名不一样-解决方法"><a href="#实体类中的属性名和表中的字段名不一样-解决方法" class="headerlink" title="实体类中的属性名和表中的字段名不一样 解决方法"></a>实体类中的属性名和表中的字段名不一样 解决方法</h4><p>&ensp;&ensp;&ensp;&ensp;  一般有三种方法：<br>&ensp;&ensp;&ensp;&ensp;  <strong>方法一</strong>  SQL语句起别名，让字段名的别名和实体类的属性名一致。</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript"><--SQL起别名--><select id="selectOrder" parameterType="Integer" resultType="Order">        SELECT order_id AS id, order_no AS orderno, order_price AS price       FROM orders   WHERE order_id = #{id}</select><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&ensp;&ensp;&ensp;&ensp;  <strong>方法二</strong>  <code>约定大于配置</code>。大多数场景下，数据库字段名和实体类中的属性名之间的差别，主要是<strong>下划线风格</strong>与<strong>驼峰风格</strong>的差距。</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript"><settings>    <setting name="logImpl" value="LOG4J"/>       <setting name="mapUnderscoreToCamelCase" value="true" /></settings><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>&ensp;&ensp;&ensp;&ensp;  <strong>方法三</strong>  映射。将字段名和实体类属性名一一映射对应。代码如下：</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript"><!-- 定义封装account和user的resultMap --><resultMap id="accountUserMap" type="account">    <id property="id" column="aid"></id>        <!–- 用 id 属性来映射主键字段。 property 为实体类属性名，column 为数据表中的属性 -–>    <result property="uid" column="uid"></result>   <!–- 用 result 属性来映射非主键字段-–>    <result property="money" column="money"></result>    <!-- 一对一的关系映射：配置封装user的内容-->    <association property="user" column="uid" javaType="user">        <id property="id" column="id"></id>        <result column="username" property="username"></result>        <result column="address" property="address"></result>        <result column="sex" property="sex"></result>        <result column="birthday" property="birthday"></result>    </association></resultMap><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>我认为，应该尽量避免使用别名，因为没有<code>可重用性</code>，尽量考虑使用<code>约定大于配置</code>这一思想。</li></ul><h4 id="XML-映射文件中，除了常见的-select-insert-update-delete标-签之外，还有哪些标签？"><a href="#XML-映射文件中，除了常见的-select-insert-update-delete标-签之外，还有哪些标签？" class="headerlink" title="XML 映射文件中，除了常见的 select | insert | update | delete标 签之外，还有哪些标签？"></a>XML 映射文件中，除了常见的 select | insert | update | delete标 签之外，还有哪些标签？</h4><pre class="line-numbers language-JavaScript"><code class="language-JavaScript"><--mapper 相关标签-->    <cache /> 标签， 给定命名空间的缓存配置。    <cache-ref /> 标签，其他命名空间缓存配置的引用。    <resultMap /> 标签，是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。    <parameterMap /> 标签，已废弃！老式风格的参数映射。内联参数是首选,这个元素可能在将来被移除，这里不会记录。    <sql /> 标签，可被其他语句引用的可重用语句块。    <include /> 标签，引用 <sql /> 标签的语句。    <selectKey /> 标签，不支持自增的主键生成策略标签。<--动态SQL 相关标签-->    <if />    <choose />、<when />、<otherwise />    <trim />、<where />、<set />    <foreach />    <bind /><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？"><a href="#Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？" class="headerlink" title="Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？"></a>Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？</h4><ul><li>Mybatis 动态 SQL ，可以让我们在 XML 映射文件内，以 XML 标签的形式编写动态 SQL ，完成逻辑判断和动态拼接 SQL 的功能。</li><li>Mybatis 提供了 9 种动态 SQL<pre class="line-numbers language-JavaScript"><code class="language-JavaScript"><if />、<choose />、<when />、<otherwise />、<trim />、<where />、<set />、<foreach />、<bind /><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>其执行原理为，使用 <strong>OGNL</strong> 的表达式，从 SQL 参数对象中计算表达式的值，根据表达式的值动态拼接 SQL ，以此来完成动态 SQL 的功能。</li></ul><h4 id="最佳实践中，通常一个-XML-映射文件，都会写一个-Mapper（Dao）-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？"><a href="#最佳实践中，通常一个-XML-映射文件，都会写一个-Mapper（Dao）-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="最佳实践中，通常一个 XML 映射文件，都会写一个 Mapper（Dao） 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？"></a>最佳实践中，通常一个 XML 映射文件，都会写一个 Mapper（Dao） 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？</h4><p>Mapper(Dao) 接口，对应的关系如下：</p><ul><li>接口的全限名，就是映射文件中的 <code>&quot;namespace&quot;</code> 的值。</li><li>接口的方法名，就是映射文件中 MappedStatement 的 <code>&quot;id&quot;</code> 值。</li><li>接口方法内的参数，就是传递给 SQL 的参数。    </li></ul><p>Mapper(Dao) 接口是没有实现类的，当调用接口方法时，接口全限名 + 方法名拼接字符串作为 key 值，可唯一定位一个对应的 MappedStatement 。举例：<code>com.mybatis3.mappers.StudentDao.findStudentById</code> ，可以唯一找到 <code>&quot;namespace&quot;</code> 为 <code>com.mybatis3.mappers.StudentDao</code> 下面 <code>&quot;id&quot;</code> 为 <code>findStudentById</code> 的 MappedStatement 。<br>总结来说，在 Mybatis 中，每一个<code>&lt;select /&gt;、&lt;insert /&gt;、&lt;update /&gt;、&lt;delete /&gt;</code> 标签，都会被解析为一个 MappedStatement 对象。</p><p>另外，Mapper 接口的实现类，通过 MyBatis 使用 <strong>JDK Proxy</strong> 自动生成其代理对象 Proxy ，而代理对象 Proxy 会拦截接口方法，从而“调用”对应的 MappedStatement 方法，最终执行 SQL ，返回执行结果。整体流程如下图：[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://static2.iocoder.cn/images/MyBatis/2020_03_15/02.png" alt="流程](http://static2.iocoder.cn/images/MyBatis/2020_03_15/02.png)" title="">                </div>                <div class="image-caption">流程](http://static2.iocoder.cn/images/MyBatis/2020_03_15/02.png)</div>            </figure>流程</p><ul><li><p>其中，SqlSession 在调用 Executor 之前，会获得对应的 MappedStatement 方法。例如：<code>DefaultSqlSession#select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</code> 方法，代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// DefaultSqlSession.java</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">select</span><span class="token punctuation">(</span>String statement<span class="token punctuation">,</span> Object parameter<span class="token punctuation">,</span> RowBounds rowBounds<span class="token punctuation">,</span> ResultHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获得 MappedStatement 对象</span>        MappedStatement ms <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">getMappedStatement</span><span class="token punctuation">(</span>statement<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 执行查询</span>        executor<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> <span class="token function">wrapCollection</span><span class="token punctuation">(</span>parameter<span class="token punctuation">)</span><span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> ExceptionFactory<span class="token punctuation">.</span><span class="token function">wrapException</span><span class="token punctuation">(</span><span class="token string">"Error querying database.  Cause: "</span> <span class="token operator">+</span> e<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        ErrorContext<span class="token punctuation">.</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>&ensp;&ensp;&ensp;&ensp; Mapper 接口里的方法，是不能重载的，因为是<strong>全限名 + 方法名</strong>的保存和寻找策略。😈 所以有时，想个 Mapper 接口里的方法名，还是蛮闹心的，嘿嘿。</p><h4 id="Mapper-接口绑定有几种实现方式-分别是怎么实现的"><a href="#Mapper-接口绑定有几种实现方式-分别是怎么实现的" class="headerlink" title="Mapper 接口绑定有几种实现方式,分别是怎么实现的?"></a>Mapper 接口绑定有几种实现方式,分别是怎么实现的?</h4><p>&ensp;&ensp;&ensp;&ensp;接口绑定有三种实现方式：</p><p>第一种，通过 <strong>XML Mapper</strong> 里面写 SQL 来绑定。在这种情况下，要指定 XML 映射文件里面的 <code>&quot;namespace&quot;</code> 必须为接口的全路径名。</p><p>第二种，通过<strong>注解</strong>绑定，就是在接口的方法上面加上 <code>@Select</code>、<code>@Update</code>、<code>@Insert</code>、<code>@Delete</code> 注解，里面包含 SQL 语句来绑定。</p><p>第三种，是第二种的特例，也是通过<strong>注解</strong>绑定，在接口的方法上面加上 <code>@SelectProvider</code>、<code>@UpdateProvider</code>、<code>@InsertProvider</code>、<code>@DeleteProvider</code> 注解，通过 Java 代码，生成对应的动态 SQL 。</p><p>&ensp;&ensp;&ensp;&ensp;实际场景下，最最最推荐的是<strong>第一种</strong>方式。因为，SQL 通过注解写在 Java 代码中，会非常杂乱。而写在 XML 中，更加有整体性，并且可以更加方便的使用 OGNL 表达式。</p><h4 id="Mybatis-的-XML-Mapper文件中，不同的-XML-映射文件，id-是否可以重复？"><a href="#Mybatis-的-XML-Mapper文件中，不同的-XML-映射文件，id-是否可以重复？" class="headerlink" title="Mybatis 的 XML Mapper文件中，不同的 XML 映射文件，id 是否可以重复？"></a>Mybatis 的 XML Mapper文件中，不同的 XML 映射文件，id 是否可以重复？</h4><p>&ensp;&ensp;&ensp;&ensp;不同的 XML Mapper 文件，如果配置了 <code>&quot;namespace&quot;</code> ，那么 id 可以重复；如果没有配置 <code>&quot;namespace&quot;</code> ，那么 id 不能重复。毕竟<code>&quot;namespace&quot;</code> 不是必须的，只是最佳实践而已。<br>&ensp;&ensp;&ensp;&ensp;原因就是，<code>namespace + id</code> 是作为 <code>Map</code> 的 key 使用的(VALUE 是SQL语句+参数类型)。如果没有 <code>&quot;namespace&quot;</code>，就剩下 id ，那么 id 重复会导致数据互相覆盖。如果有了 <code>&quot;namespace&quot;</code>，自然 id 就可以重复，<code>&quot;namespace&quot;</code>不同，<code>namespace + id</code> 自然也就不同。</p><h4 id="如何获取自动生成的-主-键值"><a href="#如何获取自动生成的-主-键值" class="headerlink" title="如何获取自动生成的(主)键值?"></a>如何获取自动生成的(主)键值?</h4><p>不同的数据库，获取自动生成的(主)键值的方式是不同的。</p><p>MySQL 有两种方式，但是<strong>自增主键</strong>，代码如下：</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">// 方式一，使用 useGeneratedKeys + keyProperty 属性<insert id="insert" parameterType="Person" useGeneratedKeys="true" keyProperty="id">    INSERT INTO person(name, pswd)    VALUE (#{name}, #{pswd})</insert>// 方式二，使用 `<selectKey />` 标签<insert id="insert" parameterType="Person" useGeneratedKeys="true" keyProperty="id">    <selectKey keyProperty="id" resultType="long" order="AFTER">        SELECT LAST_INSERT_ID()    </selectKey>    INSERT INTO person(name, pswd)    VALUE (#{name}, #{pswd})</insert><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>其中，<strong>方式一</strong> 较为常用。</li></ul><h4 id="Mybatis-执行批量插入，能返回数据库主键列表吗？"><a href="#Mybatis-执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="Mybatis 执行批量插入，能返回数据库主键列表吗？"></a>Mybatis 执行批量插入，能返回数据库主键列表吗？</h4><p>能，JDBC 都能做，Mybatis 当然也能做。</p><h4 id="在-Mapper-中如何传递多个参数"><a href="#在-Mapper-中如何传递多个参数" class="headerlink" title="在 Mapper 中如何传递多个参数?"></a>在 Mapper 中如何传递多个参数?</h4><p>第一种，使用 Map 集合(也可以封装为一个Domain对象)，装载多个参数进行传递。代码如下：</p><pre class="line-numbers language-Java"><code class="language-Java">// 调用方法Map<String, Object> map = new HashMap();map.put("start", start);map.put("end", end);return studentMapper.selectStudents(map);// Mapper 接口List<Student> selectStudents(Map<String, Object> map);// Mapper XML 代码<select id="selectStudents" parameterType="Map" resultType="Student">    SELECT *    FROM students    LIMIT #{start}, #{end}</select><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>显然，这不是一种优雅的方式。</li></ul><p>第二种，保持传递多个参数，使用 <code>@Param</code> 注解。代码如下：</p><pre class="line-numbers language-Java"><code class="language-Java">// 调用方法return studentMapper.selectStudents(0, 10);// Mapper 接口List<Student> selectStudents(@Param("start") Integer start, @Param("end") Integer end);// Mapper XML 代码<select id="selectStudents" resultType="Student">    SELECT *    FROM students    LIMIT #{start}, #{end}</select><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>推荐使用第二种方式。</li></ul><p>第三种，保持传递多个参数，不使用 <code>@Param</code> 注解。代码如下：</p><pre class="line-numbers language-Java"><code class="language-Java">// 调用方法return studentMapper.selectStudents(0, 10);// Mapper 接口List<Student> selectStudents(Integer start, Integer end);// Mapper XML 代码<select id="selectStudents" resultType="Student">    SELECT *    FROM students    LIMIT #{param1}, #{param2}</select><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>其中，按照参数在方法方法中的位置，从 1 开始，逐个为 <code>#{param1}</code>、<code>#{param2}</code>、<code>#{param3}</code> 不断向下。</li></ul><h4 id="Mybatis-是否可以映射-Enum-枚举类？"><a href="#Mybatis-是否可以映射-Enum-枚举类？" class="headerlink" title="Mybatis 是否可以映射 Enum 枚举类？"></a>Mybatis 是否可以映射 Enum 枚举类？</h4><p>Mybatis 可以映射枚举类，对应的实现类为 EnumTypeHandler 或 EnumOrdinalTypeHandler 。</p><ul><li>EnumTypeHandler ，基于 <code>Enum.name</code> 属性( String )。<strong>默认</strong>。</li><li>EnumOrdinalTypeHandler ，基于 <code>Enum.ordinal</code> 属性( <code>int</code> )。可通过 <code>&lt;setting name=&quot;defaultEnumTypeHandler&quot; value=&quot;EnumOrdinalTypeHandler&quot; /&gt;</code> 来设置。</li></ul><p>😈 当然，实际开发场景，我们很少使用 Enum 类型，更加的方式是，代码如下：</p><pre class="line-numbers language-Java"><code class="language-Java">public class Dog {    public static final int STATUS_GOOD = 1;    public static final int STATUS_BETTER = 2;    public static final int STATUS_BEST = 3；    private int status;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>并且，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一列上。映射方式为自定义一个 TypeHandler 类，实现 TypeHandler 的<code>#setParameter(...)</code> 和 <code>#getResult(...)</code> 接口方法。</p><p>TypeHandler 有两个作用：</p><ul><li>一是，完成从 javaType 至 jdbcType 的转换。</li><li>二是，完成 jdbcType 至 javaType 的转换。</li></ul><p>具体体现为 <code>#setParameter(...)</code> 和 <code>#getResult(..)</code> 两个方法，分别代表设置 SQL 问号占位符参数和获取列查询结果。</p><h4 id="Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h4><p>Mybatis 有四种 Executor 执行器，分别是 SimpleExecutor、ReuseExecutor、BatchExecutor、CachingExecutor 。</p><ul><li>SimpleExecutor ：每执行一次 update 或 select 操作，就创建一个 Statement 对象，用完立刻关闭 Statement 对象。</li><li>ReuseExecutor ：执行 update 或 select 操作，以 SQL 作为key 查找<strong>缓存</strong>的 Statement 对象，存在就使用，不存在就创建；用完后，不关闭 Statement 对象，而是放置于缓存 <code>Map</code> 内，供下一次使用。简言之，就是重复使用 Statement 对象。</li><li>BatchExecutor ：执行 update 操作（没有 select 操作，因为 JDBC 批处理不支持 select 操作），将所有 SQL 都添加到批处理中（通过 addBatch 方法），等待统一执行（使用 executeBatch 方法）。它缓存了多个 Statement 对象，每个 Statement 对象都是调用 addBatch 方法完毕后，等待一次执行 executeBatch 批处理。<strong>实际上，整个过程与 JDBC 批处理是相同</strong>。</li><li>CachingExecutor ：在上述的三个执行器之上，增加<strong>二级缓存</strong>的功能。</li></ul><p>通过设置 <code>&lt;setting name=&quot;defaultExecutorType&quot; value=&quot;&quot;&gt;</code> 的 <code>&quot;value&quot;</code> 属性，可传入 SIMPLE、REUSE、BATCH 三个值，分别使用 SimpleExecutor、ReuseExecutor、BatchExecutor 执行器。<br>通过设置 <code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;&quot;</code> 的 <code>&quot;value&quot;</code> 属性为 <code>true</code> 时，创建 CachingExecutor 执行器。   </p><h4 id="MyBatis-如何执行批量插入"><a href="#MyBatis-如何执行批量插入" class="headerlink" title="MyBatis 如何执行批量插入?"></a>MyBatis 如何执行批量插入?</h4><p>首先，在 Mapper XML 编写一个简单的 Insert 语句。代码如下：</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript"><insert id="insertUser" parameterType="String">    INSERT INTO users(name)    VALUES (#{value})</insert><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后，然后在对应的 Mapper 接口中，编写映射的方法。代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">insertUser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span> String name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，调用该 Mapper 接口方法。代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> SqlSessionFactory sqlSessionFactory<span class="token punctuation">;</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建要插入的用户的名字的数组</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> names <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"name1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"name2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"name3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"name4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获得执行器类型为 Batch 的 SqlSession 对象，并且 autoCommit = false ，禁止事务自动交</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>SqlSession session <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span>ExecutorType<span class="token punctuation">.</span>BATCH<span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获得 Mapper 对象</span>        UserMapper mapper <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>UserMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 循环插入</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String name <span class="token operator">:</span> names<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mapper<span class="token punctuation">.</span><span class="token function">insertUser</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 提交批量操作</span>        session<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，还有另一种方式，代码如下：  </p><pre class="line-numbers language-javascript"><code class="language-javascript">INSERT INTO <span class="token punctuation">[</span>表名<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">[</span>列名<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>列名<span class="token punctuation">]</span><span class="token punctuation">)</span>VALUES<span class="token punctuation">(</span><span class="token punctuation">[</span>列值<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>列值<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">[</span>列值<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>列值<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">[</span>列值<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>列值<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于这种方式，需要保证单条 SQL 不超过语句的最大限制 <code>max_allowed_packet</code> 大小，默认为 1 M 。</li></ul><h4 id="介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？"><a href="#介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？" class="headerlink" title="介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？"></a>介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？</h4><p>内容有些长，直接参见 <a href="https://tech.meituan.com/mybatis_cache.html" target="_blank" rel="noopener">《聊聊 MyBatis 缓存机制》</a> 一文。</p><hr><p>这块的源码解析，可见 <a href="http://svip.iocoder.cn/MyBatis/cache-package" target="_blank" rel="noopener">《精尽 MyBatis 源码分析 —— 缓存模块》</a> 。</p><h4 id="什么是延迟加载？-Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#什么是延迟加载？-Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="什么是延迟加载？ Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>什么是延迟加载？ Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h4><p>在一对多中，当我们有一个用户，它有100个账户。那么  </p><ol><li>在查询用户的时候，要不要把关联的账户查出来？  </li><li>在查询账户的时候，要不要把关联的用户查出来？    </li></ol><p>在实际中：</p><ol><li>在查询用户时，用户下的账户信息应该是，什么时候使用，什么时候查询的。  </li><li>在查询账户时，账户的所属用户信息应该是随着账户查询时一起查询出来。     </li></ol><p>什么是延迟加载：<br>    在真正使用数据时才发起查询，不用的时候不查询。按需加载（懒加载）<br>什么是立即加载：<br>    不管用不用，只要一调用方法，马上发起查询。<br>在对应的四种表关系中：<code>一对多</code>，<code>多对一</code>，<code>一对一</code>，<code>多对多</code><br>    <code>一对多</code>，<code>多对多</code>：通常情况下我们都是采用延迟加载。<br>    <code>多对一</code>，<code>一对一</code>：通常情况下我们都是采用立即加载。<br>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载。其中，association 指的就是<strong>一对一</strong>，collection 指的就是<strong>一对多查询</strong>。</p><p>在 Mybatis 配置文件中，可以配置 <code>&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot; /&gt;</code> 来启用延迟加载的功能。默认情况下，延迟加载的功能是<strong>关闭</strong>的。<br>它的原理是，使用 CGLIB 或 Javassist( 默认 ) 创建目标对象的代理对象。当调用代理对象的延迟加载属性的 getter 方法时，进入拦截器方法。比如调用 <code>a.getB().getName()</code> 方法，进入拦截器的 <code>invoke(...)</code> 方法，发现 <code>a.getB()</code>需要延迟加载时，那么就会单独发送事先保存好的查询关联 B 对象的 SQL ，把 B 查询上来，然后调用<code>a.setB(b)</code> 方法，于是 <code>a</code> 对象 <code>b</code> 属性就有值了，接着完成<code>a.getB().getName()</code> 方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是 Mybatis，几乎所有的包括 Hibernate 在内，支持延迟加载的原理都是一样的。</p><h4 id="Mybatis-能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"><a href="#Mybatis-能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。" class="headerlink" title="Mybatis 能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"></a>Mybatis 能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。</h4><p>能，Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询。</p><blockquote><p>艿艿：不过貌似，我自己实际开发中，还是比较喜欢自己去查询和拼接映射的数据。😈</p></blockquote><ul><li>多对一查询，其实就是一对一查询，只需要把 <code>selectOne(...)</code> 修改为 <code>selectList(...)</code> 即可。案例可见 <a href="https://blog.csdn.net/xzm_rainbow/article/details/15336959" target="_blank" rel="noopener">《MyBatis：多对一表关系详解》</a> 。</li><li>多对多查询，其实就是一对多查询，只需要把 <code>#selectOne(...)</code> 修改为 <code>selectList(...)</code> 即可。案例可见 <a href="https://blog.csdn.net/eson_15/article/details/51655188" target="_blank" rel="noopener">《【MyBatis学习10】高级映射之多对多查询》</a> 。</li></ul><hr><p>关联对象查询，有两种实现方式：</p><blockquote><p>艿艿：所有的技术方案，即会有好处，又会有坏处。很难出现，一个完美的银弹方案。</p></blockquote><ul><li>一种是单独发送一个 SQL 去查询关联对象，赋给主对象，然后返回主对象。好处是多条 SQL 分开，相对简单，坏处是发起的 SQL 可能会比较多。</li><li>另一种是使用嵌套查询，嵌套查询的含义为使用 <code>join</code> 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值。好处是只发一个 SQL 查询，就可以把主对象和其关联对象查出来，坏处是 SQL 可能比较复杂。</li></ul><p>那么问题来了，<code>join</code> 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个呢？其去重复的原理是 <code>标签内的</code> 子标签，指定了唯一确定一条记录的 <code>id</code> 列。Mybatis 会根据<code>列值来完成 100 条记录的去重复功能，</code> 可以有多个，代表了联合主键的语意。</p><p>同样主对象的关联对象，也是根据这个原理去重复的。尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。例如：下面 <code>join</code> 查询出来6条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列。Mybatis 去重复处理后，结果为 1 个老师和 6 个学生，而不是 6 个老师和 6 个学生。</p><table><thead><tr><th style="text-align:left">t_id</th><th style="text-align:left">t_name</th><th style="text-align:left">s_id</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">teacher</td><td style="text-align:left">38</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">teacher</td><td style="text-align:left">39</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">teacher</td><td style="text-align:left">40</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">teacher</td><td style="text-align:left">41</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">teacher</td><td style="text-align:left">42</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">teacher</td><td style="text-align:left">43</td></tr></tbody></table><h4 id="简述-Mybatis-的插件运行原理？以及如何编写一个插件？"><a href="#简述-Mybatis-的插件运行原理？以及如何编写一个插件？" class="headerlink" title="简述 Mybatis 的插件运行原理？以及如何编写一个插件？"></a>简述 Mybatis 的插件运行原理？以及如何编写一个插件？</h4><p>Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件。</p><p>Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 <code>#invoke(...)</code>方法。当然，只会拦截那些你指定需要拦截的方法。</p><p>编写一个 MyBatis 插件的步骤如下：</p><ol><li>首先，实现 Mybatis 的 Interceptor 接口，并实现 <code>#intercept(...)</code> 方法。</li><li>然后，在给插件编写注解，指定要拦截哪一个接口的哪些方法即可</li><li>最后，在配置文件中配置你编写的插件。</li></ol><p>具体的，可以参考 <a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins" target="_blank" rel="noopener">《MyBatis 官方文档 —— 插件》</a> 。</p><h4 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h4><p>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的<strong>内存分页</strong>，而非<strong>数据库分页</strong>。</p><p>所以，实际场景下，不适合直接使用 MyBatis 原有的 RowBounds 对象进行分页。而是使用如下两种方案：</p><ul><li>在 SQL 内直接书写带有数据库分页的参数来完成数据库分页功能</li><li>也可以使用分页插件来完成数据库分页。</li></ul><p>这两者都是基于数据库分页，差别在于前者是工程师<strong>手动</strong>编写分页条件，后者是插件<strong>自动</strong>添加分页条件。</p><p>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义分页插件。在插件的拦截方法内，拦截待执行的 SQL ，然后重写 SQL ，根据dialect 方言，添加对应的物理分页语句和物理分页参数。</p><p>举例：<code>SELECT * FROM student</code> ，拦截 SQL 后重写为：<code>select * FROM student LIMI 0，10</code> 。</p><p>目前市面上目前使用比较广泛的 MyBatis 分页插件有：</p><ul><li><a href="https://github.com/pagehelper/Mybatis-PageHelper" target="_blank" rel="noopener">Mybatis-PageHelper</a></li><li><a href="https://github.com/baomidou/mybatis-plus" target="_blank" rel="noopener">MyBatis-Plus</a></li></ul><p>从现在看来，<a href="https://github.com/baomidou/mybatis-plus" target="_blank" rel="noopener">MyBatis-Plus</a> 逐步使用的更加广泛。</p><h4 id="MyBatis-与-Hibernate-有哪些不同？"><a href="#MyBatis-与-Hibernate-有哪些不同？" class="headerlink" title="MyBatis 与 Hibernate 有哪些不同？"></a>MyBatis 与 Hibernate 有哪些不同？</h4><p>Mybatis 和 Hibernate 不同，它<strong>不完全是</strong>一个 ORM 框架，因为MyBatis 需要程序员自己编写 SQL 语句。不过 MyBatis 可以通过 XML 或注解方式灵活配置要运行的 SQL 语句，并将 Java 对象和 SQL 语句映射生成最终执行的 SQL ，最后将 SQL 执行的结果再映射生成 Java 对象。</p><p>Mybatis 学习门槛低，简单易学，程序员直接编写原生态 SQL ，可严格控制 SQL 执行性能，灵活度高。但是灵活的前提是 MyBatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套 SQL 映射文件，工作量大。</p><p>Hibernate 对象/关系映射能力强，数据库无关性好。如果用 Hibernate 开发可以节省很多代码，提高效率。但是 Hibernate 的缺点是学习门槛高，要精通门槛更高，而且怎么设计 O/R 映射，在性能和对象模型之间如何权衡，以及怎样用好 Hibernate 需要具有很强的经验和能力才行。</p><p>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。简单总结如下：</p><ul><li>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取。</li><li>Mybatis 属于半自动 ORM 映射工具，在查询关联对象或关联集合对象时，需要手动编写 SQL 来完成。</li></ul><p>另外，在 <a href="https://www.jianshu.com/p/96171e647885" target="_blank" rel="noopener">《浅析 Mybatis 与 Hibernate 的区别与用途》</a> 文章，也是写的非常不错的。</p><p>当然，实际上，MyBatis 也可以搭配自动生成代码的工具，提升开发效率，还可以使用 <a href="http://mp.baomidou.com/" target="_blank" rel="noopener">MyBatis-Plus</a> 框架，已经内置常用的 SQL 操作，也是非常不错的。</p><h4 id="JDBC-编程有哪些不足之处（问题），MyBatis是如何解决这些问题的？"><a href="#JDBC-编程有哪些不足之处（问题），MyBatis是如何解决这些问题的？" class="headerlink" title="JDBC 编程有哪些不足之处（问题），MyBatis是如何解决这些问题的？"></a>JDBC 编程有哪些不足之处（问题），MyBatis是如何解决这些问题的？</h4><p>问题一：SQL 语句写在代码中造成代码不易维护，且代码会比较混乱。</p><p>解决方式：将 SQL 语句配置在 Mapper XML 文件中，与 Java 代码分离。</p><p>问题二：根据参数不同，拼接不同的 SQL 语句非常麻烦。例如 SQL 语句的 WHERE 条件不一定，可能多也可能少，占位符需要和参数一一对应。</p><p>解决方式：MyBatis 提供 <code>&lt;where /&gt;</code>、<code>&lt;if /&gt;</code> 等等动态语句所需要的标签，并支持 OGNL 表达式，简化了动态 SQL 拼接的代码，提升了开发效率。</p><hr><p>问题三，对结果集解析麻烦，SQL 变化可能导致解析代码变化，且解析前需要遍历。</p><p>解决方式：Mybatis 自动将 SQL 执行结果映射成 Java 对象。</p><hr><p>问题四，数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</p><p>解决方式：在 <code>mybatis-config.xml</code> 中，配置数据链接池，使用连接池管理数据库链接。</p><p>当然，即使不使用 MyBatis ，也可以使用数据库连接池。<br>另外，MyBatis 默认提供了数据库连接池的实现，只是说，因为其它开源的数据库连接池性能更好，所以一般很少使用 MyBatis 自带的连接池实现。</p><h4 id="Mybatis-比-IBatis-比较大的几个改进是什么？"><a href="#Mybatis-比-IBatis-比较大的几个改进是什么？" class="headerlink" title="Mybatis 比 IBatis 比较大的几个改进是什么？"></a>Mybatis 比 IBatis 比较大的几个改进是什么？</h4><blockquote><p>这是一个选择性了解的问题，因为可能现在很多面试官，都没用过 IBatis 框架。</p></blockquote><ol><li>有接口绑定，包括注解绑定 SQL 和 XML 绑定 SQL 。</li><li>动态 SQL 由原来的节点配置变成 OGNL 表达式。</li><li>在一对一或一对多的时候，引进了 <code>association</code> ，在一对多的时候，引入了 <code>collection</code>节点，不过都是在 <code></code> 里面配置。</li></ol><h4 id="Mybatis-映射文件中，如果-A-标签通过-include-引用了B标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在A标签的前面？"><a href="#Mybatis-映射文件中，如果-A-标签通过-include-引用了B标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="Mybatis 映射文件中，如果 A 标签通过 include 引用了B标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在A标签的前面？"></a>Mybatis 映射文件中，如果 A 标签通过 include 引用了B标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在A标签的前面？</h4><p>虽然 Mybatis 解析 XML 映射文件是<strong>按照顺序</strong>解析的。但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。<strong>也就是说，无需按照顺序，进行定义</strong>。</p><p>原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为<strong>未解析状态</strong>。然后，继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析A标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p><h4 id="简述-Mybatis-的-XML-映射文件和-Mybatis-内部数据结构之间的映射关系？"><a href="#简述-Mybatis-的-XML-映射文件和-Mybatis-内部数据结构之间的映射关系？" class="headerlink" title="简述 Mybatis 的 XML 映射文件和 Mybatis 内部数据结构之间的映射关系？"></a>简述 Mybatis 的 XML 映射文件和 Mybatis 内部数据结构之间的映射关系？</h4><p>Mybatis 将所有 XML 配置信息都封装到 All-In-One 重量级对象Configuration内部。</p><p>在 XML Mapper 文件中：</p><ul><li><code>&lt;parameterMap&gt;</code> 标签，会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。</li><li><code>&lt;resultMap&gt;</code> 标签，会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。</li><li>每一个 <code>select</code>、<code>update</code>、<code>delete</code>、<code>insert</code> 标签，均会被解析为一个 MappedStatement 对象，标签内的 SQL 会被解析为一个 BoundSql 对象。   </li></ul><h4 id="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h4><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。<br>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p>]]></content>
      
      
      <categories>
          
          <category> java web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis使用总结</title>
      <link href="/2019/12/09/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/mybatis/"/>
      <url>/2019/12/09/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/mybatis/</url>
      
        <content type="html"><![CDATA[<h4 id="1-MyBatis-编程步骤"><a href="#1-MyBatis-编程步骤" class="headerlink" title="1. MyBatis 编程步骤"></a>1. MyBatis 编程步骤</h4><ol><li>创建 SqlSessionFactory 对象。构建者模式</li><li>通过 SqlSessionFactory 获取 SqlSession 对象。工厂模式</li><li>通过 SqlSession 获得 Mapper 代理对象。代理模式</li><li>通过 Mapper 代理对象，执行数据库操作。</li><li>执行成功，则使用 SqlSession 提交事务。</li><li>执行失败，则使用 SqlSession 回滚事务。</li><li>最终，关闭会话。<pre class="line-numbers language-java"><code class="language-java"> <span class="token comment" spellcheck="true">//1.读取配置文件</span> InputStream in <span class="token operator">=</span> Resources<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"SqlMapConfig.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//2.创建SqlSessionFactory工厂</span> SqlSessionFactoryBuilder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> SqlSessionFactory factory <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//3.使用工厂创建dao对象</span> IUserDao userDao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserDaoImpl</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//4.使用代理对象执行方法</span> List<span class="token operator">&lt;</span>User<span class="token operator">></span> users <span class="token operator">=</span> userDao<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span>User user <span class="token operator">:</span> users<span class="token punctuation">)</span><span class="token punctuation">{</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//5.手动提交事务、释放资源</span> session<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{} 和 ${} 的区别"></a><code>#{}</code> 和 <code>${}</code> 的区别</h4><p>&ensp;&ensp;&ensp;&ensp;  <code>${}</code> 是 Properties 文件中的变量占位符，它可以用于 XML 标签属性值和 SQL 内部，属于<strong>字符串替换</strong>。例如将 <code>${driver}</code> 会被静态替换为 <code>com.mysql.jdbc.Driver</code> ：  </p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">--</span>用于xml标签，进行属性值（字符串）替换<span class="token operator">--</span><span class="token operator">></span>  <span class="token operator">&lt;</span>dataSource type<span class="token operator">=</span><span class="token string">"UNPOOLED"</span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">--</span>未使用连接池<span class="token operator">--</span><span class="token operator">></span>     <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"driver"</span> value<span class="token operator">=</span><span class="token string">"${driver}"</span><span class="token operator">/</span><span class="token operator">></span>         <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"url"</span> value<span class="token operator">=</span><span class="token string">"${url}"</span><span class="token operator">/</span><span class="token operator">></span>       <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"username"</span> value<span class="token operator">=</span><span class="token string">"${username}"</span><span class="token operator">/</span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>dataSource<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">--</span>用于SQL拼接 ，直接字符串拼接<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">"getSubject"</span> parameterType<span class="token operator">=</span><span class="token string">"Integer"</span> resultType<span class="token operator">=</span><span class="token string">"Subject"</span><span class="token operator">></span>      SELECT <span class="token operator">*</span> FROM subject  WHERE id <span class="token operator">=</span> $<span class="token punctuation">{</span>id<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">></span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>实际场景不应该使用 <code>${id}</code> ,因为直接拼接字符串可能有 SQL 注入的风险。  </li></ul><p>&ensp;&ensp;&ensp;&ensp;  <code>#{}</code> 是 SQL 的<code>参数占位符</code>，Mybatis 会将 SQL语句中的 <code>#{}</code> 替换为 <code>?</code> 号，在 SQL 执行前会使用 PreparedStatement 的参数设置方法，按序给 SQL 的 <code>?</code> 号占位符设置参数值，比如 <code>ps.setInt(0, parameterValue)</code> 。 所以，<code>#{}</code>是 <strong>预编译处理</strong> ，可以有效防止 SQL 注入，提高系统安全性。<br>&ensp;&ensp;&ensp;&ensp;  另外，由于mybatis采用了OGNL表达式的标准，可直接以<code>.</code>的形式进行属性的取值，<code>#{}</code> 和 <code>${}</code> 的取值方式非常方便。例如：<code>#{item.name}</code> 的取值方式，使用反射从参数对象中，获取 <code>item</code> 对象的 <code>name</code> 属性值，相当于 <code>param.getItem().getName()</code> 代替了<code>bject.getName()</code>。</p><h4 id="实体类中的属性名和表中的字段名不一样-解决方法"><a href="#实体类中的属性名和表中的字段名不一样-解决方法" class="headerlink" title="实体类中的属性名和表中的字段名不一样 解决方法"></a>实体类中的属性名和表中的字段名不一样 解决方法</h4><p>&ensp;&ensp;&ensp;&ensp;  一般有三种方法：<br>&ensp;&ensp;&ensp;&ensp;  <strong>方法一</strong>  SQL语句起别名，让字段名的别名和实体类的属性名一致。</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript"><--SQL起别名--><select id="selectOrder" parameterType="Integer" resultType="Order">        SELECT order_id AS id, order_no AS orderno, order_price AS price       FROM orders   WHERE order_id = #{id}</select><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&ensp;&ensp;&ensp;&ensp;  <strong>方法二</strong>  <code>约定大于配置</code>。大多数场景下，数据库字段名和实体类中的属性名之间的差别，主要是<strong>下划线风格</strong>与<strong>驼峰风格</strong>的差距。</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript"><settings>    <setting name="logImpl" value="LOG4J"/>       <setting name="mapUnderscoreToCamelCase" value="true" /></settings><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>&ensp;&ensp;&ensp;&ensp;  <strong>方法三</strong>  映射。将字段名和实体类属性名一一映射对应。代码如下：</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript"><!-- 定义封装account和user的resultMap --><resultMap id="accountUserMap" type="account">    <id property="id" column="aid"></id>        <!–- 用 id 属性来映射主键字段。 property 为实体类属性名，column 为数据表中的属性 -–>    <result property="uid" column="uid"></result>   <!–- 用 result 属性来映射非主键字段-–>    <result property="money" column="money"></result>    <!-- 一对一的关系映射：配置封装user的内容-->    <association property="user" column="uid" javaType="user">        <id property="id" column="id"></id>        <result column="username" property="username"></result>        <result column="address" property="address"></result>        <result column="sex" property="sex"></result>        <result column="birthday" property="birthday"></result>    </association></resultMap><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>我认为，应该尽量避免使用别名，因为没有<code>可重用性</code>，尽量考虑使用<code>约定大于配置</code>这一思想。</li></ul><h4 id="XML-映射文件中，除了常见的-select-insert-update-delete标-签之外，还有哪些标签？"><a href="#XML-映射文件中，除了常见的-select-insert-update-delete标-签之外，还有哪些标签？" class="headerlink" title="XML 映射文件中，除了常见的 select | insert | update | delete标 签之外，还有哪些标签？"></a>XML 映射文件中，除了常见的 select | insert | update | delete标 签之外，还有哪些标签？</h4><pre class="line-numbers language-JavaScript"><code class="language-JavaScript"><--mapper 相关标签-->    <cache /> 标签， 给定命名空间的缓存配置。    <cache-ref /> 标签，其他命名空间缓存配置的引用。    <resultMap /> 标签，是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。    <parameterMap /> 标签，已废弃！老式风格的参数映射。内联参数是首选,这个元素可能在将来被移除，这里不会记录。    <sql /> 标签，可被其他语句引用的可重用语句块。    <include /> 标签，引用 <sql /> 标签的语句。    <selectKey /> 标签，不支持自增的主键生成策略标签。<--动态SQL 相关标签-->    <if />    <choose />、<when />、<otherwise />    <trim />、<where />、<set />    <foreach />    <bind /><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？"><a href="#Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？" class="headerlink" title="Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？"></a>Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？</h4><ul><li>Mybatis 动态 SQL ，可以让我们在 XML 映射文件内，以 XML 标签的形式编写动态 SQL ，完成逻辑判断和动态拼接 SQL 的功能。</li><li>Mybatis 提供了 9 种动态 SQL<pre class="line-numbers language-JavaScript"><code class="language-JavaScript"><if />、<choose />、<when />、<otherwise />、<trim />、<where />、<set />、<foreach />、<bind /><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>其执行原理为，使用 <strong>OGNL</strong> 的表达式，从 SQL 参数对象中计算表达式的值，根据表达式的值动态拼接 SQL ，以此来完成动态 SQL 的功能。</li></ul><h4 id="最佳实践中，通常一个-XML-映射文件，都会写一个-Mapper（Dao）-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？"><a href="#最佳实践中，通常一个-XML-映射文件，都会写一个-Mapper（Dao）-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="最佳实践中，通常一个 XML 映射文件，都会写一个 Mapper（Dao） 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？"></a>最佳实践中，通常一个 XML 映射文件，都会写一个 Mapper（Dao） 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？</h4><p>Mapper(Dao) 接口，对应的关系如下：</p><ul><li>接口的全限名，就是映射文件中的 <code>&quot;namespace&quot;</code> 的值。</li><li>接口的方法名，就是映射文件中 MappedStatement 的 <code>&quot;id&quot;</code> 值。</li><li>接口方法内的参数，就是传递给 SQL 的参数。    </li></ul><p>Mapper(Dao) 接口是没有实现类的，当调用接口方法时，接口全限名 + 方法名拼接字符串作为 key 值，可唯一定位一个对应的 MappedStatement 。举例：<code>com.mybatis3.mappers.StudentDao.findStudentById</code> ，可以唯一找到 <code>&quot;namespace&quot;</code> 为 <code>com.mybatis3.mappers.StudentDao</code> 下面 <code>&quot;id&quot;</code> 为 <code>findStudentById</code> 的 MappedStatement 。<br>总结来说，在 Mybatis 中，每一个<code>&lt;select /&gt;、&lt;insert /&gt;、&lt;update /&gt;、&lt;delete /&gt;</code> 标签，都会被解析为一个 MappedStatement 对象。</p><p>另外，Mapper 接口的实现类，通过 MyBatis 使用 <strong>JDK Proxy</strong> 自动生成其代理对象 Proxy ，而代理对象 Proxy 会拦截接口方法，从而“调用”对应的 MappedStatement 方法，最终执行 SQL ，返回执行结果。整体流程如下图：[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://static2.iocoder.cn/images/MyBatis/2020_03_15/02.png" alt="流程](http://static2.iocoder.cn/images/MyBatis/2020_03_15/02.png)" title="">                </div>                <div class="image-caption">流程](http://static2.iocoder.cn/images/MyBatis/2020_03_15/02.png)</div>            </figure>流程</p><ul><li><p>其中，SqlSession 在调用 Executor 之前，会获得对应的 MappedStatement 方法。例如：<code>DefaultSqlSession#select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</code> 方法，代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// DefaultSqlSession.java</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">select</span><span class="token punctuation">(</span>String statement<span class="token punctuation">,</span> Object parameter<span class="token punctuation">,</span> RowBounds rowBounds<span class="token punctuation">,</span> ResultHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获得 MappedStatement 对象</span>        MappedStatement ms <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">getMappedStatement</span><span class="token punctuation">(</span>statement<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 执行查询</span>        executor<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> <span class="token function">wrapCollection</span><span class="token punctuation">(</span>parameter<span class="token punctuation">)</span><span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> ExceptionFactory<span class="token punctuation">.</span><span class="token function">wrapException</span><span class="token punctuation">(</span><span class="token string">"Error querying database.  Cause: "</span> <span class="token operator">+</span> e<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        ErrorContext<span class="token punctuation">.</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>&ensp;&ensp;&ensp;&ensp; Mapper 接口里的方法，是不能重载的，因为是<strong>全限名 + 方法名</strong>的保存和寻找策略。😈 所以有时，想个 Mapper 接口里的方法名，还是蛮闹心的，嘿嘿。</p><h4 id="Mapper-接口绑定有几种实现方式-分别是怎么实现的"><a href="#Mapper-接口绑定有几种实现方式-分别是怎么实现的" class="headerlink" title="Mapper 接口绑定有几种实现方式,分别是怎么实现的?"></a>Mapper 接口绑定有几种实现方式,分别是怎么实现的?</h4><p>&ensp;&ensp;&ensp;&ensp;接口绑定有三种实现方式：</p><p>第一种，通过 <strong>XML Mapper</strong> 里面写 SQL 来绑定。在这种情况下，要指定 XML 映射文件里面的 <code>&quot;namespace&quot;</code> 必须为接口的全路径名。</p><p>第二种，通过<strong>注解</strong>绑定，就是在接口的方法上面加上 <code>@Select</code>、<code>@Update</code>、<code>@Insert</code>、<code>@Delete</code> 注解，里面包含 SQL 语句来绑定。</p><p>第三种，是第二种的特例，也是通过<strong>注解</strong>绑定，在接口的方法上面加上 <code>@SelectProvider</code>、<code>@UpdateProvider</code>、<code>@InsertProvider</code>、<code>@DeleteProvider</code> 注解，通过 Java 代码，生成对应的动态 SQL 。</p><p>&ensp;&ensp;&ensp;&ensp;实际场景下，最最最推荐的是<strong>第一种</strong>方式。因为，SQL 通过注解写在 Java 代码中，会非常杂乱。而写在 XML 中，更加有整体性，并且可以更加方便的使用 OGNL 表达式。</p><h4 id="Mybatis-的-XML-Mapper文件中，不同的-XML-映射文件，id-是否可以重复？"><a href="#Mybatis-的-XML-Mapper文件中，不同的-XML-映射文件，id-是否可以重复？" class="headerlink" title="Mybatis 的 XML Mapper文件中，不同的 XML 映射文件，id 是否可以重复？"></a>Mybatis 的 XML Mapper文件中，不同的 XML 映射文件，id 是否可以重复？</h4><p>&ensp;&ensp;&ensp;&ensp;不同的 XML Mapper 文件，如果配置了 <code>&quot;namespace&quot;</code> ，那么 id 可以重复；如果没有配置 <code>&quot;namespace&quot;</code> ，那么 id 不能重复。毕竟<code>&quot;namespace&quot;</code> 不是必须的，只是最佳实践而已。<br>&ensp;&ensp;&ensp;&ensp;原因就是，<code>namespace + id</code> 是作为 <code>Map</code> 的 key 使用的(VALUE 是SQL语句+参数类型)。如果没有 <code>&quot;namespace&quot;</code>，就剩下 id ，那么 id 重复会导致数据互相覆盖。如果有了 <code>&quot;namespace&quot;</code>，自然 id 就可以重复，<code>&quot;namespace&quot;</code>不同，<code>namespace + id</code> 自然也就不同。</p><h4 id="如何获取自动生成的-主-键值"><a href="#如何获取自动生成的-主-键值" class="headerlink" title="如何获取自动生成的(主)键值?"></a>如何获取自动生成的(主)键值?</h4><p>不同的数据库，获取自动生成的(主)键值的方式是不同的。</p><p>MySQL 有两种方式，但是<strong>自增主键</strong>，代码如下：</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">// 方式一，使用 useGeneratedKeys + keyProperty 属性<insert id="insert" parameterType="Person" useGeneratedKeys="true" keyProperty="id">    INSERT INTO person(name, pswd)    VALUE (#{name}, #{pswd})</insert>// 方式二，使用 `<selectKey />` 标签<insert id="insert" parameterType="Person" useGeneratedKeys="true" keyProperty="id">    <selectKey keyProperty="id" resultType="long" order="AFTER">        SELECT LAST_INSERT_ID()    </selectKey>    INSERT INTO person(name, pswd)    VALUE (#{name}, #{pswd})</insert><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>其中，<strong>方式一</strong> 较为常用。</li></ul><h4 id="Mybatis-执行批量插入，能返回数据库主键列表吗？"><a href="#Mybatis-执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="Mybatis 执行批量插入，能返回数据库主键列表吗？"></a>Mybatis 执行批量插入，能返回数据库主键列表吗？</h4><p>能，JDBC 都能做，Mybatis 当然也能做。</p><h4 id="在-Mapper-中如何传递多个参数"><a href="#在-Mapper-中如何传递多个参数" class="headerlink" title="在 Mapper 中如何传递多个参数?"></a>在 Mapper 中如何传递多个参数?</h4><p>第一种，使用 Map 集合(也可以封装为一个Domain对象)，装载多个参数进行传递。代码如下：</p><pre class="line-numbers language-Java"><code class="language-Java">// 调用方法Map<String, Object> map = new HashMap();map.put("start", start);map.put("end", end);return studentMapper.selectStudents(map);// Mapper 接口List<Student> selectStudents(Map<String, Object> map);// Mapper XML 代码<select id="selectStudents" parameterType="Map" resultType="Student">    SELECT *    FROM students    LIMIT #{start}, #{end}</select><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>显然，这不是一种优雅的方式。</li></ul><p>第二种，保持传递多个参数，使用 <code>@Param</code> 注解。代码如下：</p><pre class="line-numbers language-Java"><code class="language-Java">// 调用方法return studentMapper.selectStudents(0, 10);// Mapper 接口List<Student> selectStudents(@Param("start") Integer start, @Param("end") Integer end);// Mapper XML 代码<select id="selectStudents" resultType="Student">    SELECT *    FROM students    LIMIT #{start}, #{end}</select><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>推荐使用第二种方式。</li></ul><p>第三种，保持传递多个参数，不使用 <code>@Param</code> 注解。代码如下：</p><pre class="line-numbers language-Java"><code class="language-Java">// 调用方法return studentMapper.selectStudents(0, 10);// Mapper 接口List<Student> selectStudents(Integer start, Integer end);// Mapper XML 代码<select id="selectStudents" resultType="Student">    SELECT *    FROM students    LIMIT #{param1}, #{param2}</select><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>其中，按照参数在方法方法中的位置，从 1 开始，逐个为 <code>#{param1}</code>、<code>#{param2}</code>、<code>#{param3}</code> 不断向下。</li></ul><h4 id="Mybatis-是否可以映射-Enum-枚举类？"><a href="#Mybatis-是否可以映射-Enum-枚举类？" class="headerlink" title="Mybatis 是否可以映射 Enum 枚举类？"></a>Mybatis 是否可以映射 Enum 枚举类？</h4><p>Mybatis 可以映射枚举类，对应的实现类为 EnumTypeHandler 或 EnumOrdinalTypeHandler 。</p><ul><li>EnumTypeHandler ，基于 <code>Enum.name</code> 属性( String )。<strong>默认</strong>。</li><li>EnumOrdinalTypeHandler ，基于 <code>Enum.ordinal</code> 属性( <code>int</code> )。可通过 <code>&lt;setting name=&quot;defaultEnumTypeHandler&quot; value=&quot;EnumOrdinalTypeHandler&quot; /&gt;</code> 来设置。</li></ul><p>😈 当然，实际开发场景，我们很少使用 Enum 类型，更加的方式是，代码如下：</p><pre class="line-numbers language-Java"><code class="language-Java">public class Dog {    public static final int STATUS_GOOD = 1;    public static final int STATUS_BETTER = 2;    public static final int STATUS_BEST = 3；    private int status;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>并且，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一列上。映射方式为自定义一个 TypeHandler 类，实现 TypeHandler 的<code>#setParameter(...)</code> 和 <code>#getResult(...)</code> 接口方法。</p><p>TypeHandler 有两个作用：</p><ul><li>一是，完成从 javaType 至 jdbcType 的转换。</li><li>二是，完成 jdbcType 至 javaType 的转换。</li></ul><p>具体体现为 <code>#setParameter(...)</code> 和 <code>#getResult(..)</code> 两个方法，分别代表设置 SQL 问号占位符参数和获取列查询结果。</p><h4 id="Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h4><p>Mybatis 有四种 Executor 执行器，分别是 SimpleExecutor、ReuseExecutor、BatchExecutor、CachingExecutor 。</p><ul><li>SimpleExecutor ：每执行一次 update 或 select 操作，就创建一个 Statement 对象，用完立刻关闭 Statement 对象。</li><li>ReuseExecutor ：执行 update 或 select 操作，以 SQL 作为key 查找<strong>缓存</strong>的 Statement 对象，存在就使用，不存在就创建；用完后，不关闭 Statement 对象，而是放置于缓存 <code>Map</code> 内，供下一次使用。简言之，就是重复使用 Statement 对象。</li><li>BatchExecutor ：执行 update 操作（没有 select 操作，因为 JDBC 批处理不支持 select 操作），将所有 SQL 都添加到批处理中（通过 addBatch 方法），等待统一执行（使用 executeBatch 方法）。它缓存了多个 Statement 对象，每个 Statement 对象都是调用 addBatch 方法完毕后，等待一次执行 executeBatch 批处理。<strong>实际上，整个过程与 JDBC 批处理是相同</strong>。</li><li>CachingExecutor ：在上述的三个执行器之上，增加<strong>二级缓存</strong>的功能。</li></ul><p>通过设置 <code>&lt;setting name=&quot;defaultExecutorType&quot; value=&quot;&quot;&gt;</code> 的 <code>&quot;value&quot;</code> 属性，可传入 SIMPLE、REUSE、BATCH 三个值，分别使用 SimpleExecutor、ReuseExecutor、BatchExecutor 执行器。<br>通过设置 <code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;&quot;</code> 的 <code>&quot;value&quot;</code> 属性为 <code>true</code> 时，创建 CachingExecutor 执行器。   </p><h4 id="MyBatis-如何执行批量插入"><a href="#MyBatis-如何执行批量插入" class="headerlink" title="MyBatis 如何执行批量插入?"></a>MyBatis 如何执行批量插入?</h4><p>首先，在 Mapper XML 编写一个简单的 Insert 语句。代码如下：</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript"><insert id="insertUser" parameterType="String">    INSERT INTO users(name)    VALUES (#{value})</insert><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后，然后在对应的 Mapper 接口中，编写映射的方法。代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">insertUser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span> String name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，调用该 Mapper 接口方法。代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> SqlSessionFactory sqlSessionFactory<span class="token punctuation">;</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建要插入的用户的名字的数组</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> names <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"name1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"name2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"name3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"name4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获得执行器类型为 Batch 的 SqlSession 对象，并且 autoCommit = false ，禁止事务自动交</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>SqlSession session <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span>ExecutorType<span class="token punctuation">.</span>BATCH<span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获得 Mapper 对象</span>        UserMapper mapper <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>UserMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 循环插入</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String name <span class="token operator">:</span> names<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mapper<span class="token punctuation">.</span><span class="token function">insertUser</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 提交批量操作</span>        session<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，还有另一种方式，代码如下：  </p><pre class="line-numbers language-javascript"><code class="language-javascript">INSERT INTO <span class="token punctuation">[</span>表名<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">[</span>列名<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>列名<span class="token punctuation">]</span><span class="token punctuation">)</span>VALUES<span class="token punctuation">(</span><span class="token punctuation">[</span>列值<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>列值<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">[</span>列值<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>列值<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">[</span>列值<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>列值<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于这种方式，需要保证单条 SQL 不超过语句的最大限制 <code>max_allowed_packet</code> 大小，默认为 1 M 。</li></ul><h4 id="介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？"><a href="#介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？" class="headerlink" title="介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？"></a>介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？</h4><p>内容有些长，直接参见 <a href="https://tech.meituan.com/mybatis_cache.html" target="_blank" rel="noopener">《聊聊 MyBatis 缓存机制》</a> 一文。</p><hr><p>这块的源码解析，可见 <a href="http://svip.iocoder.cn/MyBatis/cache-package" target="_blank" rel="noopener">《精尽 MyBatis 源码分析 —— 缓存模块》</a> 。</p><h4 id="什么是延迟加载？-Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#什么是延迟加载？-Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="什么是延迟加载？ Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>什么是延迟加载？ Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h4><p>在一对多中，当我们有一个用户，它有100个账户。那么  </p><ol><li>在查询用户的时候，要不要把关联的账户查出来？  </li><li>在查询账户的时候，要不要把关联的用户查出来？    </li></ol><p>在实际中：</p><ol><li>在查询用户时，用户下的账户信息应该是，什么时候使用，什么时候查询的。  </li><li>在查询账户时，账户的所属用户信息应该是随着账户查询时一起查询出来。     </li></ol><p>什么是延迟加载：<br>    在真正使用数据时才发起查询，不用的时候不查询。按需加载（懒加载）<br>什么是立即加载：<br>    不管用不用，只要一调用方法，马上发起查询。<br>在对应的四种表关系中：<code>一对多</code>，<code>多对一</code>，<code>一对一</code>，<code>多对多</code><br>    <code>一对多</code>，<code>多对多</code>：通常情况下我们都是采用延迟加载。<br>    <code>多对一</code>，<code>一对一</code>：通常情况下我们都是采用立即加载。<br>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载。其中，association 指的就是<strong>一对一</strong>，collection 指的就是<strong>一对多查询</strong>。</p><p>在 Mybatis 配置文件中，可以配置 <code>&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot; /&gt;</code> 来启用延迟加载的功能。默认情况下，延迟加载的功能是<strong>关闭</strong>的。<br>它的原理是，使用 CGLIB 或 Javassist( 默认 ) 创建目标对象的代理对象。当调用代理对象的延迟加载属性的 getter 方法时，进入拦截器方法。比如调用 <code>a.getB().getName()</code> 方法，进入拦截器的 <code>invoke(...)</code> 方法，发现 <code>a.getB()</code>需要延迟加载时，那么就会单独发送事先保存好的查询关联 B 对象的 SQL ，把 B 查询上来，然后调用<code>a.setB(b)</code> 方法，于是 <code>a</code> 对象 <code>b</code> 属性就有值了，接着完成<code>a.getB().getName()</code> 方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是 Mybatis，几乎所有的包括 Hibernate 在内，支持延迟加载的原理都是一样的。</p><h4 id="Mybatis-能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"><a href="#Mybatis-能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。" class="headerlink" title="Mybatis 能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"></a>Mybatis 能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。</h4><p>能，Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询。</p><blockquote><p>艿艿：不过貌似，我自己实际开发中，还是比较喜欢自己去查询和拼接映射的数据。😈</p></blockquote><ul><li>多对一查询，其实就是一对一查询，只需要把 <code>selectOne(...)</code> 修改为 <code>selectList(...)</code> 即可。案例可见 <a href="https://blog.csdn.net/xzm_rainbow/article/details/15336959" target="_blank" rel="noopener">《MyBatis：多对一表关系详解》</a> 。</li><li>多对多查询，其实就是一对多查询，只需要把 <code>#selectOne(...)</code> 修改为 <code>selectList(...)</code> 即可。案例可见 <a href="https://blog.csdn.net/eson_15/article/details/51655188" target="_blank" rel="noopener">《【MyBatis学习10】高级映射之多对多查询》</a> 。</li></ul><hr><p>关联对象查询，有两种实现方式：</p><blockquote><p>艿艿：所有的技术方案，即会有好处，又会有坏处。很难出现，一个完美的银弹方案。</p></blockquote><ul><li>一种是单独发送一个 SQL 去查询关联对象，赋给主对象，然后返回主对象。好处是多条 SQL 分开，相对简单，坏处是发起的 SQL 可能会比较多。</li><li>另一种是使用嵌套查询，嵌套查询的含义为使用 <code>join</code> 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值。好处是只发一个 SQL 查询，就可以把主对象和其关联对象查出来，坏处是 SQL 可能比较复杂。</li></ul><p>那么问题来了，<code>join</code> 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个呢？其去重复的原理是 <code>标签内的</code> 子标签，指定了唯一确定一条记录的 <code>id</code> 列。Mybatis 会根据<code>列值来完成 100 条记录的去重复功能，</code> 可以有多个，代表了联合主键的语意。</p><p>同样主对象的关联对象，也是根据这个原理去重复的。尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。例如：下面 <code>join</code> 查询出来6条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列。Mybatis 去重复处理后，结果为 1 个老师和 6 个学生，而不是 6 个老师和 6 个学生。</p><table><thead><tr><th style="text-align:left">t_id</th><th style="text-align:left">t_name</th><th style="text-align:left">s_id</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">teacher</td><td style="text-align:left">38</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">teacher</td><td style="text-align:left">39</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">teacher</td><td style="text-align:left">40</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">teacher</td><td style="text-align:left">41</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">teacher</td><td style="text-align:left">42</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">teacher</td><td style="text-align:left">43</td></tr></tbody></table><h4 id="简述-Mybatis-的插件运行原理？以及如何编写一个插件？"><a href="#简述-Mybatis-的插件运行原理？以及如何编写一个插件？" class="headerlink" title="简述 Mybatis 的插件运行原理？以及如何编写一个插件？"></a>简述 Mybatis 的插件运行原理？以及如何编写一个插件？</h4><p>Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件。</p><p>Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 <code>#invoke(...)</code>方法。当然，只会拦截那些你指定需要拦截的方法。</p><p>编写一个 MyBatis 插件的步骤如下：</p><ol><li>首先，实现 Mybatis 的 Interceptor 接口，并实现 <code>#intercept(...)</code> 方法。</li><li>然后，在给插件编写注解，指定要拦截哪一个接口的哪些方法即可</li><li>最后，在配置文件中配置你编写的插件。</li></ol><p>具体的，可以参考 <a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins" target="_blank" rel="noopener">《MyBatis 官方文档 —— 插件》</a> 。</p><h4 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h4><p>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的<strong>内存分页</strong>，而非<strong>数据库分页</strong>。</p><p>所以，实际场景下，不适合直接使用 MyBatis 原有的 RowBounds 对象进行分页。而是使用如下两种方案：</p><ul><li>在 SQL 内直接书写带有数据库分页的参数来完成数据库分页功能</li><li>也可以使用分页插件来完成数据库分页。</li></ul><p>这两者都是基于数据库分页，差别在于前者是工程师<strong>手动</strong>编写分页条件，后者是插件<strong>自动</strong>添加分页条件。</p><p>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义分页插件。在插件的拦截方法内，拦截待执行的 SQL ，然后重写 SQL ，根据dialect 方言，添加对应的物理分页语句和物理分页参数。</p><p>举例：<code>SELECT * FROM student</code> ，拦截 SQL 后重写为：<code>select * FROM student LIMI 0，10</code> 。</p><p>目前市面上目前使用比较广泛的 MyBatis 分页插件有：</p><ul><li><a href="https://github.com/pagehelper/Mybatis-PageHelper" target="_blank" rel="noopener">Mybatis-PageHelper</a></li><li><a href="https://github.com/baomidou/mybatis-plus" target="_blank" rel="noopener">MyBatis-Plus</a></li></ul><p>从现在看来，<a href="https://github.com/baomidou/mybatis-plus" target="_blank" rel="noopener">MyBatis-Plus</a> 逐步使用的更加广泛。</p><h4 id="MyBatis-与-Hibernate-有哪些不同？"><a href="#MyBatis-与-Hibernate-有哪些不同？" class="headerlink" title="MyBatis 与 Hibernate 有哪些不同？"></a>MyBatis 与 Hibernate 有哪些不同？</h4><p>Mybatis 和 Hibernate 不同，它<strong>不完全是</strong>一个 ORM 框架，因为MyBatis 需要程序员自己编写 SQL 语句。不过 MyBatis 可以通过 XML 或注解方式灵活配置要运行的 SQL 语句，并将 Java 对象和 SQL 语句映射生成最终执行的 SQL ，最后将 SQL 执行的结果再映射生成 Java 对象。</p><p>Mybatis 学习门槛低，简单易学，程序员直接编写原生态 SQL ，可严格控制 SQL 执行性能，灵活度高。但是灵活的前提是 MyBatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套 SQL 映射文件，工作量大。</p><p>Hibernate 对象/关系映射能力强，数据库无关性好。如果用 Hibernate 开发可以节省很多代码，提高效率。但是 Hibernate 的缺点是学习门槛高，要精通门槛更高，而且怎么设计 O/R 映射，在性能和对象模型之间如何权衡，以及怎样用好 Hibernate 需要具有很强的经验和能力才行。</p><p>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。简单总结如下：</p><ul><li>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取。</li><li>Mybatis 属于半自动 ORM 映射工具，在查询关联对象或关联集合对象时，需要手动编写 SQL 来完成。</li></ul><p>另外，在 <a href="https://www.jianshu.com/p/96171e647885" target="_blank" rel="noopener">《浅析 Mybatis 与 Hibernate 的区别与用途》</a> 文章，也是写的非常不错的。</p><p>当然，实际上，MyBatis 也可以搭配自动生成代码的工具，提升开发效率，还可以使用 <a href="http://mp.baomidou.com/" target="_blank" rel="noopener">MyBatis-Plus</a> 框架，已经内置常用的 SQL 操作，也是非常不错的。</p><h4 id="JDBC-编程有哪些不足之处（问题），MyBatis是如何解决这些问题的？"><a href="#JDBC-编程有哪些不足之处（问题），MyBatis是如何解决这些问题的？" class="headerlink" title="JDBC 编程有哪些不足之处（问题），MyBatis是如何解决这些问题的？"></a>JDBC 编程有哪些不足之处（问题），MyBatis是如何解决这些问题的？</h4><p>问题一：SQL 语句写在代码中造成代码不易维护，且代码会比较混乱。</p><p>解决方式：将 SQL 语句配置在 Mapper XML 文件中，与 Java 代码分离。</p><p>问题二：根据参数不同，拼接不同的 SQL 语句非常麻烦。例如 SQL 语句的 WHERE 条件不一定，可能多也可能少，占位符需要和参数一一对应。</p><p>解决方式：MyBatis 提供 <code>&lt;where /&gt;</code>、<code>&lt;if /&gt;</code> 等等动态语句所需要的标签，并支持 OGNL 表达式，简化了动态 SQL 拼接的代码，提升了开发效率。</p><hr><p>问题三，对结果集解析麻烦，SQL 变化可能导致解析代码变化，且解析前需要遍历。</p><p>解决方式：Mybatis 自动将 SQL 执行结果映射成 Java 对象。</p><hr><p>问题四，数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</p><p>解决方式：在 <code>mybatis-config.xml</code> 中，配置数据链接池，使用连接池管理数据库链接。</p><p>当然，即使不使用 MyBatis ，也可以使用数据库连接池。<br>另外，MyBatis 默认提供了数据库连接池的实现，只是说，因为其它开源的数据库连接池性能更好，所以一般很少使用 MyBatis 自带的连接池实现。</p><h4 id="Mybatis-比-IBatis-比较大的几个改进是什么？"><a href="#Mybatis-比-IBatis-比较大的几个改进是什么？" class="headerlink" title="Mybatis 比 IBatis 比较大的几个改进是什么？"></a>Mybatis 比 IBatis 比较大的几个改进是什么？</h4><blockquote><p>这是一个选择性了解的问题，因为可能现在很多面试官，都没用过 IBatis 框架。</p></blockquote><ol><li>有接口绑定，包括注解绑定 SQL 和 XML 绑定 SQL 。</li><li>动态 SQL 由原来的节点配置变成 OGNL 表达式。</li><li>在一对一或一对多的时候，引进了 <code>association</code> ，在一对多的时候，引入了 <code>collection</code>节点，不过都是在 <code></code> 里面配置。</li></ol><h4 id="Mybatis-映射文件中，如果-A-标签通过-include-引用了B标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在A标签的前面？"><a href="#Mybatis-映射文件中，如果-A-标签通过-include-引用了B标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="Mybatis 映射文件中，如果 A 标签通过 include 引用了B标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在A标签的前面？"></a>Mybatis 映射文件中，如果 A 标签通过 include 引用了B标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在A标签的前面？</h4><p>虽然 Mybatis 解析 XML 映射文件是<strong>按照顺序</strong>解析的。但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。<strong>也就是说，无需按照顺序，进行定义</strong>。</p><p>原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为<strong>未解析状态</strong>。然后，继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析A标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p><h4 id="简述-Mybatis-的-XML-映射文件和-Mybatis-内部数据结构之间的映射关系？"><a href="#简述-Mybatis-的-XML-映射文件和-Mybatis-内部数据结构之间的映射关系？" class="headerlink" title="简述 Mybatis 的 XML 映射文件和 Mybatis 内部数据结构之间的映射关系？"></a>简述 Mybatis 的 XML 映射文件和 Mybatis 内部数据结构之间的映射关系？</h4><p>Mybatis 将所有 XML 配置信息都封装到 All-In-One 重量级对象Configuration内部。</p><p>在 XML Mapper 文件中：</p><ul><li><code>&lt;parameterMap&gt;</code> 标签，会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。</li><li><code>&lt;resultMap&gt;</code> 标签，会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。</li><li>每一个 <code>select</code>、<code>update</code>、<code>delete</code>、<code>insert</code> 标签，均会被解析为一个 MappedStatement 对象，标签内的 SQL 会被解析为一个 BoundSql 对象。   </li></ul><h4 id="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h4><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。<br>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p>]]></content>
      
      
      <categories>
          
          <category> java web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java内部类</title>
      <link href="/2019/11/20/Java%20InnerClass/"/>
      <url>/2019/11/20/Java%20InnerClass/</url>
      
        <content type="html"><![CDATA[<p>众所周知，每一个Java类都生成一个class文件。内部类是在一个类中再定义一个类，被包含着的类就称为内部类，包含内部类的相比之下就称为外部类。内部类与外部类之间有着紧密的联系，而内部类与其它的类关系不大。这也是内部类的一个优点：被完全隐藏起来，有着更好的封装性（可以声明为private对外界完全隐藏），减少了代码量（可轻松访问外部类的私有变量），使其更为简洁。<br>虽然内部类被包含在外部类中，看起来是一个类，但这只是从java编译器的角度来看的，在java虚拟机层面看到的（与泛型类似）其实还是两个类，也就是说，每个内部类最后都会被编译为一个独立的类，生成一个独立的字节码文件。下面的一段代码中实际会生成两个类：Outer与Outer$StaticInner。<br><strong>内部类可以被定义为private，仅外部类可以实例化该内部类与使用其方法，仅有内部类可以被定义为private、static</strong><br>分为静态内部类、成员内部类、方法（局部）内部类与匿名内部类。  </p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><h4 id="特征：-带有static关键字。"><a href="#特征：-带有static关键字。" class="headerlink" title="特征： 带有static关键字。"></a><strong>特征：</strong> 带有<strong>static</strong>关键字。</h4><p>在java中，只有一种情况类前可以加static关键字–静态内部类。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//定义外部类</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> outInt <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//定义外部类的静态变量，类变量</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    StaticInner si <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticInner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    si<span class="token punctuation">.</span><span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StaticInner</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//定义静态内部类</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"inner :"</span> <span class="token operator">+</span> outInt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="静态内部类使用方式"><a href="#静态内部类使用方式" class="headerlink" title="静态内部类使用方式"></a>静态内部类使用方式</h4><ol><li>一个静态内部类可以拥有 <strong>静态变量，静态方法，成员变量，成员方法，构造方法等。</strong>    </li><li>静态内部类只能只能访问外部类的静态（类）变量与静态（类）方法，不能访问实例变量与实例方法。  </li><li>在一个外部类中可以像往常使用一个类一样（如上面代码段的test方法中所示），可以很方便的去使用静态内部类。</li><li>对于其它的类，也可以使用一个类中的静态内部类的public成员。规则为<strong>“外部类.静态内部类”</strong> ，具体如下：  <blockquote><p>Outer.StaticInner si = new Outer.StaticInner();<br>si.innerMethod();</p></blockquote></li></ol><h4 id="静态内部类细节"><a href="#静态内部类细节" class="headerlink" title="静态内部类细节"></a>静态内部类细节</h4><p>既然是生成了两个类，那么为何能访问到另一个类的私有成员呢？例如上面的outInt变量。<br>java的解决方案是：自动为Outer类生成一个非私有的访问方法access$0,这个方法返回私有静态变量outInt。  </p><h4 id="静态内部类的使用场景"><a href="#静态内部类的使用场景" class="headerlink" title="静态内部类的使用场景"></a>静态内部类的使用场景</h4><p>当一个类与外部类关系紧密且不依赖外部类实例的时候，可以考虑定义为静态内部类，例如要返回多个返回值，可以考虑使用内部类。<br><strong>LinkedList</strong><br>1、非静态内部类是不可以声明静态成员的（属性和方法），使用静态类就可以声明静态成员，而这招体现在实际的工作中，也许可以让你避免绕许多圈子。<br>2、非静态内部类，可以随意的访问外部类中的成员变量与成员方法，即便它们是私有的也可以（这是它活下来的重要手段之一，呵呵）。<br>     但静态内部类对外部类的访问是有局限的，如不能访问外部类的非静态成员与变量（这是它的最大限制，也是使用频率上输给普通内部类的原因）<br>3、普通内部类把它理解为与外部类绑定了，创建普通内部类对象一定要通过外部类的对象new才行。而静态内部类是不需要的。</p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><h4 id="特点：-相比静态内部类，没有static修饰。"><a href="#特点：-相比静态内部类，没有static修饰。" class="headerlink" title="特点： 相比静态内部类，没有static修饰。"></a>特点： 相比静态内部类，没有static修饰。</h4><p>虽然成员内部类与静态内部类在定义上只差了一个static修饰符，但具体的含义与使用有着巨大的不同。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//定义外部类</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> outInt <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//定义外部类的静态变量，类变量</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is Outer`s action"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Inner inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    inner<span class="token punctuation">.</span><span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//定义内部类</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"outInt :"</span> <span class="token operator">+</span> outInt<span class="token punctuation">)</span><span class="token punctuation">;</span>      Outer<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//内部类调用外部类的非静态方法</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="成员内部类使用方式"><a href="#成员内部类使用方式" class="headerlink" title="成员内部类使用方式"></a>成员内部类使用方式</h4><ol><li>与静态内部类不同，一个成员内部类拥有 <strong>成员变量、成员方法、构造方法</strong>    </li><li>在静态内部类中，内部类只能访问外部类的静态变量与静态方法。但是在成员内部类中，除了可以访问外部类的静态变量与静态方法，还可以直接访问外部类的实例变量与实例方法。例如：在Inner类中的innerMethod方法可以直接访问外部类的私有实例变量outInt，在成员内部类Inner中可以通过 <strong>“外部类.this.xxx”</strong> 的方式来使用外部类的实例变量与实例方法，例如 <strong>“Outer.this.action();”</strong> 。既然要用  <strong>“外部类.this.xxx”</strong> 这种形式来访问外部类的实例变量与实例方法，那么在上面的代码中，在Inner类中为什么只用访问外部类的action方法时才用这种方法，而访问实例变量outInt时确直接就访问了呢？因为在不引起异议的前提下，可以省略 <strong>“外部类.this”</strong>  而直接使用外部类的实例变量或实例方法即可，也就是说内部类使用action方法时，其前面的 <strong>“Outer.this”</strong> 也可省略。    </li><li>在外部类里使用内部类的成员时，成员内部类与静态内部类的使用方式是一样， <strong>直接使用即可</strong> 如test（）方法所示。</li><li>与静态内部类所不同的是 <strong>成员内部类对象总是与一个外部类对象相连，在外部使用时（外部类之外），它不能通过 new Outer.Inner() 的方式创建对象，而是要先创建一个Outer对象。</strong>    </li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//外部（外部类之外）使用内部类的方式    </span>Outer outer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Outer<span class="token punctuation">.</span>Inner inner <span class="token operator">=</span> outer<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>inner<span class="token punctuation">.</span><span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如上面代码段所示，在外部使用成员内部类的方式。  </p><h4 id="成员内部类细节"><a href="#成员内部类细节" class="headerlink" title="成员内部类细节"></a>成员内部类细节</h4><p>静态内部类可以定义静态变量与静态方法，但是在成员内部类中不可以定义这两个（final除外，因为它等同于常量）。并且在方法内部类与匿名内部类也不可以定义静态变量与静态方法。我们可以这样理解：之所以不让定义，是因为这些内部类不应该单独使用，不应该定义类的变量与方法。</p><h4 id="成员内部类使用场景与源码举例"><a href="#成员内部类使用场景与源码举例" class="headerlink" title="成员内部类使用场景与源码举例"></a>成员内部类使用场景与源码举例</h4><p>当内部类与外部类关系密切，需要访问外部类的实例变量与实例方法时，可以考虑定义为成员内部类。这个内部类还可以定义为private，对外部完全隐藏。例如LinkedList中的listIterator方法，其返回值为接口Iterator，listIterator内部使用了成员内部类ListItr。<br>LinkedList  </p><hr><h3 id="方法内部类"><a href="#方法内部类" class="headerlink" title="方法内部类"></a>方法内部类</h3><h4 id="方法内部类特征"><a href="#方法内部类特征" class="headerlink" title="方法内部类特征"></a>方法内部类特征</h4><p>在一个方法中定义一个类。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//定义外部类</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> test<span class="token punctuation">{</span><span class="token keyword">final</span> <span class="token keyword">int</span> param<span class="token punctuation">}</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//在方法中定义一个内部类</span>    <span class="token keyword">final</span> String str <span class="token operator">=</span> <span class="token string">"xiaomi"</span><span class="token punctuation">;</span>    Inner inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//使用内部类</span>    inner<span class="token punctuation">.</span>innerMethod<span class="token punctuation">;</span>    <span class="token keyword">class</span> <span class="token class-name">Inner</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//定义内部类</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"outer a:"</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"param:"</span> <span class="token operator">+</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"test str:"</span> <span class="token operator">+</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法内部类的使用方式"><a href="#方法内部类的使用方式" class="headerlink" title="方法内部类的使用方式"></a>方法内部类的使用方式</h4><ol><li>在Outer类中的test方法中定义一个内部类Inner， <strong>方法内部类只能在定义的方法内被使用。</strong>    </li><li>方法内部类可以直接访问方法的方法参数与方法中的局部变量，  <strong>但是这些方法里的局部变量必须被声明为final，如上面的innerMethod方法所示，可直接访问param与final的str。</strong>  </li><li>如果方法是一个实例方法，则 <strong>方法内部类可以直接访问外部类的静态变量、静态方法、实例变量，实例方法。</strong>  </li><li>如果方法是一个静态方法，则 <strong>方法内部类 只能 访问外部类的静态变量、静态方法。</strong>   </li></ol><h4 id="方法内部类的思考"><a href="#方法内部类的思考" class="headerlink" title="方法内部类的思考"></a>方法内部类的思考</h4><p>似乎方法内部类有些多余，因为方法内部类能做的成员内部类也可以做到，至于方法参数也可以作为参数传递给成员内部类，我个人认为方法内部类的设计可能是出于能更好封装的目的，只能在被定义的方法中使用。  </p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><h4 id="匿名内部类的特征"><a href="#匿名内部类的特征" class="headerlink" title="匿名内部类的特征"></a>匿名内部类的特征</h4><p>与静态内部类、成员内部类、方法内部类不同，匿名内部类没有单独的定义，它在创建对象的同时定义类。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">new</span> 父类（参数列表）｛<span class="token comment" spellcheck="true">//匿名内部类的实现</span>｝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者如下使用：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">new</span> 父接口（）｛<span class="token comment" spellcheck="true">//匿名内部类的实现</span>｝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="匿名内部类的使用方式"><a href="#匿名内部类的使用方式" class="headerlink" title="匿名内部类的使用方式"></a>匿名内部类的使用方式</h4><p>匿名内部类是与new相关联的，在创建对象的时候定义类，new + 父类/父接口 +（） +｛｝，其中圆括号是传递给父类构造方法的参数，大括号里为类的定义。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">final</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>  Point p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//匿名内部类，其父类是Point。  </span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">distance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建Point对象的时候，定义了一个匿名内部类，这个类的父类是Point，创建对象的时候，给父类构造方法传递了参数2与参数3，重写了distance方法，在方法中访问了外部方法final参数x与y。   </p><ol><li>匿名内部类只能被使用一次,用来创建一个对象。</li><li>匿名内部类没有名字,没有构造方法,但可以根据参数列表,调用对应的父类构造方法。  </li><li>匿名内部类可以定义实例变量和方法,可以有初始化代码块,初始化代码块可以起到构造方法的作用,只是构造方法可以有多个,而初始化代码块只能有一份。  </li><li>匿名内部类因为没有构造方法,它自己无法接受参数,如果必须要参数,则应该使用其他内部类。与方法内部类一样,匿名内部类也可以访问外部类的所有变量和方法,可以访问方法中的final参数和局部变量。  </li></ol><h4 id="匿名内部类实现原理"><a href="#匿名内部类实现原理" class="headerlink" title="匿名内部类实现原理"></a>匿名内部类实现原理</h4><p>匿名内部类也都被生成为一个独立的类，只是类的名字以外部类加数字编号，是一个没有什么具体意义的名字。上面的代码段会产生两个类Outer和Outer$1，代码大概如下所示：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>        Point p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer</span>$<span class="token function">1</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>                                                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">distance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span>$<span class="token number">1</span> <span class="token keyword">extends</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x2<span class="token punctuation">;</span>    <span class="token keyword">int</span> y2<span class="token punctuation">;</span>    Outer outer<span class="token punctuation">;</span>    Outer$<span class="token function">1</span><span class="token punctuation">(</span>Outer outer<span class="token punctuation">,</span> <span class="token keyword">int</span> x1<span class="token punctuation">,</span> <span class="token keyword">int</span> y1<span class="token punctuation">,</span> <span class="token keyword">int</span> x2<span class="token punctuation">,</span> <span class="token keyword">int</span> y2<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span>y1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>outer <span class="token operator">=</span> outer<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x2 <span class="token operator">=</span> x2<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y2 <span class="token operator">=</span> y2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>                                  <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                     <span class="token keyword">return</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x2<span class="token punctuation">,</span>y2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与方法内部类类似，外部实例this，方法参数x和y都作为参数传递给了内部类构造方法。此外，new时的参数2和3也传递给了构造方法，内部类构造方法又将它们传递给了父类构造方法。</p><h4 id="匿名内部类使用场景"><a href="#匿名内部类使用场景" class="headerlink" title="匿名内部类使用场景"></a>匿名内部类使用场景</h4><p>匿名内部类能做的，方法内部类都能做。但如果对象只会创建一次，且不需要构造方法来接受参数，则可以使用匿名内部类，代码书写上更为简洁。<br>在调用方法时，很多方法需要一个接口参数，比如说Arrays.sort方法，它可以接受一个数组，以及一个Comparator接口参数，Comparator有一个方法compare用于比较两个对象。<br>比如说，我们要对一个字符串数组不区分大小写排序，可以使用Arrays.sort方法，但需要传递一个实现了Comparator接口的对象，这时就可以使用匿名内部类，代码如下所示：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sortIgnoreCase</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> strs<span class="token punctuation">)</span><span class="token punctuation">{</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strs<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>String o1<span class="token punctuation">,</span> String o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> o1<span class="token punctuation">.</span><span class="token function">compareToIgnoreCase</span><span class="token punctuation">(</span>o2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Comparator后面的<stirng>与泛型有关，表示比较的对象是字符串类型，后续文章会讲解泛型。<br>匿名内部类还经常用于事件处理程序中，用于响应某个事件，比如说一个Button，处理点击事件的代码可能类似如下：</stirng></p><pre class="line-numbers language-java"><code class="language-java">Button bt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Button</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bt<span class="token punctuation">.</span><span class="token function">addActionListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ActionListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span>ActionEvent e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//处理事件</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用addActionListener将事件处理程序注册到了Button对象bt中，当事件发生时，会调用actionPerformed方法，并传递事件详情ActionEvent作为参数。<br>以上Arrays.sort和Button都是上节提到的一种针对接口编程的例子，另外，它们也都是一种回调的例子。所谓回调是相对于一般的正向调用而言，平时一般都是正向调用，但Arrays.sort中传递的Comparator对象，它的compare方法并不是在写代码的时候被调用的，而是在Arrays.sort的内部某个地方回过头来调用的。Button中的传递的ActionListener对象，它的actionPerformed方法也一样，是在事件发生的时候回过头来调用的。<br>将程序分为保持不变的主体框架，和针对具体情况的可变逻辑，通过回调的方式进行协作，是计算机程序的一种常用实践。匿名内部类是实现回调接口的一种简便方式。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring总结</title>
      <link href="/2019/11/15/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Spring%20AOP/"/>
      <url>/2019/11/15/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Spring%20AOP/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring-注解"><a href="#Spring-注解" class="headerlink" title="Spring 注解"></a>Spring 注解</h3><h4 id="什么是基于注解的容器配置？"><a href="#什么是基于注解的容器配置？" class="headerlink" title="什么是基于注解的容器配置？"></a>什么是基于注解的容器配置？</h4><p>不使用 XML 来描述 Bean 装配，开发人员通过在相关的类，方法或字段声明上使用<strong>注解</strong>将配置移动到组件类本身。它可以作为 XML 设置的替代方案。例如：</p><p>Spring 的 Java 配置是通过使用 <code>@Bean</code> 和 <code>@Configuration</code> 来实现。</p><ul><li><code>@Bean</code> 注解，与 <code>&lt;bean /&gt;</code> 元素相同。</li><li><code>@Configuration</code> 注解的类，允许通过简单地调用同一个类中的其他 <code>@Bean</code> 方法来定义 Bean 间依赖关系。</li></ul><p>示例如下：</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">@Configurationpublic class StudentConfig {    @Bean    public StudentBean myStudent() {        return new StudentBean();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="如何在-Spring-中启动注解装配？"><a href="#如何在-Spring-中启动注解装配？" class="headerlink" title="如何在 Spring 中启动注解装配？"></a>如何在 Spring 中启动注解装配？</h4><p>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置 <code>&lt;context：annotation-config /&gt;</code> 元素在 Spring 配置文件中启用它。</p><p>当然，如果是使用 Spring Boot ，默认情况下已经开启。</p><h4 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h4><ul><li><code>@Component</code> ：它将 Java 类标记为 Bean 。它是任何 Spring 管理组件的<strong>通用</strong>构造型。</li><li><code>@Controller</code> ：它将一个类标记为 Spring Web MVC <strong>控制器</strong>。</li><li><code>@Service</code> ：此注解是组件注解的特化。它不会对 <code>@Component</code> 注解提供任何其他行为。您可以在<strong>服务层</strong>类中使用 @Service 而不是 <code>@Component</code> ，因为它以更好的方式指定了意图。</li><li><code>@Repository</code> ：这个注解是具有类似用途和功能的 <code>@Component</code> 注解的特化。它为 <strong>DAO</strong> 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException 。</li></ul><h2 id="Required-注解有什么用？"><a href="#Required-注解有什么用？" class="headerlink" title="@Required 注解有什么用？"></a>@Required 注解有什么用？</h2><p><code>@Required</code> 注解，应用于 Bean 属性 setter 方法。</p><ul><li>此注解仅指示必须在配置时使用 Bean 定义中的显式属性值或使用自动装配填充受影响的 Bean 属性。</li><li>如果尚未填充受影响的 Bean 属性，则容器将抛出 BeanInitializationException 异常。</li></ul><p>示例代码如下：</p><pre class="line-numbers language-Java"><code class="language-Java">public class Employee {    private String name;    @Required    public void setName(String name){        this.name=name;    }    public string getName(){        return name;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Autowired-注解有什么用？"><a href="#Autowired-注解有什么用？" class="headerlink" title="@Autowired 注解有什么用？"></a>@Autowired 注解有什么用？</h4><p><code>@Autowired</code> 注解，可以更准确地控制应该在何处以及如何进行自动装配。</p><ul><li>此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 Bean。</li><li>默认情况下，它是类型驱动的注入。</li></ul><p>示例代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EmpAccount</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> Employee emp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Qualifier-注解有什么用？"><a href="#Qualifier-注解有什么用？" class="headerlink" title="@Qualifier 注解有什么用？"></a>@Qualifier 注解有什么用？</h4><p>当你创建多个<strong>相同类型</strong>的 Bean ，并希望仅使用属性装配<strong>其中一个</strong> Bean 时，可以使用 <code>@Qualifier</code> 注解和 <code>@Autowired</code> 注解通过指定 ID 应该装配哪个<strong>确切的</strong> Bean 来消除歧义。</p><p>例如，应用中有两个类型为 Employee(可能实现了同一个接口) 的 Bean ID 为 <code>&quot;emp1&quot;</code> 和 <code>&quot;emp2&quot;</code> ，此处，我们希望 EmployeeAccount Bean 注入 <code>&quot;emp1&quot;</code> 对应的 Bean 对象。代码如下：</p><pre class="line-numbers language-Java"><code class="language-Java">public class EmployeeAccount {    @Autowired    @Qualifier(emp1)    private Employee emp;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><blockquote><p>概念点主要有：</p><ul><li>AOP</li><li>Aspect</li><li>JoinPoint</li><li>PointCut</li><li>Advice</li><li>Target</li><li>AOP Proxy</li><li>Weaving</li></ul></blockquote><p>非常推荐阅读如下两篇文章：</p><ul><li><a href="https://segmentfault.com/a/1190000007469968" target="_blank" rel="noopener">《彻底征服 Spring AOP 之理论篇》</a></li><li><a href="https://segmentfault.com/a/1190000007469982" target="_blank" rel="noopener">《彻底征服 Spring AOP 之实战篇》</a></li></ul><h4 id="什么是-AOP-？"><a href="#什么是-AOP-？" class="headerlink" title="什么是 AOP ？"></a>什么是 AOP ？</h4><p>AOP(Aspect-Oriented Programming)，即<strong>面向切面编程</strong>, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成， 提供了与 OOP 不同的抽象软件结构的视角。</p><ul><li>在 OOP 中，以类( Class )作为基本单元</li><li>在 AOP 中，以<strong>切面( Aspect )</strong>作为基本单元。</li></ul><h4 id="什么是-Aspect-？"><a href="#什么是-Aspect-？" class="headerlink" title="什么是 Aspect ？"></a>什么是 Aspect ？</h4><p>Aspect 由 <strong>PointCut</strong> 和 <strong>Advice</strong> 组成。</p><ul><li>它既包含了横切逻辑的定义，也包括了连接点的定义。</li><li>Spring AOP 就是负责实施切面的框架，它将切面所定义的横切逻辑编织到切面所指定的连接点中。</li></ul><p>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p><ol><li>如何通过 PointCut 和 Advice 定位到特定的 <strong>JoinPoint</strong> 上。</li><li>如何在 Advice 中编写切面代码。</li></ol><p><strong>可以简单地认为, 使用 @Aspect 注解的类就是切面</strong></p><h2 id="什么是-JoinPoint"><a href="#什么是-JoinPoint" class="headerlink" title="什么是 JoinPoint ?"></a>什么是 JoinPoint ?</h2><p>JoinPoint ，<strong>切点</strong>，程序运行中的一些时间点, 例如：</p><ul><li>一个方法的执行。</li><li>或者是一个异常的处理。</li></ul><p>在 Spring AOP 中，JoinPoint 总是方法的执行点。</p><h2 id="什么是-PointCut-？"><a href="#什么是-PointCut-？" class="headerlink" title="什么是 PointCut ？"></a>什么是 PointCut ？</h2><p>PointCut ，<strong>匹配</strong> JoinPoint 的谓词(a predicate that matches join points)。</p><blockquote><p>简单来说，PointCut 是匹配 JoinPoint 的条件。</p></blockquote><ul><li>Advice 是和特定的 PointCut 关联的，并且在 PointCut 相匹配的 JoinPoint 中执行。即 <code>Advice =&gt; PointCut =&gt; JoinPoint</code> 。</li><li>在 Spring 中, 所有的方法都可以认为是 JoinPoint ，但是我们并不希望在所有的方法上都添加 Advice 。<strong>而 PointCut 的作用</strong>，就是提供一组规则(使用 AspectJ PointCut expression language 来描述) 来匹配 JoinPoint ，给满足规则的 JoinPoint 添加 Advice 。</li></ul><h2 id="关于-JoinPoint-和-PointCut-的区别"><a href="#关于-JoinPoint-和-PointCut-的区别" class="headerlink" title="关于 JoinPoint 和 PointCut 的区别"></a>关于 JoinPoint 和 PointCut 的区别</h2><p>JoinPoint 和 PointCut 本质上就是<strong>两个不同纬度上</strong>的东西。</p><ul><li>在 Spring AOP 中，所有的方法执行都是 JoinPoint 。而 PointCut 是一个描述信息，它修饰的是 JoinPoint ，通过 PointCut ，我们就可以确定哪些 JoinPoint 可以被织入 Advice 。</li><li>Advice 是在 JoinPoint 上执行的，而 PointCut 规定了哪些 JoinPoint 可以执行哪些 Advice 。</li></ul><p>或者，我们在换一种说法：</p><ol><li>首先，Advice 通过 PointCut 查询需要被织入的 JoinPoint 。</li><li>然后，Advice 在查询到 JoinPoint 上执行逻辑。</li></ol><h2 id="什么是-Advice-？"><a href="#什么是-Advice-？" class="headerlink" title="什么是 Advice ？"></a>什么是 Advice ？</h2><p>Advice ，<strong>通知</strong>。</p><ul><li>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice 。</li><li>Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的<strong>拦截器</strong>。</li></ul><p><strong>有哪些类型的 Advice？</strong></p><ul><li>Before - 这些类型的 Advice 在 JoinPoint 方法之前执行，并使用 <code>@Before</code> 注解标记进行配置。</li><li>After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用 <code>@AfterReturning</code> 注解标记进行配置。</li><li>After Throwing - 这些类型的 Advice 仅在 JoinPoint 方法通过抛出异常退出并使用 <code>@AfterThrowing</code> 注解标记配置时执行。</li><li>After Finally - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 <code>@After</code> 注解标记进行配置。</li><li>Around - 这些类型的 Advice 在连接点之前和之后执行，并使用 <code>@Around</code> 注解标记进行配置。</li></ul><h2 id="什么是-Target-？"><a href="#什么是-Target-？" class="headerlink" title="什么是 Target ？"></a>什么是 Target ？</h2><p>Target ，织入 Advice 的<strong>目标对象</strong>。目标对象也被称为 <strong>Advised Object</strong> 。</p><ul><li>因为 Spring AOP 使用运行时代理的方式来实现 Aspect ，因此 Advised Object 总是一个代理对象(Proxied Object) 。</li><li><strong>注意, Advised Object 指的不是原来的对象，而是织入 Advice 后所产生的代理对象</strong>。</li><li>Advice + Target Object = Advised Object = Proxy 。</li></ul><h4 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h4><p>实现 AOP 的技术，主要分为两大类：</p><ol><li><p><strong>静态代理</strong> - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强。</p><ul><li><p>编译时编织（特殊编译器实现）</p></li><li><p>类加载时编织（特殊的类加载器实现）。</p><blockquote><p>例如，SkyWalking 基于 Java Agent 机制，配置上 ByteBuddy 库，实现类加载时编织时增强，从而实现链路追踪的透明埋点。</p></blockquote></li></ul></li><li><p><strong>动态代理</strong> - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。目前 Spring 中使用了两种动态代理库：</p><ul><li>JDK 动态代理</li><li>CGLIB<br>那么 Spring 什么时候使用 JDK 动态代理，什么时候使用 CGLIB 呢？   </li></ul></li></ol><pre><code>// From 《Spring 源码深度解析》P172// Spring AOP 部分使用 JDK 动态代理或者 CGLIB 来为目标对象创建代理。（建议尽量使用 JDK 的动态代理）// 如果被代理的目标对象实现了至少一个接口，则会使用 JDK 动态代理。所有该目标类型实现的接口都讲被代理。// 若该目标对象没有实现任何接口，则创建一个 CGLIB 代理。// 如果你希望强制使用 CGLIB 代理，（例如希望代理目标对象的所有方法，而不只是实现自接口的方法）那也可以。但是需要考虑以下两个方法：//      1&gt; 无法通知(advise) Final 方法，因为它们不能被覆盖。//      2&gt; 你需要将 CGLIB 二进制发型包放在 classpath 下面。// 为什么 Spring 默认使用 JDK 的动态代理呢？笔者猜测原因如下：//      1&gt; 使用 JDK 原生支持，减少三方依赖//      2&gt; JDK8 开始后，JDK 代理的性能差距 CGLIB 的性能不会太多。可参见：https://www.cnblogs.com/haiq/p/4304615.html</code></pre><p>Spring AOP 中的动态代理主要有两种方式，</p><ul><li><p>JDK 动态代理</p><p>JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是 InvocationHandler 接口和 Proxy 类。</p></li><li><p>CGLIB 动态代理</p><p>如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。当然，Spring 也支持配置，<strong>强制</strong> 使用 CGLIB 动态代理。<br>CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 <code>final</code> ，那么它是无法使用 CGLIB 做动态代理的。</p></li></ul><h4 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h4><ul><li>代理方式不同<ul><li>Spring AOP 基于动态代理方式实现。</li><li>AspectJ AOP 基于静态代理方式实现。</li></ul></li><li>PointCut 支持力度不同<ul><li>Spring AOP <strong>仅</strong> 支持方法级别的 PointCut 。</li><li>AspectJ AOP 提供了完全的 AOP 支持，它还支持属性级别的 PointCut 。</li></ul></li></ul><h4 id="什么是编织（Weaving）？"><a href="#什么是编织（Weaving）？" class="headerlink" title="什么是编织（Weaving）？"></a>什么是编织（Weaving）？</h4><p>Weaving ，<strong>编织</strong>。</p><ul><li>为了创建一个 Advice 对象而链接一个 Aspect 和其它应用类型或对象，称为编织（Weaving）。</li><li>在 Spring AOP 中，编织在运行时执行，即动态代理。请参考下图：[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://static2.iocoder.cn/images/Spring/2018-12-24/05.jpg" alt="Proxy](http://static2.iocoder.cn/images/Spring/2018-12-24/05.jpg)" title="">                </div>                <div class="image-caption">Proxy](http://static2.iocoder.cn/images/Spring/2018-12-24/05.jpg)</div>            </figure>Proxy</li></ul><h2 id="Spring-如何使用-AOP-切面？"><a href="#Spring-如何使用-AOP-切面？" class="headerlink" title="Spring 如何使用 AOP 切面？"></a>Spring 如何使用 AOP 切面？</h2><p>在 Spring AOP 中，有两种方式配置 AOP 切面：</p><ul><li>基于 <strong>XML</strong> 方式的切面实现。</li><li>基于 <strong>注解</strong> 方式的切面实现。</li></ul><p>目前，主流喜欢使用 <strong>注解</strong> 方式。</p><h1 id="Spring-Transaction"><a href="#Spring-Transaction" class="headerlink" title="Spring Transaction"></a>Spring Transaction</h1><p>非常推荐阅读如下文章：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;mid=2247484702&amp;idx=1&amp;sn=c04261d63929db09ff6df7cadc7cca21&amp;chksm=fa497aafcd3ef3b94082da7bca841b5b7b528eb2a52dbc4eb647b97be63a9a1cf38a9e71bf90&amp;token=165108535&amp;lang=zh_CN#rd" target="_blank" rel="noopener">《可能是最漂亮的 Spring 事务管理详解》</a></li></ul><h4 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h4><p>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。</p><p>这样可以防止出现脏数据，防止数据库数据出现问题。</p><h4 id="事务的特性指的是？"><a href="#事务的特性指的是？" class="headerlink" title="事务的特性指的是？"></a>事务的特性指的是？</h4><p>指的是 <strong>ACID</strong> ，</p><ol><li><strong>原子性</strong> Atomicity ：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li><li><strong>一致性</strong> Consistency ：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设<a href="https://zh.wikipedia.org/wiki/数据完整性" target="_blank" rel="noopener">约束</a>、<a href="https://zh.wikipedia.org/wiki/触发器_(数据库" target="_blank" rel="noopener">触发器</a>)、<a href="https://zh.wikipedia.org/w/index.php?title=级联回滚&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">级联回滚</a>等。</li><li><strong>隔离性</strong> Isolation ：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li><strong>持久性</strong> Durability ：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ol><h2 id="列举-Spring-支持的事务管理类型？"><a href="#列举-Spring-支持的事务管理类型？" class="headerlink" title="列举 Spring 支持的事务管理类型？"></a>列举 Spring 支持的事务管理类型？</h2><p>目前 Spring 提供两种类型的事务管理：</p><ul><li><strong>声明式</strong> 事务：通过使用注解或基于 XML 的配置事务，从而事务管理与业务代码分离。</li><li><strong>编程式</strong> 事务：通过编码的方式实现事务管理，需要在代码中显式的调用事务的获得、提交、回滚。它为您提供极大的灵活性，但维护起来非常困难。</li></ul><h4 id="为什么在-Spring-事务中不能切换数据源？"><a href="#为什么在-Spring-事务中不能切换数据源？" class="headerlink" title="为什么在 Spring 事务中不能切换数据源？"></a>为什么在 Spring 事务中不能切换数据源？</h4><p>做 Spring 多数据源都会有个惨痛的经历，为什么在开启事务的 Service 层的方法中，无法切换数据源呢？因为，在 Spring 的事务管理中，<strong>所使用的数据库连接会和当前线程所绑定</strong>，即使我们设置了另外一个数据源，使用的还是当前的数据源连接。</p><p>另外，多个数据源且需要事务的场景，本身会带来<strong>多事务一致性</strong>的问题，暂时没有特别好的解决方案。</p><p>所以一般一个应用，推荐除非了读写分离所带来的多数据源，其它情况下，建议只有一个数据源。并且，随着微服务日益身形，一个服务对应一个 DB 是比较常见的架构选择。</p><h4 id="Transactional-注解有哪些属性？如何使用？"><a href="#Transactional-注解有哪些属性？如何使用？" class="headerlink" title="@Transactional 注解有哪些属性？如何使用？"></a>@Transactional 注解有哪些属性？如何使用？</h4><p><code>@Transactional</code> 注解的<strong>属性</strong>如下：</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">value</td><td style="text-align:left">String</td><td style="text-align:left">可选的限定描述符，指定使用的事务管理器</td></tr><tr><td style="text-align:left">propagation</td><td style="text-align:left">enum: Propagation</td><td style="text-align:left">可选的事务传播行为设置</td></tr><tr><td style="text-align:left">isolation</td><td style="text-align:left">enum: Isolation</td><td style="text-align:left">可选的事务隔离级别设置</td></tr><tr><td style="text-align:left">readOnly</td><td style="text-align:left">boolean</td><td style="text-align:left">读写或只读事务，默认读写</td></tr><tr><td style="text-align:left">timeout</td><td style="text-align:left">int (in seconds granularity)</td><td style="text-align:left">事务超时时间设置</td></tr><tr><td style="text-align:left">rollbackFor</td><td style="text-align:left">Class对象数组，必须继承自Throwable</td><td style="text-align:left">导致事务回滚的异常类数组</td></tr><tr><td style="text-align:left">rollbackForClassName</td><td style="text-align:left">类名数组，必须继承自Throwable</td><td style="text-align:left">导致事务回滚的异常类名字数组</td></tr><tr><td style="text-align:left">noRollbackFor</td><td style="text-align:left">Class对象数组，必须继承自Throwable</td><td style="text-align:left">不会导致事务回滚的异常类数组</td></tr><tr><td style="text-align:left">noRollbackForClassName</td><td style="text-align:left">类名数组，必须继承自Throwable</td><td style="text-align:left">不会导致事务回滚的异常类名字数组</td></tr></tbody></table><ul><li>一般情况下，我们直接使用 <code>@Transactional</code> 的所有属性默认值即可。</li></ul><p>具体<strong>用法</strong>如下：</p><ul><li><code>@Transactional</code> 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 <code>public</code> 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</li><li>虽然 <code>@Transactional</code> 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， <strong><code>@Transactional</code> 注解应该只被应用到 <code>public</code> 方法上，这是由 Spring AOP 的本质决定的</strong>。如果你在 <code>protected</code>、<code>private</code> 或者默认可见性的方法上使用 <code>@Transactional</code> 注解，这将被忽略，也不会抛出任何异常。<strong>这一点，非常需要注意</strong>。  </li></ul><p>下面，我们来简单说下<strong>源码</strong>相关的东西。</p><p><code>@Transactional</code> 注解的属性，会解析成 <code>org.springframework.transaction.TransactionDefinition</code> 对象，即事务定义。TransactionDefinition 代码如下：</p><pre class="line-numbers language-Java"><code class="language-Java">public interface TransactionDefinition {    int getPropagationBehavior(); // 事务的传播行为    int getIsolationLevel(); // 事务的隔离级别    int getTimeout(); // 事务的超时时间    boolean isReadOnly(); // 事务是否只读    @Nullable    String getName(); // 事务的名字}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可能会胖友有疑惑，<code>@Transactional</code> 注解的 <code>rollbackFor</code>、<code>rollbackForClassName</code>、<code>noRollbackFor</code>、<code>noRollbackForClassName</code> 属性貌似没体现出来？它们提现在 TransactionDefinition 的实现类 RuleBasedTransactionAttribute 中。</li><li><code>#getPropagationBehavior()</code> 方法，返回事务的<strong>传播行为</strong>，该值是个枚举，在下面来说。</li><li><code>#getIsolationLevel()</code> 方法，返回事务的<strong>隔离级别</strong>，该值是个枚举，在下面来说。</li></ul><h4 id="什么是事务的隔离级别？分成哪些隔离级别？"><a href="#什么是事务的隔离级别？分成哪些隔离级别？" class="headerlink" title="什么是事务的隔离级别？分成哪些隔离级别？"></a>什么是事务的隔离级别？分成哪些隔离级别？</h4><p>另外，有一点非常重要，不同数据库对四个隔离级别的支持和实现略有不同。因为我们目前互联网主要使用 MySQL 为主，所以至少要搞懂 MySQL 对隔离级别的支持和实现情况。</p><p>在 TransactionDefinition 接口中，定义了“<strong>四种</strong>”的隔离级别枚举。代码如下：</p><pre class="line-numbers language-Java"><code class="language-Java">// TransactionDefinition.java/** * 【Spring 独有】使用后端数据库默认的隔离级别 * * MySQL 默认采用的 REPEATABLE_READ隔离级别 * Oracle 默认采用的 READ_COMMITTED隔离级别 */int ISOLATION_DEFAULT = -1;/** * 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读 */int ISOLATION_READ_UNCOMMITTED = Connection.TRANSACTION_READ_UNCOMMITTED;/** * 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生 */int ISOLATION_READ_COMMITTED = Connection.TRANSACTION_READ_COMMITTED;/** * 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 */int ISOLATION_REPEATABLE_READ = Connection.TRANSACTION_REPEATABLE_READ;/** * 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 * * 但是这将严重影响程序的性能。通常情况下也不会用到该级别。 */int ISOLATION_SERIALIZABLE = Connection.TRANSACTION_SERIALIZABLE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="什么是事务的传播级别？分成哪些传播级别？"><a href="#什么是事务的传播级别？分成哪些传播级别？" class="headerlink" title="什么是事务的传播级别？分成哪些传播级别？"></a>什么是事务的传播级别？分成哪些传播级别？</h4><p>事务的<strong>传播行为</strong>，指的是当前带有事务配置的方法，需要怎么处理事务。</p><ul><li><p>例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p></li><li><p>有一点需要注意，事务的传播级别，并不是数据库事务规范中的名词，<strong>而是 Spring 自身所定义的</strong>。通过事务的传播级别，Spring 才知道如何处理事务，是创建一个新事务呢，还是继续使用当前的事务。</p><blockquote><p>艿艿的自我吐槽：是不是有种背概念背的想哭</p></blockquote></li></ul><p>在 TransactionDefinition 接口中，定义了<strong>三类七种</strong>传播级别。代码如下：</p><pre><code>// TransactionDefinition.java// ========== 支持当前事务的情况 ========== /** * 如果当前存在事务，则使用该事务。 * 如果当前没有事务，则创建一个新的事务。 */int PROPAGATION_REQUIRED = 0;/** * 如果当前存在事务，则使用该事务。 * 如果当前没有事务，则以非事务的方式继续运行。 */int PROPAGATION_SUPPORTS = 1;/** * 如果当前存在事务，则使用该事务。 * 如果当前没有事务，则抛出异常。 */int PROPAGATION_MANDATORY = 2;// ========== 不支持当前事务的情况 ========== /** * 创建一个新的事务。 * 如果当前存在事务，则把当前事务挂起。 */int PROPAGATION_REQUIRES_NEW = 3;/** * 以非事务方式运行。 * 如果当前存在事务，则把当前事务挂起。 */int PROPAGATION_NOT_SUPPORTED = 4;/** * 以非事务方式运行。 * 如果当前存在事务，则抛出异常。 */int PROPAGATION_NEVER = 5;// ========== 其他情况 ========== /** * 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行。 * 如果当前没有事务，则等价于 {@link TransactionDefinition#PROPAGATION_REQUIRED} */int PROPAGATION_NESTED = 6;</code></pre><ul><li><p>分类之后，其实还是比较好记的。当然，绝大数场景，我们只用 <code>PROPAGATION_REQUIRED</code> 传播级别。</p></li><li><p>这里需要指出的是，前面的六种事务传播行为是 Spring 从 EJB 中引入的，他们共享相同的概念。而</p></li></ul><pre><code>  PROPAGATION_NESTED</code></pre><p>  是 Spring 所特有的。</p><ul><li>以 <code>PROPAGATION_NESTED</code> 启动的事务内嵌于外部事务中（如果存在外部事务的话），此时，内嵌事务并不是一个独立的事务，它依赖于外部事务的存在，只有通过外部的事务提交，才能引起内部事务的提交，嵌套的子事务不能单独提交。如果熟悉 JDBC 中的保存点（SavePoint）的概念，那嵌套事务就很容易理解了，其实嵌套的子事务就是保存点的一个应用，一个事务中可以包括多个保存点，每一个嵌套子事务。另外，外部事务的回滚也会导致嵌套子事务的回滚。</li></ul><h2 id="什么是事务的超时属性？"><a href="#什么是事务的超时属性？" class="headerlink" title="什么是事务的超时属性？"></a>什么是事务的超时属性？</h2><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。</p><p>在 TransactionDefinition 中以 <code>int</code> 的值来表示超时时间，其单位是秒。</p><h2 id="什么是事务的只读属性？"><a href="#什么是事务的只读属性？" class="headerlink" title="什么是事务的只读属性？"></a>什么是事务的只读属性？</h2><p>事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。</p><ul><li>所谓事务性资源就是指那些被事务管理的资源，比如数据源、JMS 资源，以及自定义的事务性资源等等。</li><li>如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。感兴趣的胖友，可以看看 <a href="https://my.oschina.net/uniquejava/blog/80954" target="_blank" rel="noopener">《不使用事务和使用只读事务的区别 》</a> 。</li></ul><p>在 TransactionDefinition 中以 <code>boolean</code> 类型来表示该事务是否只读。</p><h2 id="什么是事务的回滚规则？"><a href="#什么是事务的回滚规则？" class="headerlink" title="什么是事务的回滚规则？"></a>什么是事务的回滚规则？</h2><p>回滚规则，定义了哪些异常会导致事务回滚而哪些不会。</p><ul><li>默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。</li><li>但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</li></ul><p>注意，事务的回滚规则，并不是数据库事务规范中的名词，<strong>而是 Spring 自身所定义的</strong>。</p><h2 id="简单介绍-TransactionStatus-？"><a href="#简单介绍-TransactionStatus-？" class="headerlink" title="简单介绍 TransactionStatus ？"></a>简单介绍 TransactionStatus ？</h2><blockquote><p>艿艿：这个可能不是一个面试题，主要满足下大家的好奇心。</p></blockquote><p>TransactionStatus 接口，记录事务的状态，不仅仅包含事务本身，还包含事务的其它信息。代码如下：</p><pre><code>// TransactionStatus.javapublic interface TransactionStatus extends SavepointManager, Flushable {    /**     * 是否是新创建的事务     */    boolean isNewTransaction();    /**     * 是否有 Savepoint     *     * 在 {@link TransactionDefinition#PROPAGATION_NESTED} 传播级别使用。     */    boolean hasSavepoint();    /**     * 设置为只回滚     */    void setRollbackOnly();    /**     * 是否为只回滚     */    boolean isRollbackOnly();    /**     * 执行 flush 操作     */    @Override    void flush();    /**     * 是否事务已经完成     */    boolean isCompleted();}</code></pre><ul><li>为什么没有事务对象呢？在 TransactionStatus 的实现类 DefaultTransactionStatus 中，有个 <code>Object transaction</code> 属性，表示事务对象。</li><li><code>#isNewTransaction()</code> 方法，表示是否是新创建的事务。有什么用呢？我们对 <code>#commit(TransactionStatus status)</code> 方法的解释。通过该方法，我们可以判断，当前事务是否当前方法所创建的，只有创建事务的方法，<strong>才能且应该真正的提交事务</strong>。</li></ul><h2 id="使用-Spring-事务有什么优点？"><a href="#使用-Spring-事务有什么优点？" class="headerlink" title="使用 Spring 事务有什么优点？"></a>使用 Spring 事务有什么优点？</h2><ol><li>通过 PlatformTransactionManager ，为不同的数据层持久框架提供统一的 API ，无需关心到底是原生 JDBC、Spring JDBC、JPA、Hibernate 还是 MyBatis 。</li><li>通过使用声明式事务，使业务代码和事务管理的逻辑分离，更加清晰。</li></ol><h1 id="Spring-Data-Access"><a href="#Spring-Data-Access" class="headerlink" title="Spring Data Access"></a>Spring Data Access</h1><blockquote><p>艿艿：这块的问题，感觉面试问的不多，至少我很少问。哈哈哈。就当做下了解，万一问了呢。</p></blockquote><h2 id="Spring-支持哪些-ORM-框架？"><a href="#Spring-支持哪些-ORM-框架？" class="headerlink" title="Spring 支持哪些 ORM 框架？"></a>Spring 支持哪些 ORM 框架？</h2><ul><li>Hibernate</li><li>JPA</li><li>MyBatis</li><li><a href="https://docs.spring.io/spring/docs/3.0.0.M4/reference/html/ch13s04.html" target="_blank" rel="noopener">JDO</a></li><li><a href="https://db.apache.org/ojb/docu/howtos/howto-use-spring.html" target="_blank" rel="noopener">OJB</a></li></ul><p>可能会有胖友说，不是应该还有 Spring JDBC 吗。注意，Spring JDBC 不是 ORM 框架。</p><h2 id="在-Spring-框架中如何更有效地使用-JDBC-？"><a href="#在-Spring-框架中如何更有效地使用-JDBC-？" class="headerlink" title="在 Spring 框架中如何更有效地使用 JDBC ？"></a>在 Spring 框架中如何更有效地使用 JDBC ？</h2><p>Spring 提供了 Spring JDBC 框架，方便我们使用 JDBC 。</p><p>对于开发者，只需要使用 JdbcTemplate 类，它提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p><h2 id="使用-Spring-访问-Hibernate-的方法有哪些？。"><a href="#使用-Spring-访问-Hibernate-的方法有哪些？。" class="headerlink" title="使用 Spring 访问 Hibernate 的方法有哪些？。"></a>使用 Spring 访问 Hibernate 的方法有哪些？。</h2><p>我们可以通过两种方式使用 Spring 访问 Hibernate：</p><ul><li>使用 Hibernate 模板和回调进行控制反转。</li><li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring总结</title>
      <link href="/2019/11/15/Spring%20AOP/"/>
      <url>/2019/11/15/Spring%20AOP/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring-注解"><a href="#Spring-注解" class="headerlink" title="Spring 注解"></a>Spring 注解</h3><h4 id="什么是基于注解的容器配置？"><a href="#什么是基于注解的容器配置？" class="headerlink" title="什么是基于注解的容器配置？"></a>什么是基于注解的容器配置？</h4><p>不使用 XML 来描述 Bean 装配，开发人员通过在相关的类，方法或字段声明上使用<strong>注解</strong>将配置移动到组件类本身。它可以作为 XML 设置的替代方案。例如：</p><p>Spring 的 Java 配置是通过使用 <code>@Bean</code> 和 <code>@Configuration</code> 来实现。</p><ul><li><code>@Bean</code> 注解，与 <code>&lt;bean /&gt;</code> 元素相同。</li><li><code>@Configuration</code> 注解的类，允许通过简单地调用同一个类中的其他 <code>@Bean</code> 方法来定义 Bean 间依赖关系。</li></ul><p>示例如下：</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">@Configurationpublic class StudentConfig {    @Bean    public StudentBean myStudent() {        return new StudentBean();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="如何在-Spring-中启动注解装配？"><a href="#如何在-Spring-中启动注解装配？" class="headerlink" title="如何在 Spring 中启动注解装配？"></a>如何在 Spring 中启动注解装配？</h4><p>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置 <code>&lt;context：annotation-config /&gt;</code> 元素在 Spring 配置文件中启用它。</p><p>当然，如果是使用 Spring Boot ，默认情况下已经开启。</p><h4 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h4><ul><li><code>@Component</code> ：它将 Java 类标记为 Bean 。它是任何 Spring 管理组件的<strong>通用</strong>构造型。</li><li><code>@Controller</code> ：它将一个类标记为 Spring Web MVC <strong>控制器</strong>。</li><li><code>@Service</code> ：此注解是组件注解的特化。它不会对 <code>@Component</code> 注解提供任何其他行为。您可以在<strong>服务层</strong>类中使用 @Service 而不是 <code>@Component</code> ，因为它以更好的方式指定了意图。</li><li><code>@Repository</code> ：这个注解是具有类似用途和功能的 <code>@Component</code> 注解的特化。它为 <strong>DAO</strong> 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException 。</li></ul><h2 id="Required-注解有什么用？"><a href="#Required-注解有什么用？" class="headerlink" title="@Required 注解有什么用？"></a>@Required 注解有什么用？</h2><p><code>@Required</code> 注解，应用于 Bean 属性 setter 方法。</p><ul><li>此注解仅指示必须在配置时使用 Bean 定义中的显式属性值或使用自动装配填充受影响的 Bean 属性。</li><li>如果尚未填充受影响的 Bean 属性，则容器将抛出 BeanInitializationException 异常。</li></ul><p>示例代码如下：</p><pre class="line-numbers language-Java"><code class="language-Java">public class Employee {    private String name;    @Required    public void setName(String name){        this.name=name;    }    public string getName(){        return name;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Autowired-注解有什么用？"><a href="#Autowired-注解有什么用？" class="headerlink" title="@Autowired 注解有什么用？"></a>@Autowired 注解有什么用？</h4><p><code>@Autowired</code> 注解，可以更准确地控制应该在何处以及如何进行自动装配。</p><ul><li>此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 Bean。</li><li>默认情况下，它是类型驱动的注入。</li></ul><p>示例代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EmpAccount</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> Employee emp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Qualifier-注解有什么用？"><a href="#Qualifier-注解有什么用？" class="headerlink" title="@Qualifier 注解有什么用？"></a>@Qualifier 注解有什么用？</h4><p>当你创建多个<strong>相同类型</strong>的 Bean ，并希望仅使用属性装配<strong>其中一个</strong> Bean 时，可以使用 <code>@Qualifier</code> 注解和 <code>@Autowired</code> 注解通过指定 ID 应该装配哪个<strong>确切的</strong> Bean 来消除歧义。</p><p>例如，应用中有两个类型为 Employee(可能实现了同一个接口) 的 Bean ID 为 <code>&quot;emp1&quot;</code> 和 <code>&quot;emp2&quot;</code> ，此处，我们希望 EmployeeAccount Bean 注入 <code>&quot;emp1&quot;</code> 对应的 Bean 对象。代码如下：</p><pre class="line-numbers language-Java"><code class="language-Java">public class EmployeeAccount {    @Autowired    @Qualifier(emp1)    private Employee emp;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><blockquote><p>概念点主要有：</p><ul><li>AOP</li><li>Aspect</li><li>JoinPoint</li><li>PointCut</li><li>Advice</li><li>Target</li><li>AOP Proxy</li><li>Weaving</li></ul></blockquote><p>非常推荐阅读如下两篇文章：</p><ul><li><a href="https://segmentfault.com/a/1190000007469968" target="_blank" rel="noopener">《彻底征服 Spring AOP 之理论篇》</a></li><li><a href="https://segmentfault.com/a/1190000007469982" target="_blank" rel="noopener">《彻底征服 Spring AOP 之实战篇》</a></li></ul><h4 id="什么是-AOP-？"><a href="#什么是-AOP-？" class="headerlink" title="什么是 AOP ？"></a>什么是 AOP ？</h4><p>AOP(Aspect-Oriented Programming)，即<strong>面向切面编程</strong>, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成， 提供了与 OOP 不同的抽象软件结构的视角。</p><ul><li>在 OOP 中，以类( Class )作为基本单元</li><li>在 AOP 中，以<strong>切面( Aspect )</strong>作为基本单元。</li></ul><h4 id="什么是-Aspect-？"><a href="#什么是-Aspect-？" class="headerlink" title="什么是 Aspect ？"></a>什么是 Aspect ？</h4><p>Aspect 由 <strong>PointCut</strong> 和 <strong>Advice</strong> 组成。</p><ul><li>它既包含了横切逻辑的定义，也包括了连接点的定义。</li><li>Spring AOP 就是负责实施切面的框架，它将切面所定义的横切逻辑编织到切面所指定的连接点中。</li></ul><p>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p><ol><li>如何通过 PointCut 和 Advice 定位到特定的 <strong>JoinPoint</strong> 上。</li><li>如何在 Advice 中编写切面代码。</li></ol><p><strong>可以简单地认为, 使用 @Aspect 注解的类就是切面</strong></p><h2 id="什么是-JoinPoint"><a href="#什么是-JoinPoint" class="headerlink" title="什么是 JoinPoint ?"></a>什么是 JoinPoint ?</h2><p>JoinPoint ，<strong>切点</strong>，程序运行中的一些时间点, 例如：</p><ul><li>一个方法的执行。</li><li>或者是一个异常的处理。</li></ul><p>在 Spring AOP 中，JoinPoint 总是方法的执行点。</p><h2 id="什么是-PointCut-？"><a href="#什么是-PointCut-？" class="headerlink" title="什么是 PointCut ？"></a>什么是 PointCut ？</h2><p>PointCut ，<strong>匹配</strong> JoinPoint 的谓词(a predicate that matches join points)。</p><blockquote><p>简单来说，PointCut 是匹配 JoinPoint 的条件。</p></blockquote><ul><li>Advice 是和特定的 PointCut 关联的，并且在 PointCut 相匹配的 JoinPoint 中执行。即 <code>Advice =&gt; PointCut =&gt; JoinPoint</code> 。</li><li>在 Spring 中, 所有的方法都可以认为是 JoinPoint ，但是我们并不希望在所有的方法上都添加 Advice 。<strong>而 PointCut 的作用</strong>，就是提供一组规则(使用 AspectJ PointCut expression language 来描述) 来匹配 JoinPoint ，给满足规则的 JoinPoint 添加 Advice 。</li></ul><h2 id="关于-JoinPoint-和-PointCut-的区别"><a href="#关于-JoinPoint-和-PointCut-的区别" class="headerlink" title="关于 JoinPoint 和 PointCut 的区别"></a>关于 JoinPoint 和 PointCut 的区别</h2><p>JoinPoint 和 PointCut 本质上就是<strong>两个不同纬度上</strong>的东西。</p><ul><li>在 Spring AOP 中，所有的方法执行都是 JoinPoint 。而 PointCut 是一个描述信息，它修饰的是 JoinPoint ，通过 PointCut ，我们就可以确定哪些 JoinPoint 可以被织入 Advice 。</li><li>Advice 是在 JoinPoint 上执行的，而 PointCut 规定了哪些 JoinPoint 可以执行哪些 Advice 。</li></ul><p>或者，我们在换一种说法：</p><ol><li>首先，Advice 通过 PointCut 查询需要被织入的 JoinPoint 。</li><li>然后，Advice 在查询到 JoinPoint 上执行逻辑。</li></ol><h2 id="什么是-Advice-？"><a href="#什么是-Advice-？" class="headerlink" title="什么是 Advice ？"></a>什么是 Advice ？</h2><p>Advice ，<strong>通知</strong>。</p><ul><li>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice 。</li><li>Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的<strong>拦截器</strong>。</li></ul><p><strong>有哪些类型的 Advice？</strong></p><ul><li>Before - 这些类型的 Advice 在 JoinPoint 方法之前执行，并使用 <code>@Before</code> 注解标记进行配置。</li><li>After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用 <code>@AfterReturning</code> 注解标记进行配置。</li><li>After Throwing - 这些类型的 Advice 仅在 JoinPoint 方法通过抛出异常退出并使用 <code>@AfterThrowing</code> 注解标记配置时执行。</li><li>After Finally - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 <code>@After</code> 注解标记进行配置。</li><li>Around - 这些类型的 Advice 在连接点之前和之后执行，并使用 <code>@Around</code> 注解标记进行配置。</li></ul><h2 id="什么是-Target-？"><a href="#什么是-Target-？" class="headerlink" title="什么是 Target ？"></a>什么是 Target ？</h2><p>Target ，织入 Advice 的<strong>目标对象</strong>。目标对象也被称为 <strong>Advised Object</strong> 。</p><ul><li>因为 Spring AOP 使用运行时代理的方式来实现 Aspect ，因此 Advised Object 总是一个代理对象(Proxied Object) 。</li><li><strong>注意, Advised Object 指的不是原来的对象，而是织入 Advice 后所产生的代理对象</strong>。</li><li>Advice + Target Object = Advised Object = Proxy 。</li></ul><h4 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h4><p>实现 AOP 的技术，主要分为两大类：</p><ol><li><p><strong>静态代理</strong> - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强。</p><ul><li><p>编译时编织（特殊编译器实现）</p></li><li><p>类加载时编织（特殊的类加载器实现）。</p><blockquote><p>例如，SkyWalking 基于 Java Agent 机制，配置上 ByteBuddy 库，实现类加载时编织时增强，从而实现链路追踪的透明埋点。</p></blockquote></li></ul></li><li><p><strong>动态代理</strong> - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。目前 Spring 中使用了两种动态代理库：</p><ul><li>JDK 动态代理</li><li>CGLIB<br>那么 Spring 什么时候使用 JDK 动态代理，什么时候使用 CGLIB 呢？   </li></ul></li></ol><pre><code>// From 《Spring 源码深度解析》P172// Spring AOP 部分使用 JDK 动态代理或者 CGLIB 来为目标对象创建代理。（建议尽量使用 JDK 的动态代理）// 如果被代理的目标对象实现了至少一个接口，则会使用 JDK 动态代理。所有该目标类型实现的接口都讲被代理。// 若该目标对象没有实现任何接口，则创建一个 CGLIB 代理。// 如果你希望强制使用 CGLIB 代理，（例如希望代理目标对象的所有方法，而不只是实现自接口的方法）那也可以。但是需要考虑以下两个方法：//      1&gt; 无法通知(advise) Final 方法，因为它们不能被覆盖。//      2&gt; 你需要将 CGLIB 二进制发型包放在 classpath 下面。// 为什么 Spring 默认使用 JDK 的动态代理呢？笔者猜测原因如下：//      1&gt; 使用 JDK 原生支持，减少三方依赖//      2&gt; JDK8 开始后，JDK 代理的性能差距 CGLIB 的性能不会太多。可参见：https://www.cnblogs.com/haiq/p/4304615.html</code></pre><p>Spring AOP 中的动态代理主要有两种方式，</p><ul><li><p>JDK 动态代理</p><p>JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是 InvocationHandler 接口和 Proxy 类。</p></li><li><p>CGLIB 动态代理</p><p>如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。当然，Spring 也支持配置，<strong>强制</strong> 使用 CGLIB 动态代理。<br>CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 <code>final</code> ，那么它是无法使用 CGLIB 做动态代理的。</p></li></ul><h4 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h4><ul><li>代理方式不同<ul><li>Spring AOP 基于动态代理方式实现。</li><li>AspectJ AOP 基于静态代理方式实现。</li></ul></li><li>PointCut 支持力度不同<ul><li>Spring AOP <strong>仅</strong> 支持方法级别的 PointCut 。</li><li>AspectJ AOP 提供了完全的 AOP 支持，它还支持属性级别的 PointCut 。</li></ul></li></ul><h4 id="什么是编织（Weaving）？"><a href="#什么是编织（Weaving）？" class="headerlink" title="什么是编织（Weaving）？"></a>什么是编织（Weaving）？</h4><p>Weaving ，<strong>编织</strong>。</p><ul><li>为了创建一个 Advice 对象而链接一个 Aspect 和其它应用类型或对象，称为编织（Weaving）。</li><li>在 Spring AOP 中，编织在运行时执行，即动态代理。请参考下图：[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://static2.iocoder.cn/images/Spring/2018-12-24/05.jpg" alt="Proxy](http://static2.iocoder.cn/images/Spring/2018-12-24/05.jpg)" title="">                </div>                <div class="image-caption">Proxy](http://static2.iocoder.cn/images/Spring/2018-12-24/05.jpg)</div>            </figure>Proxy</li></ul><h2 id="Spring-如何使用-AOP-切面？"><a href="#Spring-如何使用-AOP-切面？" class="headerlink" title="Spring 如何使用 AOP 切面？"></a>Spring 如何使用 AOP 切面？</h2><p>在 Spring AOP 中，有两种方式配置 AOP 切面：</p><ul><li>基于 <strong>XML</strong> 方式的切面实现。</li><li>基于 <strong>注解</strong> 方式的切面实现。</li></ul><p>目前，主流喜欢使用 <strong>注解</strong> 方式。</p><h1 id="Spring-Transaction"><a href="#Spring-Transaction" class="headerlink" title="Spring Transaction"></a>Spring Transaction</h1><p>非常推荐阅读如下文章：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;mid=2247484702&amp;idx=1&amp;sn=c04261d63929db09ff6df7cadc7cca21&amp;chksm=fa497aafcd3ef3b94082da7bca841b5b7b528eb2a52dbc4eb647b97be63a9a1cf38a9e71bf90&amp;token=165108535&amp;lang=zh_CN#rd" target="_blank" rel="noopener">《可能是最漂亮的 Spring 事务管理详解》</a></li></ul><h4 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h4><p>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。</p><p>这样可以防止出现脏数据，防止数据库数据出现问题。</p><h4 id="事务的特性指的是？"><a href="#事务的特性指的是？" class="headerlink" title="事务的特性指的是？"></a>事务的特性指的是？</h4><p>指的是 <strong>ACID</strong> ，</p><ol><li><strong>原子性</strong> Atomicity ：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li><li><strong>一致性</strong> Consistency ：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设<a href="https://zh.wikipedia.org/wiki/数据完整性" target="_blank" rel="noopener">约束</a>、<a href="https://zh.wikipedia.org/wiki/触发器_(数据库" target="_blank" rel="noopener">触发器</a>)、<a href="https://zh.wikipedia.org/w/index.php?title=级联回滚&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">级联回滚</a>等。</li><li><strong>隔离性</strong> Isolation ：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li><strong>持久性</strong> Durability ：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ol><h2 id="列举-Spring-支持的事务管理类型？"><a href="#列举-Spring-支持的事务管理类型？" class="headerlink" title="列举 Spring 支持的事务管理类型？"></a>列举 Spring 支持的事务管理类型？</h2><p>目前 Spring 提供两种类型的事务管理：</p><ul><li><strong>声明式</strong> 事务：通过使用注解或基于 XML 的配置事务，从而事务管理与业务代码分离。</li><li><strong>编程式</strong> 事务：通过编码的方式实现事务管理，需要在代码中显式的调用事务的获得、提交、回滚。它为您提供极大的灵活性，但维护起来非常困难。</li></ul><h4 id="为什么在-Spring-事务中不能切换数据源？"><a href="#为什么在-Spring-事务中不能切换数据源？" class="headerlink" title="为什么在 Spring 事务中不能切换数据源？"></a>为什么在 Spring 事务中不能切换数据源？</h4><p>做 Spring 多数据源都会有个惨痛的经历，为什么在开启事务的 Service 层的方法中，无法切换数据源呢？因为，在 Spring 的事务管理中，<strong>所使用的数据库连接会和当前线程所绑定</strong>，即使我们设置了另外一个数据源，使用的还是当前的数据源连接。</p><p>另外，多个数据源且需要事务的场景，本身会带来<strong>多事务一致性</strong>的问题，暂时没有特别好的解决方案。</p><p>所以一般一个应用，推荐除非了读写分离所带来的多数据源，其它情况下，建议只有一个数据源。并且，随着微服务日益身形，一个服务对应一个 DB 是比较常见的架构选择。</p><h4 id="Transactional-注解有哪些属性？如何使用？"><a href="#Transactional-注解有哪些属性？如何使用？" class="headerlink" title="@Transactional 注解有哪些属性？如何使用？"></a>@Transactional 注解有哪些属性？如何使用？</h4><p><code>@Transactional</code> 注解的<strong>属性</strong>如下：</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">value</td><td style="text-align:left">String</td><td style="text-align:left">可选的限定描述符，指定使用的事务管理器</td></tr><tr><td style="text-align:left">propagation</td><td style="text-align:left">enum: Propagation</td><td style="text-align:left">可选的事务传播行为设置</td></tr><tr><td style="text-align:left">isolation</td><td style="text-align:left">enum: Isolation</td><td style="text-align:left">可选的事务隔离级别设置</td></tr><tr><td style="text-align:left">readOnly</td><td style="text-align:left">boolean</td><td style="text-align:left">读写或只读事务，默认读写</td></tr><tr><td style="text-align:left">timeout</td><td style="text-align:left">int (in seconds granularity)</td><td style="text-align:left">事务超时时间设置</td></tr><tr><td style="text-align:left">rollbackFor</td><td style="text-align:left">Class对象数组，必须继承自Throwable</td><td style="text-align:left">导致事务回滚的异常类数组</td></tr><tr><td style="text-align:left">rollbackForClassName</td><td style="text-align:left">类名数组，必须继承自Throwable</td><td style="text-align:left">导致事务回滚的异常类名字数组</td></tr><tr><td style="text-align:left">noRollbackFor</td><td style="text-align:left">Class对象数组，必须继承自Throwable</td><td style="text-align:left">不会导致事务回滚的异常类数组</td></tr><tr><td style="text-align:left">noRollbackForClassName</td><td style="text-align:left">类名数组，必须继承自Throwable</td><td style="text-align:left">不会导致事务回滚的异常类名字数组</td></tr></tbody></table><ul><li>一般情况下，我们直接使用 <code>@Transactional</code> 的所有属性默认值即可。</li></ul><p>具体<strong>用法</strong>如下：</p><ul><li><code>@Transactional</code> 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 <code>public</code> 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</li><li>虽然 <code>@Transactional</code> 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， <strong><code>@Transactional</code> 注解应该只被应用到 <code>public</code> 方法上，这是由 Spring AOP 的本质决定的</strong>。如果你在 <code>protected</code>、<code>private</code> 或者默认可见性的方法上使用 <code>@Transactional</code> 注解，这将被忽略，也不会抛出任何异常。<strong>这一点，非常需要注意</strong>。  </li></ul><p>下面，我们来简单说下<strong>源码</strong>相关的东西。</p><p><code>@Transactional</code> 注解的属性，会解析成 <code>org.springframework.transaction.TransactionDefinition</code> 对象，即事务定义。TransactionDefinition 代码如下：</p><pre class="line-numbers language-Java"><code class="language-Java">public interface TransactionDefinition {    int getPropagationBehavior(); // 事务的传播行为    int getIsolationLevel(); // 事务的隔离级别    int getTimeout(); // 事务的超时时间    boolean isReadOnly(); // 事务是否只读    @Nullable    String getName(); // 事务的名字}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可能会胖友有疑惑，<code>@Transactional</code> 注解的 <code>rollbackFor</code>、<code>rollbackForClassName</code>、<code>noRollbackFor</code>、<code>noRollbackForClassName</code> 属性貌似没体现出来？它们提现在 TransactionDefinition 的实现类 RuleBasedTransactionAttribute 中。</li><li><code>#getPropagationBehavior()</code> 方法，返回事务的<strong>传播行为</strong>，该值是个枚举，在下面来说。</li><li><code>#getIsolationLevel()</code> 方法，返回事务的<strong>隔离级别</strong>，该值是个枚举，在下面来说。</li></ul><h4 id="什么是事务的隔离级别？分成哪些隔离级别？"><a href="#什么是事务的隔离级别？分成哪些隔离级别？" class="headerlink" title="什么是事务的隔离级别？分成哪些隔离级别？"></a>什么是事务的隔离级别？分成哪些隔离级别？</h4><p>另外，有一点非常重要，不同数据库对四个隔离级别的支持和实现略有不同。因为我们目前互联网主要使用 MySQL 为主，所以至少要搞懂 MySQL 对隔离级别的支持和实现情况。</p><p>在 TransactionDefinition 接口中，定义了“<strong>四种</strong>”的隔离级别枚举。代码如下：</p><pre class="line-numbers language-Java"><code class="language-Java">// TransactionDefinition.java/** * 【Spring 独有】使用后端数据库默认的隔离级别 * * MySQL 默认采用的 REPEATABLE_READ隔离级别 * Oracle 默认采用的 READ_COMMITTED隔离级别 */int ISOLATION_DEFAULT = -1;/** * 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读 */int ISOLATION_READ_UNCOMMITTED = Connection.TRANSACTION_READ_UNCOMMITTED;/** * 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生 */int ISOLATION_READ_COMMITTED = Connection.TRANSACTION_READ_COMMITTED;/** * 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 */int ISOLATION_REPEATABLE_READ = Connection.TRANSACTION_REPEATABLE_READ;/** * 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 * * 但是这将严重影响程序的性能。通常情况下也不会用到该级别。 */int ISOLATION_SERIALIZABLE = Connection.TRANSACTION_SERIALIZABLE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="什么是事务的传播级别？分成哪些传播级别？"><a href="#什么是事务的传播级别？分成哪些传播级别？" class="headerlink" title="什么是事务的传播级别？分成哪些传播级别？"></a>什么是事务的传播级别？分成哪些传播级别？</h4><p>事务的<strong>传播行为</strong>，指的是当前带有事务配置的方法，需要怎么处理事务。</p><ul><li><p>例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p></li><li><p>有一点需要注意，事务的传播级别，并不是数据库事务规范中的名词，<strong>而是 Spring 自身所定义的</strong>。通过事务的传播级别，Spring 才知道如何处理事务，是创建一个新事务呢，还是继续使用当前的事务。</p><blockquote><p>艿艿的自我吐槽：是不是有种背概念背的想哭</p></blockquote></li></ul><p>在 TransactionDefinition 接口中，定义了<strong>三类七种</strong>传播级别。代码如下：</p><pre><code>// TransactionDefinition.java// ========== 支持当前事务的情况 ========== /** * 如果当前存在事务，则使用该事务。 * 如果当前没有事务，则创建一个新的事务。 */int PROPAGATION_REQUIRED = 0;/** * 如果当前存在事务，则使用该事务。 * 如果当前没有事务，则以非事务的方式继续运行。 */int PROPAGATION_SUPPORTS = 1;/** * 如果当前存在事务，则使用该事务。 * 如果当前没有事务，则抛出异常。 */int PROPAGATION_MANDATORY = 2;// ========== 不支持当前事务的情况 ========== /** * 创建一个新的事务。 * 如果当前存在事务，则把当前事务挂起。 */int PROPAGATION_REQUIRES_NEW = 3;/** * 以非事务方式运行。 * 如果当前存在事务，则把当前事务挂起。 */int PROPAGATION_NOT_SUPPORTED = 4;/** * 以非事务方式运行。 * 如果当前存在事务，则抛出异常。 */int PROPAGATION_NEVER = 5;// ========== 其他情况 ========== /** * 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行。 * 如果当前没有事务，则等价于 {@link TransactionDefinition#PROPAGATION_REQUIRED} */int PROPAGATION_NESTED = 6;</code></pre><ul><li><p>分类之后，其实还是比较好记的。当然，绝大数场景，我们只用 <code>PROPAGATION_REQUIRED</code> 传播级别。</p></li><li><p>这里需要指出的是，前面的六种事务传播行为是 Spring 从 EJB 中引入的，他们共享相同的概念。而</p></li></ul><pre><code>  PROPAGATION_NESTED</code></pre><p>  是 Spring 所特有的。</p><ul><li>以 <code>PROPAGATION_NESTED</code> 启动的事务内嵌于外部事务中（如果存在外部事务的话），此时，内嵌事务并不是一个独立的事务，它依赖于外部事务的存在，只有通过外部的事务提交，才能引起内部事务的提交，嵌套的子事务不能单独提交。如果熟悉 JDBC 中的保存点（SavePoint）的概念，那嵌套事务就很容易理解了，其实嵌套的子事务就是保存点的一个应用，一个事务中可以包括多个保存点，每一个嵌套子事务。另外，外部事务的回滚也会导致嵌套子事务的回滚。</li></ul><h2 id="什么是事务的超时属性？"><a href="#什么是事务的超时属性？" class="headerlink" title="什么是事务的超时属性？"></a>什么是事务的超时属性？</h2><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。</p><p>在 TransactionDefinition 中以 <code>int</code> 的值来表示超时时间，其单位是秒。</p><h2 id="什么是事务的只读属性？"><a href="#什么是事务的只读属性？" class="headerlink" title="什么是事务的只读属性？"></a>什么是事务的只读属性？</h2><p>事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。</p><ul><li>所谓事务性资源就是指那些被事务管理的资源，比如数据源、JMS 资源，以及自定义的事务性资源等等。</li><li>如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。感兴趣的胖友，可以看看 <a href="https://my.oschina.net/uniquejava/blog/80954" target="_blank" rel="noopener">《不使用事务和使用只读事务的区别 》</a> 。</li></ul><p>在 TransactionDefinition 中以 <code>boolean</code> 类型来表示该事务是否只读。</p><h2 id="什么是事务的回滚规则？"><a href="#什么是事务的回滚规则？" class="headerlink" title="什么是事务的回滚规则？"></a>什么是事务的回滚规则？</h2><p>回滚规则，定义了哪些异常会导致事务回滚而哪些不会。</p><ul><li>默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。</li><li>但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</li></ul><p>注意，事务的回滚规则，并不是数据库事务规范中的名词，<strong>而是 Spring 自身所定义的</strong>。</p><h2 id="简单介绍-TransactionStatus-？"><a href="#简单介绍-TransactionStatus-？" class="headerlink" title="简单介绍 TransactionStatus ？"></a>简单介绍 TransactionStatus ？</h2><blockquote><p>艿艿：这个可能不是一个面试题，主要满足下大家的好奇心。</p></blockquote><p>TransactionStatus 接口，记录事务的状态，不仅仅包含事务本身，还包含事务的其它信息。代码如下：</p><pre><code>// TransactionStatus.javapublic interface TransactionStatus extends SavepointManager, Flushable {    /**     * 是否是新创建的事务     */    boolean isNewTransaction();    /**     * 是否有 Savepoint     *     * 在 {@link TransactionDefinition#PROPAGATION_NESTED} 传播级别使用。     */    boolean hasSavepoint();    /**     * 设置为只回滚     */    void setRollbackOnly();    /**     * 是否为只回滚     */    boolean isRollbackOnly();    /**     * 执行 flush 操作     */    @Override    void flush();    /**     * 是否事务已经完成     */    boolean isCompleted();}</code></pre><ul><li>为什么没有事务对象呢？在 TransactionStatus 的实现类 DefaultTransactionStatus 中，有个 <code>Object transaction</code> 属性，表示事务对象。</li><li><code>#isNewTransaction()</code> 方法，表示是否是新创建的事务。有什么用呢？我们对 <code>#commit(TransactionStatus status)</code> 方法的解释。通过该方法，我们可以判断，当前事务是否当前方法所创建的，只有创建事务的方法，<strong>才能且应该真正的提交事务</strong>。</li></ul><h2 id="使用-Spring-事务有什么优点？"><a href="#使用-Spring-事务有什么优点？" class="headerlink" title="使用 Spring 事务有什么优点？"></a>使用 Spring 事务有什么优点？</h2><ol><li>通过 PlatformTransactionManager ，为不同的数据层持久框架提供统一的 API ，无需关心到底是原生 JDBC、Spring JDBC、JPA、Hibernate 还是 MyBatis 。</li><li>通过使用声明式事务，使业务代码和事务管理的逻辑分离，更加清晰。</li></ol><h1 id="Spring-Data-Access"><a href="#Spring-Data-Access" class="headerlink" title="Spring Data Access"></a>Spring Data Access</h1><blockquote><p>艿艿：这块的问题，感觉面试问的不多，至少我很少问。哈哈哈。就当做下了解，万一问了呢。</p></blockquote><h2 id="Spring-支持哪些-ORM-框架？"><a href="#Spring-支持哪些-ORM-框架？" class="headerlink" title="Spring 支持哪些 ORM 框架？"></a>Spring 支持哪些 ORM 框架？</h2><ul><li>Hibernate</li><li>JPA</li><li>MyBatis</li><li><a href="https://docs.spring.io/spring/docs/3.0.0.M4/reference/html/ch13s04.html" target="_blank" rel="noopener">JDO</a></li><li><a href="https://db.apache.org/ojb/docu/howtos/howto-use-spring.html" target="_blank" rel="noopener">OJB</a></li></ul><p>可能会有胖友说，不是应该还有 Spring JDBC 吗。注意，Spring JDBC 不是 ORM 框架。</p><h2 id="在-Spring-框架中如何更有效地使用-JDBC-？"><a href="#在-Spring-框架中如何更有效地使用-JDBC-？" class="headerlink" title="在 Spring 框架中如何更有效地使用 JDBC ？"></a>在 Spring 框架中如何更有效地使用 JDBC ？</h2><p>Spring 提供了 Spring JDBC 框架，方便我们使用 JDBC 。</p><p>对于开发者，只需要使用 JdbcTemplate 类，它提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p><h2 id="使用-Spring-访问-Hibernate-的方法有哪些？。"><a href="#使用-Spring-访问-Hibernate-的方法有哪些？。" class="headerlink" title="使用 Spring 访问 Hibernate 的方法有哪些？。"></a>使用 Spring 访问 Hibernate 的方法有哪些？。</h2><p>我们可以通过两种方式使用 Spring 访问 Hibernate：</p><ul><li>使用 Hibernate 模板和回调进行控制反转。</li><li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring--IoC</title>
      <link href="/2019/11/11/spring/"/>
      <url>/2019/11/11/spring/</url>
      
        <content type="html"><![CDATA[<p>spring中的IoC是一种软件开发的思想，用来降低程序间耦合的问题。在未采用IoC的开发中，上层依赖下层，某个对象需要另一个对象，只能自己采用new的方式进行创建，那么会产生以下的问题：  </p><ol><li>new的方式散落在整个工程的各个地方，如果想更换一个所需要的对象，将需要对涉及到所有的new进行修改。  </li><li>许多对象以单例的模式就可以满足业务需求，不需要每次都new一个对象，浪费资源、效率。</li></ol><p>针对以上的问题1，我们可以采用工厂模式可以解决。将一个字符串作为一个类对象的标识id，&lt;id=””, class=””&gt;，在程序中使用id进行对象的注入，id与class的关系保存在一个配置文件中（代码之外），如果需要更换所需的对象，只需要更改&lt;id=””, class=””&gt;中的class方式即可，实现了上层与所需依赖以抽象的方式(id字符串)联系起来。  </p><p>针对以上的问题2，我们可以考虑使用一个容器来管理业务中所需要的单例对象，例如使用一个map来管理工厂模式所产生的对象，而这个map就是spring中的IoC容器。  </p><p>有了上面的思路，再来说一说Spring中的一些概念。</p><ol><li>IoC之前谁控制谁，怎么控制，IoC之后谁控制谁，怎么控制<br> IoC之前，类都是通过new通过组合，完成对象的依赖，即谁需要，谁控制类的创建。IoC通过IoC容器，谁需要，IoC将所需要的对象注入到谁中。</li><li>IoC容器什么？<br>Spring的核心是 Spring IoC 容器。容器创建 Bean 对象，将它们装配在一起，配置它们并管理它们的完整生命周期。  <ul><li>Spring 容器使用依赖注入来管理组成应用程序的 Bean 对象。  </li><li>容器通过读取提供的配置元数据 Bean Definition 来接收对象进行实例化，配置和组装的指令。  </li><li>该配置元数据 Bean Definition 可以通过 XML，Java 注解或 Java Config 代码提供。</li></ul></li><li>IoC与DI之间关系是怎样的<br> IoC和DI指的是一件事。IoC是一种思想，这种思想不仅在Spring中，在Spring之前，也有许多框架采用这种思想。Martin Fowler将Spring中IoC改为DI，并有如下解释：已经存在某种模式，该模式被称为IoC，但IoC太普遍，任何框架都IoC，为了让表意更明确，决定用DI来精确指称那个模式（来自 <a href="https://martinfowler.com/articles/injection.html）" target="_blank" rel="noopener">https://martinfowler.com/articles/injection.html）</a>  。如上我认为也可以有如下解释：IoC是一种思想，是一种目的（解耦）。DI更像是实现IoC的一种方式，DI有更具体的实现方式（interface，setter，constructor）。IoC是指让生成类的方式由传统方式（new）反过来，既程序员不调用new,需要类的时候由框架注入（DI），是同一件不同层面（由思想到更为具体的实现方式）的解读。  </li><li>组件、bean、javaBean是个啥？<br>组件是构成某个事物的组成部分，例如电池就是手机的组件。<br>bean是指可重复使用的组件，嗯可以直接理解为各种对象（我认为）<br>JavaBean特指Java语言书写的bean。spring能管理各种各样的bean。</li><li>Spring 中有多少种 IoC 容器？<br> Spring 提供了两种( 不是“个” ) IoC 容器，分别是 BeanFactory、ApplicationContext。其中ApplicationContext接口是BeanFactory的子接口，它扩展了BeanFactory接口的功能，平时主要使用ApplicationContext容器。<br> BeanFactory：就像一个包含 Bean 集合的工厂类。它会在客户端要求时实例化 Bean 对象，即需要时创建对象。<br> ApplicationContext：由spring-context包提供，会在容器初始化时就全部加载所有的bean。ApplicationContext 接口扩展了 BeanFactory 接口，它在 BeanFactory 基础上提供了一些额外的功能。内置如下功能：  <ul><li>MessageSource ：管理 message ，实现国际化等功能。</li><li>ApplicationEventPublisher ：事件发布。</li><li>ResourcePatternResolver ：多资源加载。</li><li>EnvironmentCapable ：系统 Environment（profile + Properties）相关。</li><li>Lifecycle ：管理生命周期。</li><li>Closable ：关闭，释放资源</li><li>InitializingBean：自定义初始化。</li><li>BeanNameAware：设置 beanName 的 Aware 接口。</li></ul></li><li><p>常用的BeanFactory容器有哪些？<br> BeanFactory 最常用的是XmlBeanFactory 。它可以根据 XML 文件中定义的内容，创建相应的 Bean。</p></li><li><p>常用的 ApplicationContext 容器由有哪些？<br> 以下是三种较常见的 ApplicationContext 实现方式：  </p><ul><li><strong>ClassPathXmlApplicationContext</strong> ：从 ClassPath 的 XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。例如：ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);  </li><li><strong>FileSystemXmlApplicationContext</strong> ：由文件系统中的XML配置文件读取上下文。例如：ApplicationContext context = new FileSystemXmlApplicationContext(“bean.xml”);</li><li><strong>XmlWebApplicationContext</strong> ：由 Web 应用的XML文件读取上下文。例如我们在 Spring MVC 使用的情况。</li><li>由于目前使用 Spring Boot 为主，所以通常使用的是第四种 ApplicationContext 容器，<strong>ConfigServletWebServerApplicationContext</strong> 。    </li></ul></li><li><p>IoC 的一些好处？<br> 它将最小化应用程序中的代码量。<br> 它以最小的影响和最少的侵入机制促进松耦合。<br> 它支持即时的实例化和延迟加载 Bean 对象。<br> 它将应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。  </p></li><li><p>Spring 有哪些配置方式，（几种方式创建Bean）<br> 1、XML 配置文件<br> 2、注解配置<br>  默认情况下，Spring 容器中未打开注解装配。因此，需要在使用它之前在 Spring 配置文件中启用它。  </p><pre class="line-numbers language-javascript"><code class="language-javascript">  <span class="token operator">&lt;</span>beans<span class="token operator">></span>  <span class="token operator">&lt;</span>context<span class="token punctuation">:</span>annotation<span class="token operator">-</span>config<span class="token operator">/</span><span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">/</span>beans<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 3、Java Config 配置 还需了解几个注解如 @Bean 和 @Configuration   </p></li><li><p>XML创建Bean的三种方式<br>1 使用默认构造函数创建。<br>在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时。采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。  </p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"accountService"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.itheima.service.impl.AccountServiceImpl"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2 使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）先将此工厂实例化，再调用其方法生成对象     </p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"instanceFactory"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.xiaomi.factory.InstanceFactory"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"accountService"</span> factory<span class="token operator">-</span>bean<span class="token operator">=</span><span class="token string">"instanceFactory"</span> factory<span class="token operator">-</span>method<span class="token operator">=</span><span class="token string">"getAccountService"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>3 使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器)</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"accountService"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.xiaomi.factory.StaticFactory"</span> factory<span class="token operator">-</span>method<span class="token operator">=</span><span class="token string">"getAccountService"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><bean id="accountService" class="com.xiaomi.factory.StaticFactory" factory-method="getAccountService"></bean></li><li><p>Spring中有几种注入方式？   基于注解的注入：<br>基于xml配置文件的注入方式？<br><strong>能注入的数据：有三类</strong>  </p><pre><code>1. 基本类型和String  2. 其他bean类型（在配置文件中或者注解配置过的bean）  3. 复杂类型/集合类型  </code></pre><p><strong>注入的方式：有三种</strong>    </p><pre><code>1. 使用构造函数提供  2. 使用set方法提供  3. 使用注解提供    </code></pre><p>构造函数注入：<br>使用的标签:constructor-arg<br>标签出现的位置：bean标签的内部<br>标签中的属性<br>  type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型<br>  index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始<br>  name：用于指定给构造函数中指定名称的参数赋值<br>  =============以上三个用于指定给构造函数中哪个参数赋值===============================<br>  value：用于提供基本类型和String类型的数据<br>  ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象  </p><p>优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。<br>弊端：改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。  </p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"accountService"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.xiaomi.service.impl.AccountServiceImpl"</span><span class="token operator">></span><span class="token operator">&lt;</span>constructor<span class="token operator">-</span>arg name<span class="token operator">=</span><span class="token string">"name"</span> value<span class="token operator">=</span><span class="token string">"小米"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>constructor<span class="token operator">-</span>arg<span class="token operator">></span><span class="token operator">&lt;</span>constructor<span class="token operator">-</span>arg name<span class="token operator">=</span><span class="token string">"age"</span> value<span class="token operator">=</span><span class="token string">"18"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>constructor<span class="token operator">-</span>arg<span class="token operator">></span><span class="token operator">&lt;</span>constructor<span class="token operator">-</span>arg name<span class="token operator">=</span><span class="token string">"birthday"</span> ref<span class="token operator">=</span><span class="token string">"now"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>constructor<span class="token operator">-</span>arg<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 配置一个日期对象 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"now"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"java.util.Date"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>set方法注入</strong>   更常用的方式<br>涉及的标签：property<br>出现的位置：bean标签的内部<br>标签的属性:    </p><pre><code>name：用于指定注入时所调用的set方法名称value：用于提供基本类型和String类型的数据ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象</code></pre><p>优势：创建对象时没有明确的限制，可以直接使用默认构造函数.<br>弊端：如果有某个成员必须有值，则获取对象是有可能set方法没有执行。</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript"><bean id="accountService2" class="com.itheima.service.impl.AccountServiceImpl2"><property name="name" value="TEST" ></property><property name="age" value="21"></property><property name="birthday" ref="now"></property></bean><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂类型的注入/集合类型的注入</strong><br>用于给List结构集合注入的标签：list 、 array 、 set<br>用于个Map结构集合注入的标签:  map  、 props<br>结构相同，标签可以互换</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"accountService3"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.xiaomi.service.impl.AccountServiceImpl3"</span><span class="token operator">></span><span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"myStrs"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token keyword">set</span><span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>AAA<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>BBB<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>CCC<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">set</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span><span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"myList"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>array<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>AAA<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>BBB<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>CCC<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>array<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span><span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"mySet"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>list<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>AAA<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>BBB<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>CCC<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>list<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span><span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"myMap"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>props<span class="token operator">></span>        <span class="token operator">&lt;</span>prop key<span class="token operator">=</span><span class="token string">"testC"</span><span class="token operator">></span>ccc<span class="token operator">&lt;</span><span class="token operator">/</span>prop<span class="token operator">></span>        <span class="token operator">&lt;</span>prop key<span class="token operator">=</span><span class="token string">"testD"</span><span class="token operator">></span>ddd<span class="token operator">&lt;</span><span class="token operator">/</span>prop<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>props<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span><span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"myProps"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>map<span class="token operator">></span>        <span class="token operator">&lt;</span>entry key<span class="token operator">=</span><span class="token string">"testA"</span> value<span class="token operator">=</span><span class="token string">"aaa"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>entry<span class="token operator">></span>        <span class="token operator">&lt;</span>entry key<span class="token operator">=</span><span class="token string">"testB"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>value<span class="token operator">></span>BBB<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>entry<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>map<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>基于注解的注入</strong><br>用于创建对象的注解：<br>Component:作用：用于把当前类对象存入spring容器中。<br>Component的value属性：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。<br>Controller：一般用在表现层<br>Service：一般用在业务层<br>Repository：一般用在持久层<br>Controller、Service、Respository三个注解他们的作用和属性与Component是一模一样。但为我们提供明确的三层使用的注解，使我们的三层结构更加清晰。<br>用于注入数据的注解：<br>他们的作用就和在xml配置文件中的bean标签中写一个<property>标签的作用是一样的<br>Autowired: 自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功。 如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。 出现位置可以是变量上，也可以是方法上。<br>需要注意的是在使用Autowired注解注入时，set方法就不是必须的了。<br>Qualifier:在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用。但是在给方法参数注入时可以。Qualifier的value属性用于指定注入bean的id。<br>Resource：直接按照bean的id注入。Resource注解可以独立使用。Resource注解的name属性用于指定bean的id。<br>需要注意的是以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。另外，集合类型的注入只能通过XML来实现。</property></p></li><li><p>Spring 支持几种 Bean Scope ？<br>Spring Bean 支持 6 种 Scope ，分别如下：<br><strong>Singleton</strong> ： 每个 Spring IoC 容器仅有一个单 Bean 实例。默认<br><strong>Prototype</strong> ： 每次请求都会产生一个新的实例（多例）。<br><strong>Request</strong>   ： 每一次 HTTP 请求都会产生一个新的 Bean 实例，并且该 Bean 仅在当前 HTTP 请求内有效。<br><strong>Session</strong>   ： 每一个的 Session 都会产生一个新的 Bean 实例，同时该 Bean 仅在当前 HTTP Session 内有效。<br><strong>Application</strong> ： 每一个 Web Application 都会产生一个新的 Bean ，同时该 Bean 仅在当前 Web Application 内有效。<br><strong>Global-session</strong> ：用于集群中，已在 Spring5 中消失。<br>仅当使用支持 Web 的 ApplicationContext 时，例如 <strong>WebApplicationContext</strong> ，最后4个才可用。实际常用的只有 Singleton 和 Prototype 两种级别，甚至说，只有 Singleton 级别。  </p></li><li>Spring Bean 在容器的生命周期是什么样的？<br>单例对象 singleton<br>出生：当容器创建时对象出生<br>活着：只要容器还在，对象一直活着<br>死亡：容器销毁，对象消亡<br>总结：单例对象的生命周期和容器相同<br>多例对象  prototype<br>出生：当我们使用对象时spring框架为我们创建<br>活着：对象只要是在使用过程中就一直活着。<br>死亡：当对象长时间不用，且没有别的对象引用时，由Java的垃圾回收器回收    </li><li><p>什么是 Spring 的内部 bean？<br>只有将 Bean 仅用作另一个 Bean 的属性时，才能将 Bean 声明为内部 Bean。<br>为了定义 Bean，Spring 提供基于 XML 的配置元数据在 <property>或 <constructor-arg> 中提供了 <bean>元素的使用。<br>内部 Bean 总是匿名的，并且它们总是作为原型 Prototype 。<br>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。示例代码如下：  </bean></constructor-arg></property></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Student.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> Person person<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ... Setters and Getters</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Person.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>  <span class="token keyword">private</span> String address<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Setters and Getters</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> bean<span class="token punctuation">.</span>xml <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>bean id<span class="token operator">=</span>“StudentBean<span class="token string">" class="</span>com<span class="token punctuation">.</span>edureka<span class="token punctuation">.</span>Student"<span class="token operator">></span>  <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"person"</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>This is inner bean <span class="token operator">--</span><span class="token operator">></span>      <span class="token operator">&lt;</span>bean <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.edureka.Person"</span><span class="token operator">></span>          <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"name"</span> value<span class="token operator">=</span>“Scott"<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span>          <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"address"</span> value<span class="token operator">=</span>“Bangalore"<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Spring 框架中的单例 Bean 是线程安全的么？<br>Spring 框架并没有对单例 Bean 进行任何多线程的封装处理。所以关于单例 Bean 的线程安全和并发问题，需要开发者自行去搞定。<br>并且，单例的线程安全问题，也不是 Spring 应该去关心的。Spring 应该做的是，提供根据配置，创建单例 Bean 或多例 Bean 的功能。<br>当然，但实际上，大部分的 Spring Bean 并没有可变的状态(比如Serview 类和 DAO 类)，所以在某种程度上说 Spring 的单例 Bean 是线程安全的。<br>如果你的 Bean 有多种状态的话，就需要自行保证线程安全。最浅显的解决办法，就是将多态 Bean 的作用域( Scope )由 Singleton 变更为 Prototype 。</p></li></ol><p>16.Spring Bean 怎么解决循环依赖的问题？<br>XXXXXX</p><p>以上部分是我对Spring的理解，并整理了一边经常用到的知识点。在下一篇文章中，我会以工厂模式加反射来实现一下IoC的思想，并对Spring IoC中所用到的注解进行进一步的整理。</p>]]></content>
      
      
      <categories>
          
          <category> java web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring--IoC</title>
      <link href="/2019/11/11/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/spring/"/>
      <url>/2019/11/11/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/spring/</url>
      
        <content type="html"><![CDATA[<p>spring中的IoC是一种软件开发的思想，用来降低程序间耦合的问题。在未采用IoC的开发中，上层依赖下层，某个对象需要另一个对象，只能自己采用new的方式进行创建，那么会产生以下的问题：  </p><ol><li>new的方式散落在整个工程的各个地方，如果想更换一个所需要的对象，将需要对涉及到所有的new进行修改。  </li><li>许多对象以单例的模式就可以满足业务需求，不需要每次都new一个对象，浪费资源、效率。</li></ol><p>针对以上的问题1，我们可以采用工厂模式可以解决。将一个字符串作为一个类对象的标识id，&lt;id=””, class=””&gt;，在程序中使用id进行对象的注入，id与class的关系保存在一个配置文件中（代码之外），如果需要更换所需的对象，只需要更改&lt;id=””, class=””&gt;中的class方式即可，实现了上层与所需依赖以抽象的方式(id字符串)联系起来。  </p><p>针对以上的问题2，我们可以考虑使用一个容器来管理业务中所需要的单例对象，例如使用一个map来管理工厂模式所产生的对象，而这个map就是spring中的IoC容器。  </p><p>有了上面的思路，再来说一说Spring中的一些概念。</p><ol><li>IoC之前谁控制谁，怎么控制，IoC之后谁控制谁，怎么控制<br> IoC之前，类都是通过new通过组合，完成对象的依赖，即谁需要，谁控制类的创建。IoC通过IoC容器，谁需要，IoC将所需要的对象注入到谁中。</li><li>IoC容器什么？<br>Spring的核心是 Spring IoC 容器。容器创建 Bean 对象，将它们装配在一起，配置它们并管理它们的完整生命周期。  <ul><li>Spring 容器使用依赖注入来管理组成应用程序的 Bean 对象。  </li><li>容器通过读取提供的配置元数据 Bean Definition 来接收对象进行实例化，配置和组装的指令。  </li><li>该配置元数据 Bean Definition 可以通过 XML，Java 注解或 Java Config 代码提供。</li></ul></li><li>IoC与DI之间关系是怎样的<br> IoC和DI指的是一件事。IoC是一种思想，这种思想不仅在Spring中，在Spring之前，也有许多框架采用这种思想。Martin Fowler将Spring中IoC改为DI，并有如下解释：已经存在某种模式，该模式被称为IoC，但IoC太普遍，任何框架都IoC，为了让表意更明确，决定用DI来精确指称那个模式（来自 <a href="https://martinfowler.com/articles/injection.html）" target="_blank" rel="noopener">https://martinfowler.com/articles/injection.html）</a>  。如上我认为也可以有如下解释：IoC是一种思想，是一种目的（解耦）。DI更像是实现IoC的一种方式，DI有更具体的实现方式（interface，setter，constructor）。IoC是指让生成类的方式由传统方式（new）反过来，既程序员不调用new,需要类的时候由框架注入（DI），是同一件不同层面（由思想到更为具体的实现方式）的解读。  </li><li>组件、bean、javaBean是个啥？<br>组件是构成某个事物的组成部分，例如电池就是手机的组件。<br>bean是指可重复使用的组件，嗯可以直接理解为各种对象（我认为）<br>JavaBean特指Java语言书写的bean。spring能管理各种各样的bean。</li><li>Spring 中有多少种 IoC 容器？<br> Spring 提供了两种( 不是“个” ) IoC 容器，分别是 BeanFactory、ApplicationContext。其中ApplicationContext接口是BeanFactory的子接口，它扩展了BeanFactory接口的功能，平时主要使用ApplicationContext容器。<br> BeanFactory：就像一个包含 Bean 集合的工厂类。它会在客户端要求时实例化 Bean 对象，即需要时创建对象。<br> ApplicationContext：由spring-context包提供，会在容器初始化时就全部加载所有的bean。ApplicationContext 接口扩展了 BeanFactory 接口，它在 BeanFactory 基础上提供了一些额外的功能。内置如下功能：  <ul><li>MessageSource ：管理 message ，实现国际化等功能。</li><li>ApplicationEventPublisher ：事件发布。</li><li>ResourcePatternResolver ：多资源加载。</li><li>EnvironmentCapable ：系统 Environment（profile + Properties）相关。</li><li>Lifecycle ：管理生命周期。</li><li>Closable ：关闭，释放资源</li><li>InitializingBean：自定义初始化。</li><li>BeanNameAware：设置 beanName 的 Aware 接口。</li></ul></li><li><p>常用的BeanFactory容器有哪些？<br> BeanFactory 最常用的是XmlBeanFactory 。它可以根据 XML 文件中定义的内容，创建相应的 Bean。</p></li><li><p>常用的 ApplicationContext 容器由有哪些？<br> 以下是三种较常见的 ApplicationContext 实现方式：  </p><ul><li><strong>ClassPathXmlApplicationContext</strong> ：从 ClassPath 的 XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。例如：ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);  </li><li><strong>FileSystemXmlApplicationContext</strong> ：由文件系统中的XML配置文件读取上下文。例如：ApplicationContext context = new FileSystemXmlApplicationContext(“bean.xml”);</li><li><strong>XmlWebApplicationContext</strong> ：由 Web 应用的XML文件读取上下文。例如我们在 Spring MVC 使用的情况。</li><li>由于目前使用 Spring Boot 为主，所以通常使用的是第四种 ApplicationContext 容器，<strong>ConfigServletWebServerApplicationContext</strong> 。    </li></ul></li><li><p>IoC 的一些好处？<br> 它将最小化应用程序中的代码量。<br> 它以最小的影响和最少的侵入机制促进松耦合。<br> 它支持即时的实例化和延迟加载 Bean 对象。<br> 它将应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。  </p></li><li><p>Spring 有哪些配置方式，（几种方式创建Bean）<br> 1、XML 配置文件<br> 2、注解配置<br>  默认情况下，Spring 容器中未打开注解装配。因此，需要在使用它之前在 Spring 配置文件中启用它。  </p><pre class="line-numbers language-javascript"><code class="language-javascript">  <span class="token operator">&lt;</span>beans<span class="token operator">></span>  <span class="token operator">&lt;</span>context<span class="token punctuation">:</span>annotation<span class="token operator">-</span>config<span class="token operator">/</span><span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">/</span>beans<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 3、Java Config 配置 还需了解几个注解如 @Bean 和 @Configuration   </p></li><li><p>XML创建Bean的三种方式<br>1 使用默认构造函数创建。<br>在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时。采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。  </p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"accountService"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.itheima.service.impl.AccountServiceImpl"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2 使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）先将此工厂实例化，再调用其方法生成对象     </p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"instanceFactory"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.xiaomi.factory.InstanceFactory"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"accountService"</span> factory<span class="token operator">-</span>bean<span class="token operator">=</span><span class="token string">"instanceFactory"</span> factory<span class="token operator">-</span>method<span class="token operator">=</span><span class="token string">"getAccountService"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>3 使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器)</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"accountService"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.xiaomi.factory.StaticFactory"</span> factory<span class="token operator">-</span>method<span class="token operator">=</span><span class="token string">"getAccountService"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><bean id="accountService" class="com.xiaomi.factory.StaticFactory" factory-method="getAccountService"></bean></li><li><p>Spring中有几种注入方式？   基于注解的注入：<br>基于xml配置文件的注入方式？<br><strong>能注入的数据：有三类</strong>  </p><pre><code>1. 基本类型和String  2. 其他bean类型（在配置文件中或者注解配置过的bean）  3. 复杂类型/集合类型  </code></pre><p><strong>注入的方式：有三种</strong>    </p><pre><code>1. 使用构造函数提供  2. 使用set方法提供  3. 使用注解提供    </code></pre><p>构造函数注入：<br>使用的标签:constructor-arg<br>标签出现的位置：bean标签的内部<br>标签中的属性<br>  type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型<br>  index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始<br>  name：用于指定给构造函数中指定名称的参数赋值<br>  =============以上三个用于指定给构造函数中哪个参数赋值===============================<br>  value：用于提供基本类型和String类型的数据<br>  ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象  </p><p>优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。<br>弊端：改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。  </p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"accountService"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.xiaomi.service.impl.AccountServiceImpl"</span><span class="token operator">></span><span class="token operator">&lt;</span>constructor<span class="token operator">-</span>arg name<span class="token operator">=</span><span class="token string">"name"</span> value<span class="token operator">=</span><span class="token string">"小米"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>constructor<span class="token operator">-</span>arg<span class="token operator">></span><span class="token operator">&lt;</span>constructor<span class="token operator">-</span>arg name<span class="token operator">=</span><span class="token string">"age"</span> value<span class="token operator">=</span><span class="token string">"18"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>constructor<span class="token operator">-</span>arg<span class="token operator">></span><span class="token operator">&lt;</span>constructor<span class="token operator">-</span>arg name<span class="token operator">=</span><span class="token string">"birthday"</span> ref<span class="token operator">=</span><span class="token string">"now"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>constructor<span class="token operator">-</span>arg<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 配置一个日期对象 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"now"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"java.util.Date"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>set方法注入</strong>   更常用的方式<br>涉及的标签：property<br>出现的位置：bean标签的内部<br>标签的属性:    </p><pre><code>name：用于指定注入时所调用的set方法名称value：用于提供基本类型和String类型的数据ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象</code></pre><p>优势：创建对象时没有明确的限制，可以直接使用默认构造函数.<br>弊端：如果有某个成员必须有值，则获取对象是有可能set方法没有执行。</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript"><bean id="accountService2" class="com.itheima.service.impl.AccountServiceImpl2"><property name="name" value="TEST" ></property><property name="age" value="21"></property><property name="birthday" ref="now"></property></bean><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂类型的注入/集合类型的注入</strong><br>用于给List结构集合注入的标签：list 、 array 、 set<br>用于个Map结构集合注入的标签:  map  、 props<br>结构相同，标签可以互换</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"accountService3"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.xiaomi.service.impl.AccountServiceImpl3"</span><span class="token operator">></span><span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"myStrs"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token keyword">set</span><span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>AAA<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>BBB<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>CCC<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">set</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span><span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"myList"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>array<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>AAA<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>BBB<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>CCC<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>array<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span><span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"mySet"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>list<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>AAA<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>BBB<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>CCC<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>list<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span><span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"myMap"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>props<span class="token operator">></span>        <span class="token operator">&lt;</span>prop key<span class="token operator">=</span><span class="token string">"testC"</span><span class="token operator">></span>ccc<span class="token operator">&lt;</span><span class="token operator">/</span>prop<span class="token operator">></span>        <span class="token operator">&lt;</span>prop key<span class="token operator">=</span><span class="token string">"testD"</span><span class="token operator">></span>ddd<span class="token operator">&lt;</span><span class="token operator">/</span>prop<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>props<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span><span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"myProps"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>map<span class="token operator">></span>        <span class="token operator">&lt;</span>entry key<span class="token operator">=</span><span class="token string">"testA"</span> value<span class="token operator">=</span><span class="token string">"aaa"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>entry<span class="token operator">></span>        <span class="token operator">&lt;</span>entry key<span class="token operator">=</span><span class="token string">"testB"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>value<span class="token operator">></span>BBB<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>entry<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>map<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>基于注解的注入</strong><br>用于创建对象的注解：<br>Component:作用：用于把当前类对象存入spring容器中。<br>Component的value属性：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。<br>Controller：一般用在表现层<br>Service：一般用在业务层<br>Repository：一般用在持久层<br>Controller、Service、Respository三个注解他们的作用和属性与Component是一模一样。但为我们提供明确的三层使用的注解，使我们的三层结构更加清晰。<br>用于注入数据的注解：<br>他们的作用就和在xml配置文件中的bean标签中写一个<property>标签的作用是一样的<br>Autowired: 自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功。 如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。 出现位置可以是变量上，也可以是方法上。<br>需要注意的是在使用Autowired注解注入时，set方法就不是必须的了。<br>Qualifier:在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用。但是在给方法参数注入时可以。Qualifier的value属性用于指定注入bean的id。<br>Resource：直接按照bean的id注入。Resource注解可以独立使用。Resource注解的name属性用于指定bean的id。<br>需要注意的是以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。另外，集合类型的注入只能通过XML来实现。</property></p></li><li><p>Spring 支持几种 Bean Scope ？<br>Spring Bean 支持 6 种 Scope ，分别如下：<br><strong>Singleton</strong> ： 每个 Spring IoC 容器仅有一个单 Bean 实例。默认<br><strong>Prototype</strong> ： 每次请求都会产生一个新的实例（多例）。<br><strong>Request</strong>   ： 每一次 HTTP 请求都会产生一个新的 Bean 实例，并且该 Bean 仅在当前 HTTP 请求内有效。<br><strong>Session</strong>   ： 每一个的 Session 都会产生一个新的 Bean 实例，同时该 Bean 仅在当前 HTTP Session 内有效。<br><strong>Application</strong> ： 每一个 Web Application 都会产生一个新的 Bean ，同时该 Bean 仅在当前 Web Application 内有效。<br><strong>Global-session</strong> ：用于集群中，已在 Spring5 中消失。<br>仅当使用支持 Web 的 ApplicationContext 时，例如 <strong>WebApplicationContext</strong> ，最后4个才可用。实际常用的只有 Singleton 和 Prototype 两种级别，甚至说，只有 Singleton 级别。  </p></li><li>Spring Bean 在容器的生命周期是什么样的？<br>单例对象 singleton<br>出生：当容器创建时对象出生<br>活着：只要容器还在，对象一直活着<br>死亡：容器销毁，对象消亡<br>总结：单例对象的生命周期和容器相同<br>多例对象  prototype<br>出生：当我们使用对象时spring框架为我们创建<br>活着：对象只要是在使用过程中就一直活着。<br>死亡：当对象长时间不用，且没有别的对象引用时，由Java的垃圾回收器回收    </li><li><p>什么是 Spring 的内部 bean？<br>只有将 Bean 仅用作另一个 Bean 的属性时，才能将 Bean 声明为内部 Bean。<br>为了定义 Bean，Spring 提供基于 XML 的配置元数据在 <property>或 <constructor-arg> 中提供了 <bean>元素的使用。<br>内部 Bean 总是匿名的，并且它们总是作为原型 Prototype 。<br>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。示例代码如下：  </bean></constructor-arg></property></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Student.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> Person person<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ... Setters and Getters</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Person.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>  <span class="token keyword">private</span> String address<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Setters and Getters</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> bean<span class="token punctuation">.</span>xml <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>bean id<span class="token operator">=</span>“StudentBean<span class="token string">" class="</span>com<span class="token punctuation">.</span>edureka<span class="token punctuation">.</span>Student"<span class="token operator">></span>  <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"person"</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>This is inner bean <span class="token operator">--</span><span class="token operator">></span>      <span class="token operator">&lt;</span>bean <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.edureka.Person"</span><span class="token operator">></span>          <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"name"</span> value<span class="token operator">=</span>“Scott"<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span>          <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"address"</span> value<span class="token operator">=</span>“Bangalore"<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Spring 框架中的单例 Bean 是线程安全的么？<br>Spring 框架并没有对单例 Bean 进行任何多线程的封装处理。所以关于单例 Bean 的线程安全和并发问题，需要开发者自行去搞定。<br>并且，单例的线程安全问题，也不是 Spring 应该去关心的。Spring 应该做的是，提供根据配置，创建单例 Bean 或多例 Bean 的功能。<br>当然，但实际上，大部分的 Spring Bean 并没有可变的状态(比如Serview 类和 DAO 类)，所以在某种程度上说 Spring 的单例 Bean 是线程安全的。<br>如果你的 Bean 有多种状态的话，就需要自行保证线程安全。最浅显的解决办法，就是将多态 Bean 的作用域( Scope )由 Singleton 变更为 Prototype 。</p></li></ol><p>16.Spring Bean 怎么解决循环依赖的问题？<br>XXXXXX</p><p>以上部分是我对Spring的理解，并整理了一边经常用到的知识点。在下一篇文章中，我会以工厂模式加反射来实现一下IoC的思想，并对Spring IoC中所用到的注解进行进一步的整理。</p>]]></content>
      
      
      <categories>
          
          <category> java web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java泛型</title>
      <link href="/2019/10/22/Java%20Generic/"/>
      <url>/2019/10/22/Java%20Generic/</url>
      
        <content type="html"><![CDATA[<h3 id="泛型来源"><a href="#泛型来源" class="headerlink" title="泛型来源"></a>泛型来源</h3><p>前面用到了集合，可以存储自定义的对象然后进行遍历操作，由于可存储的对象可以是任意类型的，因此就可能在转换时出现类型转换异常，Java为了解决这个问题，提出了一种机制 – 泛型（Generic）。<br>泛型把明确具体类型的工作提前到了编译时期。<br>集合都是基于泛型的，泛型的基本思想与概念是简单的，但是泛型有一些比较令人费解的语法，细节和局限性。本文主要阐述泛型的基本概念与原理、通配符、泛型需要注意的一些细节与局限性。  </p><h3 id="泛型基本概念与原理"><a href="#泛型基本概念与原理" class="headerlink" title="泛型基本概念与原理"></a>泛型基本概念与原理</h3><p>泛型的字面意思就是广泛的类型。类、接口与方法都可以应用于很广泛的类型。 <strong>代码与他们能够操作的数据类型不再紧密的绑定在一起</strong>，同一段代码可以处理不同的数据类型，有代码复用、降低耦合、提高代码的可读性与安全性的优点。  </p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类（Generic Class）时，我们只关注泛型，而不用专注于数据存储的细节。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>  T first<span class="token punctuation">;</span>  T second<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token function">Pair</span><span class="token punctuation">(</span>T first<span class="token punctuation">,</span> T second<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> T <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> first<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> T <span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> second<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所定义的泛型类Pair与普通类有以下区别：  </p><ul><li>类名后加了<t>;  </t></li><li>成员变量first与second的类型为T；  </li></ul><p>T表示 <strong>类型参数</strong> ，<strong>泛型就是类型参数化，处理的数据类型不是固定的，而是可以作为参数传入。</strong><br>需要注意的是，T只是一个符号，编译器会把T统一的进行修改。T也可以替换为Ti，s等等，只要一致就可以。但是对于泛型的类型参数一般使用大写字母，并且比较短，在Java的标准类库中变量E表示集合的元素，符号K与V分别表示表的关键字与关键字与值的类型，字母T或者U、S表示任意类型。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//java泛型类的具体使用</span>Pair<span class="token operator">&lt;</span>Integer<span class="token operator">></span> minmax <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//后面尖括号里的类型可以省略</span>Integer min <span class="token operator">=</span> minmax<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer max <span class="token operator">=</span> minmax<span class="token punctuation">.</span><span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当然在定义泛型类时候也可以定义多个类型参数，例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span>S<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//......</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>泛型的类型参数T到底是什么？为什么不直接定义一个Object类（在对象里使用时再使用向下转型也就是强制类型转换）而要再次定义类型参数呢？<br>实际上，Java泛型的内部原理是这样的：</p><blockquote><p>众所周知，编译器将Java源代码转换为.class问文件，虚拟机加载并运行.class问文件。而对于泛型类，编译器会将泛型类的代码转换为普通的非泛型代码</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java源码-剖析LinkedList</title>
      <link href="/2019/10/20/Java%20LinkedList/"/>
      <url>/2019/10/20/Java%20LinkedList/</url>
      
        <content type="html"><![CDATA[<p>ArrayLis通过索引值随机访问的效率很高，但是插入与删除的性能比较低；LinkedList也实现了List接口，而LIst接口扩展了Collection接口，Collection接口又扩展了Iterable接口。同时LinkedList还实现了队列接口Queue，就是平时说的队列，两个操作点，尾部加元素，头部删元素，先进先出。<br>但是LinkedList与ArrayList的特点几乎刚好相反。  </p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>LinkedList的构造方法有两个，与ArrayList类似。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">LinkedList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Queue接口：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Queue</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">{</span>  <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//尾部添加元素  队满 抛出异常</span>  <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//尾部添加元素  队满 返回false</span>  E <span class="token function">romove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//删除头部元素  队为空 抛出异常</span>  E <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//删除头部元素  队为空 返回null</span>  E <span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//查看头部元素  队为空 抛出异常</span>  E <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//查看头部元素  队为空 返回null</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，LinkedList可以使用上面Queue的接口去当做栈使用。<br>其实，LinkedList是直接实现了Deque<e>接口，而Deque接口扩展了Queue接口。Deque接口有着更为通用的方法，包含了栈的操作方法。<br>Deque接口：  </e></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Deque</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Queue</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">{</span>  <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">boolean</span> <span class="token function">offerFirst</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">boolean</span> <span class="token function">offerLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>  E <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  E <span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  E <span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  E <span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  E <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  E <span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  E <span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  E <span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>xxxFirst操作头部，xxxLast操作尾部。每种操作两种方法，也是因为队满或者队空时处理方法不同。addXXX/getXXX/removeXXX抛异常，peekXXX/pollXXX返回null，offerXXX返回false。<br>综上，LinkedList由于实现了Duque接口，所以可以把它看做队列、栈、双端队列。  </p><h3 id="实现原理（java7）"><a href="#实现原理（java7）" class="headerlink" title="实现原理（java7）"></a>实现原理（java7）</h3><h4 id="内部组成"><a href="#内部组成" class="headerlink" title="内部组成"></a>内部组成</h4><p>ArrayList内部是数组，元素在内存中是连续存放的。但是LinkedList的内部实现是 <strong>双向链表</strong> ，其每个元素在内存中都是单独存放的，元素之间通过链接连在一起。<br>数据结构链表中的节点Node在java中由静态内部类实现。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">{</span>  E item<span class="token punctuation">;</span>  Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span>  Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">;</span>  <span class="token function">Node</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span>prev<span class="token punctuation">,</span>E element<span class="token punctuation">,</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LinkedList主要就是操作以下三个成员变量。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> first<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//头结点</span><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> last<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//尾节点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>add（）方法的主要步骤：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>last <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span> first <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token keyword">else</span> l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>size<span class="token operator">++</span><span class="token punctuation">;</span>modCount<span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1)  创建一个新的节点newNode。l与last指向原来的尾节点，如果原来链表为空，则为null。<br>2） 修改尾节点last，指向最新的最后节点newNode。<br>3） 修改前节点的向后链接，如果原来链表为空，则让头结点指向新节点，否则让前一个节点next指向新节点。<br>4） 增加链表大小。<br>注意：modCount++的目的与在ArrayList中是一样的，记录修改次数，便于迭代过程中检测结构性变化。<br><strong>LinkedList的内存是按需分配的。</strong><br>add（）方法是在尾部插入，当然也可以在头部或者中间插入元素 public void add(int index, E element)。具体过程如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span>        <span class="token function">linkLast</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">linkBefore</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">linkBefore</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> succ<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// assert succ != null;</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> pred <span class="token operator">=</span> succ<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> e<span class="token punctuation">,</span> succ<span class="token punctuation">)</span><span class="token punctuation">;</span>    succ<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">==</span> null<span class="token punctuation">)</span>        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token keyword">else</span>        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>succ：后继节点，pred：前驱节点。在这两个节点中间插入一个节点。步骤如下：<br>1）创建一个newNode节点。<br>2) succ的前驱指向新节点newNode。<br>3) pred的前驱指向新节点newNode，若前驱为null，将头结点first指向新节点newNode。<br>4）增加长度。<br>通过索引删除元素的主要过程如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//通过Node（）方法找到节点后，调用unlink（Node&lt;E> x）方法</span>E <span class="token function">unlink</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// assert x != null;</span>    <span class="token keyword">final</span> E element <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        first <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        last <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        next<span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    x<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>    size<span class="token operator">--</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> element<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>基本思路就是让x的前驱和后继直接链接起来，next是x的后继，prev是x的前驱，具体分为两步：  </p><ol><li>让x的前驱的后继指向x的后继。如果x没有前驱，说明删除的是头节点，则修改头节点指向x的后继。</li><li>让x的后继的前驱指向x的前驱。如果x没有后继，说明删除的是尾节点，则修改尾节点指向x的前驱。  </li></ol></blockquote><p>其它常用方法还有按索引值访问元素get（int i）与按内容查找元素indexOf（Object o）。其中get方法主要调用node方法返回第i个节点，节点的item变量就是其元素值。 indexOf方法直接从first开始查找，若要查找的内容不是null，则使用equal方法进行比较。   </p><h3 id="特点分析"><a href="#特点分析" class="headerlink" title="特点分析"></a>特点分析</h3><p>LinkedList内部是用双向链表实现的，维护了长度、头节点和尾节点，这决定了它有如下特点：</p><ol><li>按需分配空间，不需要预先分配很多空间。</li><li>不可以随机访问，<strong>按照索引位置访问</strong>效率比较低，必须从头或尾顺着链接找，效率为O(N/2)[如果索引位置在前部分：<strong>index&lt;(size&gt;&gt;1)</strong> ，则从first节点开始，否则从last节点开始]。  </li><li>只要是按照内容查找元素，不管LinkedList的列表是否已排序，效率都比较低，因为必须逐个的进行比较，时间复杂度为O(N)。  </li><li>由于有first与last节点所以在两端添加、删除元素的效率很高，时间复杂度为O(1)。  </li><li>在中间插入、删除元素，要先定位，效率比较低，为O(N)，但修改本身的效率很高，效率为O(1)。   </li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用法上，LinkedList是一个List，但也实现了Deque接口，可以作为队列、栈和双端队列使用。实现原理上，内部是一个双向链表，并维护了长度、头节点和尾节点。<br>根据LinkedList和ArrayList的特点，我们就可以根据实际情况进行选择，如果列表长度未知，添加、删除操作比较多，尤其经常从两端进行操作，而按照索引位置访问相对比较少，则LinkedList是比较理想的选择。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> java源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java为何没有引用传递？</title>
      <link href="/2019/09/07/Java%20CallByValueReference/"/>
      <url>/2019/09/07/Java%20CallByValueReference/</url>
      
        <content type="html"><![CDATA[<blockquote><p>值传递（值调用）（call by value）是指在调用函数式将实际参数<strong>复制</strong>一份传递到函数中,这样在函数中如果对参数进行修改，将不会影响到实际参数。<br>  引用传递（引用调用）（pass by reference）是指在调用函数时将实际参数的地址<strong>直接传递</strong>到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p></blockquote><h2 id="误解"><a href="#误解" class="headerlink" title="误解"></a>误解</h2><ul><li>错解一：Java有引用传递。</li><li>错解二：区分值传递和引用传递的依据是方法参数的内容，如果方法参数是值，就是值传递。如果方法参数引用，就是引用传递。</li><li>错解三：方法参数如果是普通数据类型，那就是值传递。如果是对象，那就是引用传递。</li></ul><h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p>  方法参数是基本类型时，方法接收的是调用者提供的值。方法不会修改传递给它的参数的参数变量的内容。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token function">doubleValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//该方法调用后，value值仍然为5.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面是一段最简单的代码，可以看出：一个方法不可能修改一个基于基本数据类型的参数。<br>下面的代码是修改员工工资，中将雇员的薪金提高一倍：  </p><pre class="line-numbers language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doubleSalary</span><span class="token punctuation">(</span>Employ x<span class="token punctuation">)</span><span class="token punctuation">{</span>  x<span class="token punctuation">.</span><span class="token function">raiseSalary</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//将工资提高二倍</span>  <span class="token punctuation">}</span>  xiaomi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span>······<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">doubleValue</span><span class="token punctuation">(</span>migaoyang<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>具体执行过程为：</p><ol><li>x被初始化为xiaomi值的<strong>拷贝</strong>，这里是一个对象的引用。  </li><li>raiseSalary方法将用于这个对象的引用。x与xiaomi同时引用的那个Employee对象的薪水提高一倍。  </li><li>方法结束后，参数变量x不再使用。对象变量xiaomi继续引用那个薪水提高一倍的雇员对象。  </li></ol></blockquote><p>结果确实是修改了被传入的对象，因此许多程序员认为Java对对象采用的是引用调用，实际上这种理解是不对的，下面是一个反例：<br>首先编写一个交换两个雇员对象的方法：  </p><pre class="line-numbers language-Java"><code class="language-Java">public static void swap(Employee x,Employee y){  employee temp = x;  x = y;  y = temp;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果Java对象采用的是按引用调用，那么上面的代码就能实现交换对象的效果。</p><pre class="line-numbers language-java"><code class="language-java">Employee a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"Alice"</span>······<span class="token punctuation">)</span><span class="token punctuation">;</span>Emplouee b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Emplouee</span><span class="token punctuation">(</span><span class="token string">"bob"</span>······<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但是，swap方法并没有改变a与b中的对象引用。swap方法的参数x与y被初始化为两个队下对象引用的拷贝，swap方法交换的是这两个拷贝。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//x reference to Alice,y to bob</span>Employee temp <span class="token operator">=</span> x<span class="token punctuation">;</span>x <span class="token operator">=</span> y<span class="token punctuation">;</span>y <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//now x reference to bob,y to Alice</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，在方法结束运行时参数变量x与y就被丢弃了，而被丢弃的这俩x与y是a与b引用地址的拷贝，通过x与y确实能找到被引用的对象，进而可以修改所指向对象的属性。但是swap方法结束后x与y就会被丢弃，之前变量a与b仍然引用swap方法调用之前所引用的对象。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>比较上面的三个例子，最重要的是后两个例子，为什么都是对象，一个被传进去的对象被改变了而另一并不改变呢？我想许多人对Java是否有引用传递的疑惑就在在这里。再根据值传递与引用传递的定义来看，区分这两者的根本就是被传进去的参数是否是被<strong>复制</strong>的，我们再传一个对象给方法时候，实际是将这个对象引用的值复制了一份，然后再传进方法，方法里是通过这个被复制的引用的值去找对象的（此时也就是有两个对象的引用共同指向一个对象），所以从值传递与引用传递的定义来看，传递对象也是值引用。  </p><p>再看开始的三个疑惑，其实区分值传递与引用传递的根本在于传递的参数是否有备份，Java里仅有值传递，方法参数是对象是也是值传递。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java源码-剖析HashMap</title>
      <link href="/2019/08/16/Java%20HashMap/"/>
      <url>/2019/08/16/Java%20HashMap/</url>
      
        <content type="html"><![CDATA[<p>ArrayList与LinkedList的缺点就是按元素内容查找值时，查找元素的时间复杂度都较高，而HashMap查找元素的时间复杂度可以达到O(1)!<br>Map在这里是映射的关系，K-V之间相互映射，计算K的hashCode值，根据这个值去计算（取模 数组的长度）HashMap内部所维护数组的索引i，当然，这个i值可能会重复，对于重复的值，在java7中使用链表继续存储。<strong>数组里存的内容也是一个Entry对象。</strong><br>取值时要通过K来取，若K的hash值所找到的位置发生了hash碰撞（有链表），就使用equal方法比较具体的K值。  </p><h3 id="HashMap所实现的Map接口"><a href="#HashMap所实现的Map接口" class="headerlink" title="HashMap所实现的Map接口"></a>HashMap所实现的Map接口</h3><p>Map有键（Key）与V（value），并且这俩是相对应的，由键间接的得到要存储与访问的地址，所以键（Key）是不能重复的，如果重复了，其所对应的值也会被覆盖掉。在以下场景中使用Map会很方便：  </p><blockquote><ol><li>一个词典应用，键可以为单词，值可以为单词信息类，包括含义、发音、例句等。  </li><li>统计和记录一本书中所有单词出现的次数，可以以单词为键，出现次数为值。  </li><li>管理配置文件中的配置项，配置项是典型的键值对。  </li><li>根据身份证号查询人员信息，身份证号为键，人员信息为值。    </li></ol></blockquote><p>其实从一一对应的角度来说，array、ArrayList、LinkedList也可以看作为一种特殊的Map，将他们的索引看做键（Key），将元素内容（对象）看做值。<br>Map接口：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">containsKey</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">containsValue</span><span class="token punctuation">(</span>Object value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">putAll</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Set<span class="token operator">&lt;</span>K<span class="token operator">></span> <span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span><span class="token punctuation">;</span>    V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span><span class="token punctuation">;</span>    V <span class="token function">remove</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span><span class="token punctuation">;</span>    Collection<span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Set<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">>></span> <span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">interface</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>        K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        V <span class="token function">setValue</span><span class="token punctuation">(</span>V value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Map接口中的方法都比较简单，其中put方法中，判断Key是否重复的依据是要么为null（存在索引为0的位置）要么equal返回false。  </p><h3 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h3><p>HashMap内部主要维护了以下成员变量：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">transient</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table <span class="token operator">=</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> EMPTY_TABLE<span class="token punctuation">;</span><span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//实际键值对的个数</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>数组table初始化为EMPTY_TABLE，而EMPTY_TABLE定义为一个静态常量的空表。table会随着实际情况（与threshold有关）进行长度的增加，类似于ArrayList，不过添加第一个元素时默认分配长度为16（ArrayList初始长度不为空表，长度为10）。threshold表示阈值，当键值对个数size大于等于threshold时考虑进行扩展,threshold = table.length*loadFactor。loadFactor是负载因子，<strong>表示整体上table能被占用的程度</strong> ，默认值为0.75，可以通过构造方法修改。<br>HashMap里面也有一个内部类Entry，它实现了Map接口的内部接口Entry&lt;K,V&gt;。上面的table是一个HashMap内部类Entry类型的数组，数组的每个元素指向一个单链表（索引重复时放链表），并且这个链表的每个节点表示一个键值对。 HashMap中的内部类Entry主要如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">final</span> K key<span class="token punctuation">;</span>  V value<span class="token punctuation">;</span>  Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>  <span class="token keyword">int</span> hash<span class="token punctuation">;</span>  <span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> K k<span class="token punctuation">,</span> V v<span class="token punctuation">,</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>      value <span class="token operator">=</span> v<span class="token punctuation">;</span>      next <span class="token operator">=</span> n<span class="token punctuation">;</span>      key <span class="token operator">=</span> k<span class="token punctuation">;</span>      hash <span class="token operator">=</span> h<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p>其中int型的hash记录每个Key的哈希值，减少了哈希值的计算次数。Entry型的next指向下一个Entry节点。<br>以下是使用put方法进行键值对保存的过程：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> EMPTY_TABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是第一次保存键值对（初始为空表），就会调用inflateTable()方法给table分配空间，inflateTable方法主要如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inflateTable</span><span class="token punctuation">(</span><span class="token keyword">int</span> toSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Find a power of 2 >= toSize</span>    <span class="token keyword">int</span> capacity <span class="token operator">=</span> <span class="token function">roundUpToPowerOf2</span><span class="token punctuation">(</span>toSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>capacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认情况下，capacity的值为16，threshold会变为12，table会分配一个长度为16的Entry数组。然后若key是否为null调用putForNullKey单独处理（后面再说），否则调用hash（）方法计算key的哈希值，hash（）方法的代码为：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">0</span>    h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>基于key自身的hashCode方法的返回值，又进行了一些位运算，目的是为了随机和均匀性。  </p></blockquote><p>有了hash值之后，调用indexFor方法，计算应该将这个键值对要放到数组table的索引，代码为：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>HashMap中，<strong>length为2的幂次方</strong>，<strong>h&amp;(length-1)</strong> 等同于求模运算：<strong>h%length</strong>。<br>找到了保存位置i，table[i]指向一个单向链表，接下来，就是在这个链表中逐个查找是否已经有这个键了，遍历代码为：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>而比较的时候，是先比较hash值，hash相同的时候，再使用equals方法进行比较，代码为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>先比较hash是因为hash是整数，比较的性能一般要比equals比较高很多，如果连hash都不同，就没有必要调用equals方法了，这样整体上可以提高比较性能。如果能找到，直接修改Entry中的value即可。modCount++的意义与ArrayList和LinkedList中的一样，记录修改次数，以方便在迭代中检测结构性变化。如果没找到，则调用addEntry方法在给定的位置添加一条，代码为：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果空间是够的，不需要resize，则调用createEntry添加，createEntry的代码为：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码比较直接，新建一个Entry对象，并插入单向链表的头部，并增加size。<br>如果空间不够，即size已经要超过阈值threshold了，并且对应的table位置已经插入过对象了，具体检查代码为：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>则调用resize方法对table进行扩展，扩展策略是乘2，resize的主要代码为：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">,</span> <span class="token function">initHashSeedAsNeeded</span><span class="token punctuation">(</span>newCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分配一个容量为原来两倍的Entry数组</strong>，调用transfer方法将原来的键值对移植过来，然后更新内部的table变量，以及threshold的值。<strong>transfer</strong> 方法的代码为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>null <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span>hash <span class="token operator">=</span> null <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//重新计算在新数组里的i值</span>            e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            e <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数rehash一般为false。这段代码遍历原来的每个键值对，计算新位置，并保存到新位置。<br>以上，就是保存键值对的主要代码，简单总结一下，基本步骤为：</p><ol><li>计算键的哈希值</li><li>根据哈希值得到保存位置（取模）</li><li>插到对应位置的链表头部或更新已有值</li><li>根据需要扩展table大小   </li></ol><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">getForNullKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> entry <span class="token operator">=</span> <span class="token function">getEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null <span class="token operator">==</span> entry <span class="token operator">?</span> null <span class="token operator">:</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>HashMap的key可以为null</strong> ，key为null的时候，放在table[0]，调用getForNullKey()获取值，如果key不为null，则调用getEntry()获取键值对节点entry，然后调用节点的getValue()方法获取值。getEntry方法的代码是：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getEntry</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         e <span class="token operator">!=</span> null<span class="token punctuation">;</span>         e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> e<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本思想如下：  </p><ol><li>计算键的hash值；</li><li>根据hash找到table中的对应链表；</li><li>在链表中遍历查找；</li><li>逐个比较，先通过hash快速比较，hash相同再通过equals比较；</li></ol><h4 id="方法containsValue-查看是否包含某些值"><a href="#方法containsValue-查看是否包含某些值" class="headerlink" title="方法containsValue()  查看是否包含某些值"></a>方法containsValue()  查看是否包含某些值</h4><p>HashMap可以方便高效的按照键进行操作，但如果要根据值进行操作，则需要遍历，containsValue方法的代码为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsValue</span><span class="token punctuation">(</span>Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">containsNullValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tab<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">;</span> e <span class="token operator">!=</span> null <span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要查找的值为null，则调用containsNullValue单独处理，我们看不为null的情况，遍历的逻辑也很简单，就是从table的第一个链表开始，从上到下，从左到右逐个节点进行访问，通过equals方法比较值，直到找到为止。  </p><h4 id="方法remove-根据键删除键值对"><a href="#方法remove-根据键删除键值对" class="headerlink" title="方法remove()  根据键删除键值对"></a>方法remove()  根据键删除键值对</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">remove</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> <span class="token function">removeEntryForKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>removeEntryForKey()方法的代码为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">removeEntryForKey</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> prev <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            modCount<span class="token operator">++</span><span class="token punctuation">;</span>            size<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> e<span class="token punctuation">)</span>                table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token keyword">else</span>                prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordRemoval</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> e<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        prev <span class="token operator">=</span> e<span class="token punctuation">;</span>        e <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本逻辑为：</p><ol><li>计算hash，根据hash找到对应的table索引;</li><li>遍历table[i]，查找待删节点，使用变量prev指向前一个节点，next指向下一个节点，e指向当前节点，遍历结构代码为：</li></ol><blockquote><pre class="line-numbers language-java"><code class="language-java">Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> prev <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> prev<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>找到了<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//删除</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span>prev <span class="token operator">=</span> e<span class="token punctuation">;</span>e <span class="token operator">=</span> next<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>`</code></p></blockquote><ol start="3"><li>判断是否找到，依然是先比较hash，hash相同时再用equals方法比较;  </li><li>删除的逻辑就是让长度减小，然后让待删节点的前后节点连起来，如果待删节点是第一个节点，则让table[i]直接指向后一个节点;<br>e.recordRemoval(this);在HashMap中代码为空，主要是为了HashMap的子类扩展使用。  <h4 id="实现原理小结"><a href="#实现原理小结" class="headerlink" title="实现原理小结"></a>实现原理小结</h4>HashMap内部有一个数组table，<strong>每个元素table[i]指向一个单向链表</strong> ，根据键存取值，用键算出hash，取模得到数组中的索引位置buketIndex，然后操作table[buketIndex]指向的单向链表。<br>存取的时候依据键的hash值，只在对应的链表中操作，不会访问别的链表，在对应链表操作时也是先比较hash值，相同的话才用equals方法比较，这就要求，相同的对象其hashCode()返回值必须相同，如果键是自定义的类，就特别需要注意这一点。这也是hashCode和equals方法的一个关键约束，这个约束我们在介绍包装类的时候也提到过。</li></ol><h3 id="HashMap总结"><a href="#HashMap总结" class="headerlink" title="HashMap总结"></a>HashMap总结</h3><p>HashMap实现了Map接口，内部使用数组链表和哈希的方式进行实现，这决定了它有如下特点：</p><ol><li>根据键保存和获取值的效率都很高，为O(1)，每个单向链表往往只有一个或少数几个节点，根据hash值就可以直接快速定位。</li><li>HashMap中的键值对没有顺序，因为hash值是随机的。  </li></ol><p>如果经常需要根据键存取值，而且不要求顺序，那HashMap就是理想的选择。<br>根据哈希值存取对象、比较对象是计算机程序中一种重要的思维方式，它使得存取对象主要依赖于自身哈希值，而不是与其他对象进行比较，存取效率也就与集合大小无关，高达O(1)，即使进行比较，也利用哈希值提高比较性能。不过HashMap没有顺序，如果要保持添加的顺序，可以使用<strong>HashMap的一个子类LinkedHashMap</strong>，子类LinkedHashMap可以排序。</p><p><code>`</code></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> java源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务</title>
      <link href="/2019/07/15/Java%20Web%20%20Transaction/"/>
      <url>/2019/07/15/Java%20Web%20%20Transaction/</url>
      
        <content type="html"><![CDATA[<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务指一组操作，要么全部执行，要么全都不执行。也就是最小的执行单位是定义的这一组事务。<br><strong>事务的作用</strong><br>　为了确保逻辑的成功执行。 例如：银行的转账。  </p><p> <strong>事务的特性 ACID</strong>  </p><ol><li>原子性  Atomicity<br>事务中包含的逻辑，不可分割。   </li><li>一致性  Consistency<br>事务执行前后。数据完整性  </li><li>隔离性  Isolation<br>事务在执行期间不应该受到其他事务的影响,两个事务的结果不应该相互影响。    </li><li>持久性  Durability<br>事务执行成功，那么数据应该持久保存到磁盘上。  </li></ol><h3 id="事务安全问题"><a href="#事务安全问题" class="headerlink" title="事务安全问题"></a>事务安全问题</h3><p><strong>读问题</strong><br>在读操作时可能会出现以下三种等级的错误 1.脏读 2.不可重读读 3.幻读  </p><ol><li>脏读<br>A事务读B事务还未提交的数据。  </li><li>不可重复读<br>A事务读到了B事务提交的数据，造成了A前后两次查询结果不一致。  </li><li>幻读<br>A事务读到了B事务insert的数据，造成了A前后两次查询结果不一致 。</li></ol><p>脏读是因为读到了未提交的还会回滚的数据导致的两次结果不一致（第一次脏数据，第二次正确数据），不可重复读是由于B提交而读到两次结果不一样（第一次未提交，第二次已提交正确数据）。  </p><p><strong>读问题的解决方案–隔离级别</strong>      </p><ol><li>读未提交   <strong>Read Uncommite</strong><br>　　A事务读到B事务未提交的事务，而B可能回滚，引起－－脏读问题。    </li><li>读已提交   <strong>Read Committed</strong><br>　　A事务第一次读到B事务未提交的数据，第二次读到B数据提交的数据，造成了A事务前后两次不同的结果。这个隔离级别能够屏蔽 <strong>脏读</strong> 的问题， 但是引发了另一个问题－－ <strong>不可重复读</strong>  。  </li><li>重复读  <strong>Repeatable Read</strong><br>　　AB两个事务，B事务进行了修改还未提交，A查询还是B事务修改之前的结果。B事务进行了提交，A查询结果仍是B事务修改之前的结果。也就是在可重复读的隔离级别中，AB是两个相互独立的互不影响。可重复读虽然解决了不可重复读的问题，但是这个隔离级别某种程度来说，在实际中的作用并不大。并且这个隔离级别还没有解决－－幻读的问题。</li><li>可串行化  <strong>Serializable</strong><br>　　解决了幻读问题。如果有一个连接的隔离级别设置为了串行化 ，那么谁先打开了事务， 谁就有了先执行的权利， 谁后打开事务，谁就只能得着，等前面的那个事务，提交或者回滚后，才能执行。例如：B先打开了一个事务，A又打开了一个事物，此时B不管是否已经修改，只要还没有提交，A的查询都会一直阻塞着，一直等B提交之后A才会有查询的结果。但是这种隔离级别一般比较少用。容易造成性能上的问题。效率比较低。</li></ol><ul><li><p>按效率划分，从高到低  </p><blockquote><p>读未提交  &gt; 读已提交  &gt; 可重复读  &gt; 可串行化</p></blockquote></li><li><p>按拦截程度 ，从高到底  </p><blockquote><p>可串行化 &gt; 可重复读 &gt; 读已提交 &gt;  读未提交  </p></blockquote></li></ul><p><strong>写问题</strong>  </p><ul><li>丢失更新<br>　　AB事务同时建立，A修改了一部分数据并提交，B修改了另外一部分数据进行提交，结果A的修改丢失了，最后的结果只有B自己修改的数据，A的修改被覆盖了，同时假设B在上面的过程中修改后被回滚，那么AB的修改都不会被保存。  </li></ul><p><strong>写问题的解决方案–锁</strong><br>悲观锁，认为一定会出现丢失更新。<br>乐观锁，认为一定不会出现丢失更新。</p><ol><li><p>悲观锁<br>　　<strong>for update</strong> 数据库的锁机制，也叫排他锁。A事务先建立，B事务后建立，和可串行化类似，B会等A提交后再进行操作（B可以在A修改的基础上进行修改）。</p></li><li><p>乐观锁<br>　　乐观锁需要开发者手动控制，可以加一个字段（可以为一个时间戳或者标志）。例如新加了一个字段version，AB两个事务的version都为0，当A修改后提交时候将version修改为1并保存，B要提交修改的时候比较自己的version与数据库里的version值，如果一样，可以直接将本次的提交存下来，否则就将再次获取数据库里的数据，重新进行修改、提交。  </p></li></ol><h3 id="代码里的事务"><a href="#代码里的事务" class="headerlink" title="代码里的事务"></a>代码里的事务</h3><p>作用：代码里面的事务，主要是用来数据库连接的。  </p><blockquote><p>通过conn.setAutoCommit（false ）来关闭自动提交的设置。<br>提交事务  conn.commit();<br>回滚事务 conn.rollback();  </p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Connection conn <span class="token operator">=</span> null<span class="token punctuation">;</span>    PreparedStatement ps <span class="token operator">=</span> null<span class="token punctuation">;</span>    ResultSet rs <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        conn <span class="token operator">=</span> JDBCUtil<span class="token punctuation">.</span><span class="token function">getConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//JDBCUtil是自己编写的JDBC工具类</span>        <span class="token comment" spellcheck="true">//连接，事务默认就是自动提交的。 关闭自动提交。</span>        conn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String sql <span class="token operator">=</span> <span class="token string">"update account set money = money - ? where id = ?"</span><span class="token punctuation">;</span>        ps <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//扣钱， 扣ID为1 的100块钱</span>        ps<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ps<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ps<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">/</span><span class="token number">0</span> <span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//加钱， 给ID为2 加100块钱</span>        ps<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ps<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ps<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//成功： 提交事务。</span>        conn<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//事变： 回滚事务</span>            conn<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e1<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        JDBCUtil<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> ps<span class="token punctuation">,</span> rs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="事务总结"><a href="#事务总结" class="headerlink" title="事务总结"></a>事务总结</h3><ol><li>事务只是针对连接连接对象，如果再开一个连接对象，那么那是默认的提交。</li><li>事务是会自动提交的。</li></ol><p><strong>隔离级别</strong><br>读未提交  </p><blockquote><p>引发问题： 脏读  </p></blockquote><p>读已提交  </p><blockquote><p>解决： 脏读 ， 引发： 不可重复读  </p></blockquote><p>可重复读  </p><blockquote><p>解决： 脏读 、 不可重复读 ， 未解决： 幻读   </p></blockquote><p>可串行化  </p><blockquote><p>解决： 脏读、 不可重复读 、 幻读。</p></blockquote><p>mySql 默认的隔离级别是 可重复读<br>Oracle 默认的隔离级别是  读已提交</p>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet（二）</title>
      <link href="/2019/06/29/Java%20Web%20%20Servlet2/"/>
      <url>/2019/06/29/Java%20Web%20%20Servlet2/</url>
      
        <content type="html"><![CDATA[<p>提要：Servlet配置路径、ServletConfig、ServletContext、</p><h3 id="1-Servlet配置路径（xml或者注解）"><a href="#1-Servlet配置路径（xml或者注解）" class="headerlink" title="1. Servlet配置路径（xml或者注解）"></a>1. Servlet配置路径（xml或者注解）</h3><p>假设项目名称为a。  </p><ol><li><p><strong>全路径匹配</strong>  </p><blockquote><p>以 / 开始　/a/aa/bb<br>localhost:8080/项目名称/aa/bb  </p></blockquote></li><li><p><strong>路径匹配 , 前半段匹配</strong>   </p><blockquote><p> 以/ 开始 , 但是以 * 结束 　　   / a / */*<br>符号 * 其实是一个通配符，匹配任意文字<br>localhost:8080/项目名称/aa/bb</p></blockquote></li><li><p><strong>以扩展名匹配</strong>    </p><blockquote><p>写法： 没有/　以 * 开始　　*.扩展名　　*.aa　　*.bb</p></blockquote></li></ol><h3 id="2-ServletConfig"><a href="#2-ServletConfig" class="headerlink" title="2. ServletConfig"></a>2. ServletConfig</h3><p>单个Servlet类的配置对象，通过这个对象，可以获取servlet在配置的时候一些信息  </p><h4 id="2-1-ServletConfig作用"><a href="#2-1-ServletConfig作用" class="headerlink" title="2.1 ServletConfig作用"></a>2.1 ServletConfig作用</h4><p>可以获取、设置单个servlet类的配置参数。例如当使用jar文件（class）放在自己的servlet类里面时，配置参数不固定，就可以使用ServletConfig方便的设置配置参数。  </p><h4 id="2-2-使用方法"><a href="#2-2-使用方法" class="headerlink" title="2.2 使用方法"></a>2.2 使用方法</h4><pre class="line-numbers language-java"><code class="language-java">  <span class="token comment" spellcheck="true">//1. 得到servlet配置对象 专门用于在配置servlet的信息  </span>  ServletConfig config <span class="token operator">=</span> <span class="token function">getServletConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取到的是配置servlet里面servlet-name 的文本内容  </span>  String servletName <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getServletName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"servletName="</span><span class="token operator">+</span>servletName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2、 可以获取具体的某一个参数。  </span>  String address <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getInitParameter</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"address="</span><span class="token operator">+</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3.获取所有的参数名称  </span>  Enumeration<span class="token operator">&lt;</span>String<span class="token operator">></span> names <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getInitParameterNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//遍历取出所有的参数名称  </span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String key <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> names<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String value <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getInitParameter</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"key==="</span><span class="token operator">+</span>key <span class="token operator">+</span> <span class="token string">"   value="</span><span class="token operator">+</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-ServletContext"><a href="#3-ServletContext" class="headerlink" title="3. ServletContext"></a>3. ServletContext</h3><p>每个web工程都只有一个ServletContext对象。也就是不管在哪个servlet里面，获取到的这个类的对象都是同一个。  </p><h4 id="3-1-ServletContext的作用"><a href="#3-1-ServletContext的作用" class="headerlink" title="3.1 ServletContext的作用"></a>3.1 ServletContext的作用</h4><ol><li>获取全局配置参数</li><li>获取web工程中的资源</li><li>存取数据，servlet间共享数据域对象  </li></ol><h5 id="3-1-1-ServletContext获取全局配置参数的方法"><a href="#3-1-1-ServletContext获取全局配置参数的方法" class="headerlink" title="3.1.1 ServletContext获取全局配置参数的方法()"></a>3.1.1 ServletContext获取全局配置参数的方法()</h5><pre class="line-numbers language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>  web<span class="token punctuation">.</span>xml文件里面 全局参数 ： 任何servlet都可以用，ServletContext <span class="token operator">--</span><span class="token operator">></span> <span class="token operator">&lt;</span>context<span class="token operator">-</span>param<span class="token operator">></span>   <span class="token operator">&lt;</span>param<span class="token operator">-</span>name<span class="token operator">></span>address<span class="token operator">&lt;</span><span class="token operator">/</span>param<span class="token operator">-</span>name<span class="token operator">></span>   <span class="token operator">&lt;</span>param<span class="token operator">-</span>value<span class="token operator">></span>深圳宝安<span class="token operator">&lt;</span><span class="token operator">/</span>param<span class="token operator">-</span>value<span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">/</span>context<span class="token operator">-</span>param<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取全局参数</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>    <span class="token function">doGet</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//1. 获取对象</span>    ServletContext context <span class="token operator">=</span> <span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String address <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getInitParameter</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是01获取的数据：：address="</span><span class="token operator">+</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-1-2-可以获取Web应用中的资源"><a href="#3-1-2-可以获取Web应用中的资源" class="headerlink" title="3.1.2 可以获取Web应用中的资源"></a>3.1.2 可以获取Web应用中的资源</h5><ol><li>获取资源在tomcat里面的绝对路径<br> 先得到路径，然后自己new InpuStream  <pre><code>   context.getRealPath(&quot;&quot;) //这里得到的是项目在tomcat里面的根目录。   D:\tomcat\apache-tomcat-7.0.52\apache-tomcat-7.0.52\wtpwebapps\Demo03\     String path = context.getRealPath(&quot;file/config.properties&quot;);   D:\tomcat\apache-tomcat-7.0.52\apache-tomcat-7.0.52\wtpwebapps\Demo03\file\config.properties</code></pre></li></ol><ol start="2"><li>getResourceAsStream 获取资源流对象。<br>直接给相对的路径，然后获取流对象。  </li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//获取web工程下的资源，转化为流对象。</span>InputStream is <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getResouceAsStream</span><span class="token punctuation">(</span><span class="token string">"file/config.properties"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-2-ServletContext周期"><a href="#3-2-ServletContext周期" class="headerlink" title="3.2 ServletContext周期"></a>3.2 ServletContext周期</h4><p>服务器启动的时候，会为托管的每一个web应用程序，创建一个ServletContext对象。<br>销毁该对象的方法：从服务器移除托管，或者是关闭服务器。   </p><h4 id="3-3-ServletContext的作用范围"><a href="#3-3-ServletContext的作用范围" class="headerlink" title="3.3 ServletContext的作用范围"></a>3.3 ServletContext的作用范围</h4><p>只要在同一个web项目里面，也就是同一个ServletContext对象，都可以取。</p><h3 id="4-HttpServletRequset"><a href="#4-HttpServletRequset" class="headerlink" title="4. HttpServletRequset"></a>4. HttpServletRequset</h3><p>HttpServletRequset类对象封装了客户端提交的一切数据。  </p><h4 id="4-1-可以获取客户端请求头信息"><a href="#4-1-可以获取客户端请求头信息" class="headerlink" title="4.1. 可以获取客户端请求头信息"></a>4.1. 可以获取客户端请求头信息</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//得到一个枚举集合  </span>Enumeration<span class="token operator">&lt;</span>String<span class="token operator">></span> headerNames <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeaderNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>headerNames<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      String name <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> headerNames<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      String value <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token operator">+</span><span class="token string">"="</span><span class="token operator">+</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-获取客户端提交过来的数据"><a href="#4-2-获取客户端提交过来的数据" class="headerlink" title="4.2. 获取客户端提交过来的数据"></a>4.2. 获取客户端提交过来的数据</h4><pre class="line-numbers language-java"><code class="language-java">String name <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String address <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name="</span><span class="token operator">+</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"address="</span><span class="token operator">+</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//-------------------------------------------------</span><span class="token comment" spellcheck="true">//name=zhangsan&amp;name=lisi&amp;name=wangwu 一个key可以对应多个值。</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> map <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameterMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set<span class="token operator">&lt;</span>String<span class="token operator">></span> keySet <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> iterator <span class="token operator">=</span> keySet<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String key <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"key="</span><span class="token operator">+</span>key <span class="token operator">+</span> <span class="token string">"--的值总数有："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        String value <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        String value1 <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        String value2 <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token operator">+</span><span class="token string">" ======= "</span><span class="token operator">+</span> value <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value1 <span class="token operator">+</span> <span class="token string">"="</span><span class="token operator">+</span> value2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-request获取中文数据乱码"><a href="#5-request获取中文数据乱码" class="headerlink" title="5. request获取中文数据乱码"></a>5. request获取中文数据乱码</h3><p>客户端提交数据给服务器端，如果数据中带有中文的话，有可能会出现乱码情况。  </p><ul><li><p><strong>GET方式</strong>  </p><ol><li>转码代码</li></ol></li></ul><pre class="line-numbers language-java"><code class="language-java">            String username <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String password <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"userName="</span><span class="token operator">+</span>username<span class="token operator">+</span><span class="token string">"==password="</span><span class="token operator">+</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//get请求过来的数据，在url地址栏上就已经经过编码了，所以我们取到的就是乱码，</span>            <span class="token comment" spellcheck="true">//tomcat收到了这批数据，getParameter 默认使用ISO-8859-1去解码</span>            <span class="token comment" spellcheck="true">//先让文字回到ISO-8859-1对应的字节数组 ， 然后再按utf-8组拼字符串</span>            username <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>username<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"userName="</span><span class="token operator">+</span>username<span class="token operator">+</span><span class="token string">"==password="</span><span class="token operator">+</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>2. 可以在tomcat里面做设置处理，以后get请求过来的数据永远都是用UTF-8编码。</code></pre><p>  conf/server.xml 加上URIEncoding=”utf-8”</p><pre class="line-numbers language-java"><code class="language-java">          <span class="token operator">&lt;</span>Connector connectionTimeout<span class="token operator">=</span><span class="token string">"20000"</span> port<span class="token operator">=</span><span class="token string">"8080"</span> protocol<span class="token operator">=</span><span class="token string">"HTTP/1.1"</span>  redirectPort<span class="token operator">=</span><span class="token string">"8443"</span> URIEncoding<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">/</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>POST方式</strong><br>需要设置请求体里面的文字编码。<br><strong>request.setCharacterEncoding(“UTF-8”);</strong><br>这行设置一定要写在getParameter方法之前之前。  </li></ul><h3 id="6-HttpServletResponse"><a href="#6-HttpServletResponse" class="headerlink" title="6. HttpServletResponse"></a>6. HttpServletResponse</h3><p>负责返回数据给客户端。</p><ul><li>输出数据到页面上</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//以字符流的方式写数据</span>response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"&lt;h1>hello response...&lt;/h1>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//以字节流的方式写数据</span>response<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"hello response2222..."</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="响应的数据中有中文，则有可能出现中文乱码情况"><a href="#响应的数据中有中文，则有可能出现中文乱码情况" class="headerlink" title="响应的数据中有中文，则有可能出现中文乱码情况"></a>响应的数据中有中文，则有可能出现中文乱码情况</h4><ul><li>以字符流输出    <blockquote><p>response.getWriter()  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1. 指定输出到客户端的时候，这些文字使用UTF-8编码</span>response<span class="token punctuation">.</span><span class="token function">setCharacterEncoding</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote></li></ul><p>//2. 直接规定浏览器看这份数据的时候，使用什么编码来看。<br>response.setHeader(“Content-Type”, “text/html; charset=UTF-8”);</p><p>response.getWriter().write(“响应…”);</p><pre><code>+ 以字节流输出&gt; response.getOutputStream()​```java  //1. 指定浏览器看这份数据使用的码表response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;);//2. 指定输出的中文用的码表response.getOutputStream().write(&quot;响应..&quot;.getBytes(&quot;UTF-8&quot;));</code></pre><p><strong>不管是字节流还是字符流，直接使用下面一行代码就可以了。</strong><br><strong>response.setContentType(“text/html;charset=UTF-8”);</strong> 然后在写数据即可。</p>]]></content>
      
      
      <categories>
          
          <category> Servlet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet（一）</title>
      <link href="/2019/06/16/Java%20Web%20%20Servlet1/"/>
      <url>/2019/06/16/Java%20Web%20%20Servlet1/</url>
      
        <content type="html"><![CDATA[<p>提要：Servlet执行过程、执行周期。  </p><p>在java中，JVM是java程序唯一认识的“操作系统”，其可执行文件为 <strong>.class</strong> 。<br>在Servlet/JSP中，web容器（Container）是Servlet/JSP唯一认识的HTTP服务器。我们需要知道Servlet/JSP与web容器是如何沟通的，web容器如何管理Servlet/JSP的各种对象等问题。  </p><h3 id="Hello-Servlet"><a href="#Hello-Servlet" class="headerlink" title="Hello Servlet"></a>Hello Servlet</h3><ol><li>新建一个类， 实现Servlet接口</li><li>配置Servlet ， 用意： 告诉服务器，我们的应用有这么些个servlet。<br>在webContent/WEB-INF/web.xml里面写上以下内容。  </li></ol><pre class="line-numbers language-java"><code class="language-java">  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 向tomcat报告， 这个应用里面有这个servlet， 名字叫做HelloServlet <span class="token punctuation">,</span> 具体的路径是com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>HelloServlet <span class="token operator">--</span><span class="token operator">></span>  <span class="token operator">&lt;</span>servlet<span class="token operator">></span>      <span class="token operator">&lt;</span>servlet<span class="token operator">-</span>name<span class="token operator">></span>HelloServlet<span class="token operator">&lt;</span><span class="token operator">/</span>servlet<span class="token operator">-</span>name<span class="token operator">></span>      <span class="token operator">&lt;</span>servlet<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">></span>com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>HelloServlet<span class="token operator">&lt;</span><span class="token operator">/</span>servlet<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>servlet<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 注册servlet的映射。  servletName <span class="token operator">:</span> 找到上面注册的具体servlet，  url<span class="token operator">-</span>pattern<span class="token operator">:</span> 在地址栏上的path 一定要以<span class="token operator">/</span>打头 <span class="token operator">--</span><span class="token operator">></span>  <span class="token operator">&lt;</span>servlet<span class="token operator">-</span>mapping<span class="token operator">></span>      <span class="token operator">&lt;</span>servlet<span class="token operator">-</span>name<span class="token operator">></span>HelloServlet<span class="token operator">&lt;</span><span class="token operator">/</span>servlet<span class="token operator">-</span>name<span class="token operator">></span>      <span class="token operator">&lt;</span>url<span class="token operator">-</span>pattern<span class="token operator">></span><span class="token operator">/</span>a<span class="token operator">&lt;</span><span class="token operator">/</span>url<span class="token operator">-</span>pattern<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>servlet<span class="token operator">-</span>mapping<span class="token operator">></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>在地址栏上输入 <a href="http://localhost:8080/项目名称/a" target="_blank" rel="noopener">http://localhost:8080/项目名称/a</a></li></ol><h3 id="Servlet执行过程（xml方式）"><a href="#Servlet执行过程（xml方式）" class="headerlink" title="Servlet执行过程（xml方式）"></a>Servlet执行过程（xml方式）</h3><p><a href="http://localhost:8080/HelloServlet/a" target="_blank" rel="noopener">http://localhost:8080/HelloServlet/a</a></p><ol><li>tomcat应用</li><li>找到具体项目</li><li>找到web.xml，在Servlet-mapping部分找url-pattern与a相对应的servlet-name。</li><li>在servlet部分找到servlet-name相对应的servlet-class</li><li>找到具体的类后创建该类实例</li><li>执行Servlet中的service方法  </li></ol><h3 id="Servlet的通用写法"><a href="#Servlet的通用写法" class="headerlink" title="Servlet的通用写法"></a>Servlet的通用写法</h3><blockquote><pre><code>   Servlet (接口)        |        |    GenericServlet        |        |    HttpServlet （用于处理http的请求）  </code></pre></blockquote><p>例如： 定义一个类，继承HttpServlet 复写doGet 和 doPost</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloServlet02</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//Get请求会来这个方法</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest req<span class="token punctuation">,</span> HttpServletResponse resp<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"get---"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//POST请求会来这个方法</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span>HttpServletRequest req<span class="token punctuation">,</span> HttpServletResponse resp<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"post----"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在service方法中的主要工作是判断是该使用doGet方法、doPost方法或者其他方法。  </p><h3 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h3><ul><li>生命周期</li></ul><blockquote><p>从创建到销毁的一段时间</p></blockquote><ul><li>生命周期方法</li></ul><blockquote><p>从创建到销毁，所调用的那些方法。</p></blockquote><ul><li><p>init方法</p><pre><code>  在创建该servlet的实例时，就执行该方法。  一个servlet只会初始化一次， init方法只会执行一次  默认情况下是 ： 初次访问该servlet，才会创建实例。</code></pre></li><li><p>service方法</p><pre><code>  只要客户端来了一个请求，那么就执行这个方法了。    该方法可以被执行很多次。 一次请求，对应一次service方法的调用</code></pre></li><li><p>destroy方法<br>servlet销毁的时候，就会执行该方法</p><pre><code>1. 该项目从tomcat的里面移除。2. 正常关闭tomcat就会执行 shutdown.bat</code></pre></li></ul><blockquote><p>doGet 和 doPost不算生命周期方法，所谓的生命周期方法是指，从对象的创建到销毁一定会执行的方法， 但是这两个方法，不一定会执行。</p></blockquote><h3 id="让Servlet创建实例的时机提前。"><a href="#让Servlet创建实例的时机提前。" class="headerlink" title="让Servlet创建实例的时机提前。"></a>让Servlet创建实例的时机提前。</h3><ol><li><p>默认情况下，只有在初次访问servlet的时候，才会执行init方法。 有的时候，我们可能需要在这个方法里面执行一些初始化工作，甚至是做一些比较耗时的逻辑。</p></li><li><p>那么这个时候，初次访问，可能会在init方法中逗留太久的时间。 那么改变思路，使用其他办法可以让这个初始化的时机提前一点。</p></li><li><p>在配置的时候， 使用load-on-startup元素来指定， 给定的数字越小，启动的时机就越早。 一般不写负数， 从2开始即可。</p></li></ol><pre class="line-numbers language-java"><code class="language-java">        <span class="token operator">&lt;</span>servlet<span class="token operator">></span>              <span class="token operator">&lt;</span>servlet<span class="token operator">-</span>name<span class="token operator">></span>HelloServlet04<span class="token operator">&lt;</span><span class="token operator">/</span>servlet<span class="token operator">-</span>name<span class="token operator">></span>              <span class="token operator">&lt;</span>servlet<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">></span>com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>HelloServlet04<span class="token operator">&lt;</span><span class="token operator">/</span>servlet<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">></span>              <span class="token operator">&lt;</span>load<span class="token operator">-</span>on<span class="token operator">-</span>startup<span class="token operator">></span><span class="token number">2</span><span class="token operator">&lt;</span><span class="token operator">/</span>load<span class="token operator">-</span>on<span class="token operator">-</span>startup<span class="token operator">></span>          <span class="token operator">&lt;</span><span class="token operator">/</span>servlet<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Servlet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用排序算法的java实现</title>
      <link href="/2019/06/01/Java%20Sort/"/>
      <url>/2019/06/01/Java%20Sort/</url>
      
        <content type="html"><![CDATA[<h1 id="BubbleSort"><a href="#BubbleSort" class="headerlink" title="BubbleSort"></a>BubbleSort</h1><p>起泡排序就是两两交换排序，可以将最大值或最小值放在一端，然后再从下个依次两两比较，将第二大或者第二小的放在一端第二个。  </p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bubble</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                data<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> data<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="InsertSort"><a href="#InsertSort" class="headerlink" title="InsertSort"></a>InsertSort</h1><p>InsertSort操作基本操作是将一个记录插入到<strong>已排好的有序表</strong>中。即对于给定的一组数据，初始时候假设第一个数据自成一个有序序列，其余记录为无序序列。接着从第二个数据开始，按照数据的大小依次将当前将要处理的数据插入到<strong>之前的有序序列</strong>中，直到最后一个记录插入到有序序列中为止。<br>以下为直接插入排序。        </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InsertSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> null <span class="token operator">||</span> data<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> data<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//从第二个数组数据开始</span>            <span class="token keyword">int</span> j <span class="token operator">=</span>i <span class="token punctuation">;</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//和有序序列的最后一个data[i-1]比较，若比data[i-1]还小，</span>                <span class="token comment" spellcheck="true">// 就进行有序序列的比较--数据后移</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> temp <span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                    data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/*            while (j > 0 &amp;&amp; data[j-1] > temp) {                    data[j] = data[j-1];                    j--;               }*/</span>                data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>        <span class="token keyword">return</span> data<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>折半插入排序 – 对于直接插入排序也可以和折半查找相结合。可以在直接插入的基础上减少“比较”与“移动”的次数。  </p><h1 id="MergingSort"><a href="#MergingSort" class="headerlink" title="MergingSort"></a>MergingSort</h1><p>归并排序与插入排序与起泡排序不同，“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表。<br>核心操作是将一维数组中前后相邻的两个有序序列归并为一个有序序列。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">,</span> n1<span class="token punctuation">,</span> n2<span class="token punctuation">;</span>    n1 <span class="token operator">=</span> q <span class="token operator">-</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    n2 <span class="token operator">=</span> r <span class="token operator">-</span> q<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> lPart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rPart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> p<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> k<span class="token operator">++</span><span class="token punctuation">)</span>        lPart<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n2<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> k<span class="token operator">++</span><span class="token punctuation">)</span>        rPart<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n1 <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n2<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lPart<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> rPart<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> lPart<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> rPart<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//寻找还有未融合完的部分序列</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n1<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">,</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> lPart<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n2<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> rPart<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="QuickSort"><a href="#QuickSort" class="headerlink" title="QuickSort"></a>QuickSort</h1><p>快速排序其实是对起泡排序的一种改进，其基本思想是：通过一趟排序将待排数据分割成独立的两部分，其中一部分数据的关键字均比另一部分的关键字小，然后就可以对这两部分数据再进行排序，已达到整个序列有序。  </p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quick</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">sort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token punctuation">,</span> <span class="token keyword">int</span> low <span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token punctuation">,</span> j <span class="token punctuation">;</span>    <span class="token keyword">int</span> index <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//pivot</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">>=</span> high <span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    i <span class="token operator">=</span> low<span class="token punctuation">;</span>    j <span class="token operator">=</span> high<span class="token punctuation">;</span>    index <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> index <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//use '>=' to be ensure stabilize</span>            j <span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>            data<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//data[i] = data[j] ; i++;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> index<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//not use '=' ensure stabilize</span>            i <span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>            data<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> index<span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span>low<span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// i = j</span>    <span class="token function">sort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="SelectSort"><a href="#SelectSort" class="headerlink" title="SelectSort"></a>SelectSort</h1><p>选择排序的基本思想是：每一趟在 n-i+1 个数据中选出数值最小的记录，然后作为有序序列的第i个数据。  </p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> null <span class="token operator">||</span> data<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> data<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//select min,set first</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> data<span class="token punctuation">.</span>length <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> min<span class="token punctuation">;</span>                min <span class="token operator">=</span>  data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ShellSort"><a href="#ShellSort" class="headerlink" title="ShellSort"></a>ShellSort</h2><p>希尔排序又称为“缩小增量排序”(Diminishing Increment Sort),其实希尔排序也是一种属于<strong>插入类</strong>的方法，但是在时间效率上有着较大的改进。<br>希尔排序的基本思想是：先将整个待排序列分割为若干子序列分别进行直接插入排序，在整个序列中的数据“基本有序”时候，再对全体数据进行一次直接插入排序（即增量为1）。   </p><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">shell</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> pace <span class="token operator">=</span> length<span class="token operator">/</span><span class="token number">2</span> <span class="token punctuation">;</span> pace <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">;</span> pace <span class="token operator">=</span> pace <span class="token operator">/</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//设置一个步长（增量）pace，每隔这个增量就是一个子序列。</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> pace <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span> j <span class="token operator">=</span> i <span class="token operator">-</span> pace <span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">;</span> j  <span class="token operator">-=</span> pace<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//初始j为第一个子序列的第一个数据</span>                <span class="token comment" spellcheck="true">//保证已经比较过的子序列是有序的，在自序列中为递增</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    data<span class="token punctuation">[</span>j<span class="token operator">+</span>pace<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//data[j+pace] == data[i] == temp</span>                <span class="token punctuation">}</span><span class="token keyword">else</span>                    <span class="token comment" spellcheck="true">//已经遍历的子序列已经有序，data[j]已为最大值</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                                <span class="token punctuation">}</span>            data<span class="token punctuation">[</span>j<span class="token operator">+</span>pace<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> data<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Sort </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连接池</title>
      <link href="/2019/05/06/Java%20Web%20%20ConnectionPool/"/>
      <url>/2019/05/06/Java%20Web%20%20ConnectionPool/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><ol><li>数据库连接的对象创建，比较消耗性能。     </li><li>一开始现在内存中开辟一块空间（以集合存起来）， 一开先往Pool里面放置多个连接对象。以后需要连接的话，直接从Pool里面取。不需要自己用到时再重头开始建立了。使用完毕，需要归还连接，确保连接对象能循环利用。  </li></ol><p>常用的开源连接池有DBCP（Apache）与C3P0  </p><h4 id="DBCP"><a href="#DBCP" class="headerlink" title="DBCP"></a>DBCP</h4><p>首先导入jar文件。<br><strong>方式一 不使用配置文件：</strong>   </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDBCP01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Connection conn <span class="token operator">=</span> null<span class="token punctuation">;</span>    PreparedStatement ps <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//1. 构建数据源对象</span>        BasicDataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BasicDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//连的是什么类型的数据库， 访问的是哪个数据库 ， 用户名， 密码</span>        <span class="token comment" spellcheck="true">//jdbc:mysql://localhost/bank 主协议：子协议 ://地址/数据库</span>        dataSource<span class="token punctuation">.</span><span class="token function">setDriverClassName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost/bank"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//2. 得到连接对象</span>            conn <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String sql <span class="token operator">=</span> <span class="token string">"insert into account values(null , ? , ?)"</span><span class="token punctuation">;</span>            ps <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>            ps<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ps<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ps<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            JDBCUtil<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> ps<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>方式二 使用配置文件方式</strong>   </p><pre class="line-numbers language-java"><code class="language-java">#dbcpconfig<span class="token punctuation">.</span>properties 配置文件#连接设置driverClassName<span class="token operator">=</span>com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>Driverurl<span class="token operator">=</span>jdbc<span class="token operator">:</span>mysql<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">:</span><span class="token number">3306</span><span class="token operator">/</span>jdbcusername<span class="token operator">=</span>rootpassword<span class="token operator">=</span><span class="token number">123456</span>#<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 初始化连接 <span class="token operator">--</span><span class="token operator">></span>initialSize<span class="token operator">=</span><span class="token number">10</span>#最大连接数量maxActive<span class="token operator">=</span><span class="token number">50</span>#<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 最大空闲连接 <span class="token operator">--</span><span class="token operator">></span>maxIdle<span class="token operator">=</span><span class="token number">20</span>#<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 最小空闲连接 <span class="token operator">--</span><span class="token operator">></span>minIdle<span class="token operator">=</span><span class="token number">5</span>#<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 超时等待时间以毫秒为单位 <span class="token number">6000</span>毫秒<span class="token operator">/</span><span class="token number">1000</span>等于<span class="token number">60</span>秒 <span class="token operator">--</span><span class="token operator">></span>maxWait<span class="token operator">=</span><span class="token number">60000</span>#JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：<span class="token punctuation">[</span>属性名<span class="token operator">=</span>property<span class="token punctuation">;</span><span class="token punctuation">]</span>#注意：<span class="token string">"user"</span> 与 <span class="token string">"password"</span> 两个属性会被明确地传递，因此这里不需要包含他们。connectionProperties<span class="token operator">=</span>useUnicode<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>characterEncoding<span class="token operator">=</span>gbk#指定由连接池所创建的连接的自动提交（auto<span class="token operator">-</span>commit）状态。defaultAutoCommit<span class="token operator">=</span><span class="token boolean">true</span>#driver <span class="token keyword">default</span> 指定由连接池所创建的连接的事务级别（TransactionIsolation）。#可用值为下列之一：（详情可见javadoc。）NONE<span class="token punctuation">,</span>READ_UNCOMMITTED<span class="token punctuation">,</span> READ_COMMITTED<span class="token punctuation">,</span> REPEATABLE_READ<span class="token punctuation">,</span> SERIALIZABLEdefaultTransactionIsolation<span class="token operator">=</span>READ_UNCOMMITTED<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">Connection conn <span class="token operator">=</span> null<span class="token punctuation">;</span>PreparedStatement ps <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    BasicDataSourceFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BasicDataSourceFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    InputStream is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"src//dbcpconfig.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>    DataSource dataSource <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createDataSource</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2. 得到连接对象</span>    conn <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String sql <span class="token operator">=</span> <span class="token string">"insert into account values(null , ? , ?)"</span><span class="token punctuation">;</span>    ps <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    ps<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"liangchaowei"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ps<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ps<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>    JDBCUtil<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> ps<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="C3P0（重要）"><a href="#C3P0（重要）" class="headerlink" title="C3P0（重要）"></a>C3P0（重要）</h3><p>拷贝jar文件到lib目录。<br><strong>方式一 不使用配置文件方式</strong>（不常用）   </p><pre class="line-numbers language-java"><code class="language-java">Connection conn <span class="token operator">=</span> null<span class="token punctuation">;</span>PreparedStatement ps <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//1. 创建datasource</span>    ComboPooledDataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2. 设置连接数据库的信息</span>    dataSource<span class="token punctuation">.</span><span class="token function">setDriverClass</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dataSource<span class="token punctuation">.</span><span class="token function">setJdbcUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost/bank"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dataSource<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dataSource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2. 得到连接对象</span>    conn <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String sql <span class="token operator">=</span> <span class="token string">"insert into account values(null , ? , ?)"</span><span class="token punctuation">;</span>    ps <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    ps<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"admi234n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ps<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">103200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ps<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>    JDBCUtil<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> ps<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方式二 使用配置文件方式</strong><br>C3P0配置文件支持properties与XML（用的较多）两种方式。 xml配置文件具体的内容资料或者官网都有，直接复制内容<br>即可，但是名字必须叫 c3p0-config.xml。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//默认会找 xml 中的 default-config 分支。</span>ComboPooledDataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2. 设置连接数据的信息</span><span class="token comment" spellcheck="true">// dataSource.setDriverClass("com.mysql.jdbc.Driver");</span><span class="token comment" spellcheck="true">// dataSource.setJdbcUrl("jdbc:mysql://localhost/bank");</span><span class="token comment" spellcheck="true">// dataSource.setUser("root");</span><span class="token comment" spellcheck="true">// dataSource.setPassword("root");</span><span class="token comment" spellcheck="true">//2. 得到连接对象</span>conn <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String sql <span class="token operator">=</span> <span class="token string">"insert into account values(null , ? , ?)"</span><span class="token punctuation">;</span>ps <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>ps<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"admi234n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ps<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">103200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ps<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DBUtils</title>
      <link href="/2019/05/04/Java%20Web%20%20DBUtils/"/>
      <url>/2019/05/04/Java%20Web%20%20DBUtils/</url>
      
        <content type="html"><![CDATA[<h3 id="DBUtils"><a href="#DBUtils" class="headerlink" title="DBUtils"></a>DBUtils</h3><p>Commons DbUtils是Apache提供的一个对JDBC进行简单封装的开源工具类库， 简化了CRUD，里面定义了通用的CRUD方法。同时也不会影响程序的性能。  </p><h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//dbutils 只是帮我们简化了CRUD 的代码， 但是连接的创建以及获取工作，不在他的工作范围，还需要我们自己动手。</span>QueryRunner queryRunner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryRunner</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//增加</span>queryRunner<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">"insert into account values (null , ? , ? )"</span><span class="token punctuation">,</span> <span class="token string">"aa"</span> <span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除</span>queryRunner<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">"delete from account where id = ?"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//更新</span>queryRunner<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">"update account set money = ? where id = ?"</span><span class="token punctuation">,</span> <span class="token number">10000000</span> <span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><strong>1. 直接new接口的匿名实现类</strong><br>查询结果为单个对象。  </p><pre class="line-numbers language-java"><code class="language-java">QueryRunner queryRunner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryRunner</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">Account  account <span class="token operator">=</span>  queryRunner<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"select * from account where id = ?"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ResultSetHandler</span><span class="token operator">&lt;</span>Account<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Account <span class="token function">handle</span><span class="token punctuation">(</span>ResultSet rs<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>        Account account  <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Account</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            String name <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> money <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"money"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            account<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            account<span class="token punctuation">.</span><span class="token function">setMoney</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> account<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>account<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 直接使用框架已经写好的实现类。</strong>    </p><ul><li>查询单个对象    </li></ul><pre class="line-numbers language-java"><code class="language-java">QueryRunner queryRunner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryRunner</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//查询单个对象</span>Account account <span class="token operator">=</span> queryRunner<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"select * from account where id = ?"</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">BeanHandler</span><span class="token operator">&lt;</span>Account<span class="token operator">></span><span class="token punctuation">(</span>Account<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>　　上面的代码段里使用了字节码文件Account.class，目的是与上面的匿名类相比，使用反射技术得到类的字节码相对象的实例，之前是new实现的。new关键字底层应该也是通过反射： 类名.class.newInstance()得到一个实例。</p><ul><li>查询多个对象  </li></ul><pre class="line-numbers language-java"><code class="language-java">QueryRunner queryRunner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryRunner</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>Account<span class="token operator">></span> list <span class="token operator">=</span> queryRunner<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"select * from account "</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">BeanListHandler</span><span class="token operator">&lt;</span>Account<span class="token operator">></span><span class="token punctuation">(</span>Account<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要熟练掌握  </p><pre class="line-numbers language-java"><code class="language-java">queryRunner<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>queryRunner<span class="token punctuation">.</span>query<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="ResultSetHandler-常用的实现类"><a href="#ResultSetHandler-常用的实现类" class="headerlink" title="ResultSetHandler 常用的实现类"></a>ResultSetHandler 常用的实现类</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//常用  是使用频率最高的</span>BeanHandler <span class="token comment" spellcheck="true">// 查询到的单个数据封装成一个对象</span>BeanListHandler <span class="token comment" spellcheck="true">// 查询到的多个数据封装 成一个List&lt;对象></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">ArrayHandler <span class="token comment" spellcheck="true">// 查询到的单个数据封装成一个数组</span>ArrayListHandler <span class="token comment" spellcheck="true">// 查询到的多个数据封装成一个集合 ，集合里面的元素是数组。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">MapHandler <span class="token comment" spellcheck="true">// 查询到的单个数据封装成一个map</span>MapListHandler <span class="token comment" spellcheck="true">// 查询到的多个数据封装成一个集合 ，集合里面的元素是map。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//不常用  </span>ColumnListHandler  KeyedHandler  ScalarHandler  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC基础</title>
      <link href="/2019/05/02/Java%20Web%20%20JDBC/"/>
      <url>/2019/05/02/Java%20Web%20%20JDBC/</url>
      
        <content type="html"><![CDATA[<p><strong>JDBC：</strong> JAVA Database Connectivity java 数据库连接。</p><h3 id="JDBC的基本使用步骤："><a href="#JDBC的基本使用步骤：" class="headerlink" title="JDBC的基本使用步骤："></a>JDBC的基本使用步骤：</h3><ol><li>注册驱动</li></ol><pre class="line-numbers language-java"><code class="language-java">DriverManager<span class="token punctuation">.</span><span class="token function">registerDriver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>Driver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Driver类里面有静态代码块，如果使用上面等于注册了两次，实际没有必要也没有影响。可使用以下：  </p><pre class="line-numbers language-java"><code class="language-java">Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>建立连接</li></ol><pre class="line-numbers language-java"><code class="language-java">   <span class="token comment" spellcheck="true">//DriverManager.getConnection("jdbc:mysql://localhost/test?user=monty&amp;password=greatsqldb");</span>   <span class="token comment" spellcheck="true">//2. 建立连接 参数一： 协议 + 访问的数据库 ， 参数二： 用户名 ， 参数三： 密码。</span>   Connection conn <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost/student"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li>创建statement</li></ol><pre class="line-numbers language-java"><code class="language-java"> <span class="token comment" spellcheck="true">//3. 创建statement，跟数据库打交道，一定需要这个对象</span>  Statement st <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="4"><li>执行sql ，得到ResultSet</li></ol><pre class="line-numbers language-java"><code class="language-java">   <span class="token comment" spellcheck="true">//4. 执行查询 ， 得到结果集</span>    String sql <span class="token operator">=</span> <span class="token string">"select * from t_stu"</span><span class="token punctuation">;</span>    Result rs <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="5"><li>遍历结果集</li></ol><pre class="line-numbers language-java"><code class="language-java">   <span class="token comment" spellcheck="true">//5. 遍历查询每一条记录</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> id <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String name <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> age <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"id="</span><span class="token operator">+</span>id <span class="token operator">+</span> <span class="token string">"===name="</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">"==age="</span><span class="token operator">+</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>释放资源  </li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>          rs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> sqlEx<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// ignore</span>      rs <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用properties配置文件"><a href="#使用properties配置文件" class="headerlink" title="使用properties配置文件"></a>使用properties配置文件</h3><ol><li>在src文件下建立xxx.properties文件，具体如下：</li></ol><pre class="line-numbers language-java"><code class="language-java">driverClass <span class="token operator">=</span> com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>Driverurl <span class="token operator">=</span> jdbc<span class="token operator">:</span>mysql<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span>studentname <span class="token operator">=</span> rootpassword <span class="token operator">=</span> <span class="token number">123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面的url在使用时如果遇到插入为汉字时会遇到乱码，也就是数据库里存的是乱码，需要在url后面再加上 <strong>?useUnicode=true&amp;characterEncoding=utf-8</strong> 。也就是：</p><pre class="line-numbers language-java"><code class="language-java">url <span class="token operator">=</span> jdbc<span class="token operator">:</span>mysql<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span>student<span class="token operator">?</span>useUnicode<span class="token operator">=</span><span class="token boolean">true</span><span class="token operator">&amp;</span>characterEncoding<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>在JDBC工具类里面，使用静态代码块，读取xxx.properties</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span><span class="token punctuation">{</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//1. 创建一个属性配置对象</span>    Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    InputStream is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"jdbc.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//对应文件位于工程根目录</span>    <span class="token comment" spellcheck="true">//使用类加载器，去读取src底下的资源文件。 后面在servlet  //对应文件位于src目录下</span>    <span class="token comment" spellcheck="true">//InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream("jdbc.properties");</span>    <span class="token comment" spellcheck="true">//导入输入流。</span>    properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//读取属性</span>    driverClass <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"driverClass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    url <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    name <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    password <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据库的基本CRUD"><a href="#数据库的基本CRUD" class="headerlink" title="数据库的基本CRUD"></a>数据库的基本CRUD</h3><ol><li>insert  </li></ol><pre class="line-numbers language-java"><code class="language-java">INSERT INTO <span class="token function">t_stu</span> <span class="token punctuation">(</span>NAME <span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token function">VALUES</span> <span class="token punctuation">(</span><span class="token string">'wangqiang'</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token punctuation">)</span>INSERT INTO t_stu <span class="token function">VALUES</span> <span class="token punctuation">(</span>NULL<span class="token punctuation">,</span><span class="token string">'wangqiang2'</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. 获取连接对象</span>    conn <span class="token operator">=</span> JDBCUtil<span class="token punctuation">.</span><span class="token function">getConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. 根据连接对象，得到statement</span>    st <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3. 执行添加</span>    String sql <span class="token operator">=</span> <span class="token string">"insert into t_stu values(null , 'aobama' , 59)"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//影响的行数， ，如果大于0 表明操作成功。 否则失败</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>result <span class="token operator">></span><span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"添加成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"添加失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>delete</li></ol><pre class="line-numbers language-java"><code class="language-java">  DELETE FROM t_stu WHERE id <span class="token operator">=</span> <span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. 获取连接对象</span>    conn <span class="token operator">=</span> JDBCUtil<span class="token punctuation">.</span><span class="token function">getConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. 根据连接对象，得到statement</span>    st <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3. 执行添加</span>    String sql <span class="token operator">=</span> <span class="token string">"delete from t_stu where name='aobama'"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//影响的行数， ，如果大于0 表明操作成功。 否则失败</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>result <span class="token operator">></span><span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>query</li></ol><pre class="line-numbers language-java"><code class="language-java">  SELECT <span class="token operator">*</span> FROM t_stu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 1. 获取连接对象</span>    conn <span class="token operator">=</span> JDBCUtil<span class="token punctuation">.</span><span class="token function">getConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. 根据连接对象，得到statement</span>    st <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3. 执行sql语句，返回ResultSet</span>    String sql <span class="token operator">=</span> <span class="token string">"select * from t_stu"</span><span class="token punctuation">;</span>    rs <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 4. 遍历结果集</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String name <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> age <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">"   "</span> <span class="token operator">+</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>update</li></ol><pre class="line-numbers language-java"><code class="language-java">  UPDATE t_stu SET age <span class="token operator">=</span> <span class="token number">38</span> WHERE id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. 获取连接对象</span>    conn <span class="token operator">=</span> JDBCUtil<span class="token punctuation">.</span><span class="token function">getConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. 根据连接对象，得到statement</span>    st <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3. 执行添加</span>    String sql <span class="token operator">=</span> <span class="token string">"update t_stu set age = 26 where name ='qyq'"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//影响的行数， ，如果大于0 表明操作成功。 否则失败</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>result <span class="token operator">></span><span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"更新成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"更新失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用简单的单元测试"><a href="#使用简单的单元测试" class="headerlink" title="使用简单的单元测试"></a>使用简单的单元测试</h3><p>　　平时测试时都是在public static void main方法里面，可以使用单元测试而直接测试一个方法。在eclipse中可以add library添加Junit4的包，在idea可直接使用。<br>　　首先定义一个类，TestXXX,里面定义方法testXXX（XXX为要测试的方法）。在testXXX上面使用 <strong>@test</strong> 进行测试。   </p><h3 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h3><p>Data Access Object 数据访问对象  </p><ol><li>新建一个dao的接口， 里面声明数据库访问规则(面向接口编程，定义了接口里的规则（要实现的方法）之后，进行具体的实现）。</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//定义操作数据库的方法</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserDao</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//查询所有     </span><span class="token keyword">void</span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>新建一个dao的实现类，具体实现早前定义的规则     </li></ol><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserDao</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Connection conn <span class="token operator">=</span> null<span class="token punctuation">;</span>        Statement st <span class="token operator">=</span> null<span class="token punctuation">;</span>        ResultSet rs <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//1. 获取连接对象</span>            conn <span class="token operator">=</span> JDBCUtil<span class="token punctuation">.</span><span class="token function">getConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//2. 创建statement对象</span>            st <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String sql <span class="token operator">=</span> <span class="token string">"select * from t_user"</span><span class="token punctuation">;</span>            rs <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                String userName <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                String password <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userName<span class="token operator">+</span><span class="token string">"="</span><span class="token operator">+</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            JDBCUtil<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> st<span class="token punctuation">,</span> rs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>可以使用单元测试进行测试   </li></ol><pre class="line-numbers language-java"><code class="language-java">  <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFindAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        UserDao dao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dao<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>##Statement安全问题<br>Statement执行 ，其实是拼接sql语句的。  先拼接sql语句，然后在一起执行。   </p><pre class="line-numbers language-java"><code class="language-java">    String sql <span class="token operator">=</span> <span class="token string">"select * from t_user where username='"</span><span class="token operator">+</span> username  <span class="token operator">+</span><span class="token string">"' and password='"</span><span class="token operator">+</span> password <span class="token operator">+</span><span class="token string">"'"</span><span class="token punctuation">;</span>    UserDao dao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dao<span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">,</span> <span class="token string">"100234khsdf88' or '1=1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    SELECT <span class="token operator">*</span> FROM t_user WHERE username<span class="token operator">=</span><span class="token string">'admin'</span> AND PASSWORD<span class="token operator">=</span><span class="token string">'100234khsdf88'</span> or <span class="token string">'1=1'</span>    前面先拼接sql语句， 如果变量里面带有了 数据库的关键字，那么一并认为是关键字。 不认为是普通的字符串。    rs <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="PrepareStatement"><a href="#PrepareStatement" class="headerlink" title="PrepareStatement"></a>PrepareStatement</h3><p>PrepareStatement对象就是替换前面的statement对象。<br>优点：</p><ul><li>安全性  </li><li>使用简单，不用拼接字符串  </li></ul><p> 相比较以前的statement， 预先处理给定的sql语句，对其执行语法检查。 在sql语句里面使用 <strong>?</strong> 占位符来替代后续要传递进来的变量。 后面进来的变量值，将会被看成是字符串，不会产生任何的关键字。</p><pre class="line-numbers language-java"><code class="language-java">    String sql <span class="token operator">=</span> <span class="token string">"insert into t_user values(null , ? , ?)"</span><span class="token punctuation">;</span>     ps <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//给占位符赋值 从左到右数过来，1 代表第一个问号， 永远你是1开始。</span>     ps<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> userName<span class="token punctuation">)</span><span class="token punctuation">;</span>     ps<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java源码-剖析ArrayList</title>
      <link href="/2019/03/28/Java%20ArrayList/"/>
      <url>/2019/03/28/Java%20ArrayList/</url>
      
        <content type="html"><![CDATA[<p>容器类(集合)，顾名思义就是用来容纳其它数据的类。在泛型的那篇笔记中，实现了一个简单的动态数组的容器类–DynamicArray,本篇主要阐述Java中真正的动态数组（数组列表）容器类ArrayList（Java 7）的基本用法、迭代操作、实现的一些Interface（Collection、List与RandAccess）、特点与应用场景。  </p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ArrayList是一个泛型类，使用时需要实例化泛型参数，比如  </p><pre class="line-numbers language-java"><code class="language-java">ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> intList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//new ArrayList&lt;Integer>()中尖括号的类型Java7后可以省略  </span>ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span>  strList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ArrayList常用的方法有：  </p><pre class="line-numbers language-Java"><code class="language-Java">public boolean add(E e)  //将新元素添加到末尾public boolean isEmpty() //判断数组列表是否为空public int size()  //获取当前的长度public E get(int index)  // 访问（获取）指定位置元素public int indexOf(Object o)  //查找给定元素，找到返回索引值，否之返回-1public int lastIndexOf(Object o)  //从后往前查找public boolean contain(Object o)  //是否包含指定元素，依据时equals方法的返回值public E remove(int index)  //删除指定位置元素，返回被删的元素  public boolean remove(Object o)  //删除指定元素，只删除一个相同的元素，返回值表示是否删除了元素//如果o为null，则删除值为null的元素public void clean()  //删除所有元素public vod add(int index, E element)  //在指定位置插入元素，index=0表示插在最前面(如果在中间插入，原有的将会整体往后顺移)publi  E set (int index, E element)   //修改指定位置的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>ArrayList原理与我们之前写的DynamicArray类似，其内部有一个数组elementData，整数size记录实际的元素个数。如下所示：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">transient</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>类中各种public方法的内部操作其实都是对这个数组与整型的操作，elementData会根据实际元素的个数的增加而动态的<strong>重新</strong>分配，整数size记录实际的元素个数。<br>以下是add方法实现的主要代码：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>  elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先调用ensureCapacityInternal方法的目的是确保这次添加元素时候，数组的容量是足够的。ensureCapacityInternal的代码如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>    minCapacity <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ensureCapacityInternal方法首先判断数组elementData是否为空，DEFAULT_CAPACITY的值为10，然后调用ensureExplicitCapacity方法，主要代码如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>  modCount<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// overflow-conscious code</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>modCount表示内部的修改次数，如果需要的长度大于当前数组elementData的长度，则调用grow()，主要代码如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// overflow-conscious code</span>  <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>     newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>      newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>  elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>grow（）的作用就是先确定扩容的长度，然后使用copyOf方法。里面需要注意的时移位运算，newCapacity相当于1.5倍的oldCapacity。<br>以下为remove方法的代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>  modCount<span class="token operator">++</span><span class="token punctuation">;</span>  E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//计算要移动的元素个数</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>      System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>  elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work 将size减1，同时释放引用以便原对象被垃圾回收</span>  <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>remove方法里也有一个modCount变量，然后numMoved计算要移动的元素个数，从index往后的元素都往前移动一位，调用了 System.arraycopy 方法来移动元素。 elementData[–size] = null; 这行代码将size减1（索引0开始），同时将最后一个位置设为null，因为设为null之后也就不再继续引用原来的对象，其就可以被垃圾回收。<br>其它的方法大多也比较简单。 　　</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>迭代是ArrayList常见的操作，以下是一个迭代操作的例子，循环打印ArrayList的每个元素（ArrayList因为底层操作是数组所以支持foreach语法,增强for循环适用与各种容器，相比普通for循环，更为通用）：</p><pre class="line-numbers language-java"><code class="language-java">ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> intList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>intList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>intList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>intList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>Integer a<span class="token operator">:</span>intList<span class="token punctuation">)</span><span class="token punctuation">{</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的foreach语法背后是怎么实现的呢？其实编译器会将它转换为类似下面的代码：</p><pre class="line-numbers language-java"><code class="language-java">Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> it <span class="token operator">=</span> intList<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="迭代器接口"><a href="#迭代器接口" class="headerlink" title="迭代器接口"></a>迭代器接口</h4><p>ArrayList实现了Iterable接口，在Java7中，Iterable如下定义：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterable</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>  Iterator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，iterator返回一个实现了Iterator接口的对象，在Java7中，Iterator接口的定义如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">boolean</span> <span class="token function">hashNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  E next<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，hasNext（）判断是否还有元素未访问，next（）返回下一个元素，remove（）删除最后返回的元素，只读访问的基本模式类似于：  </p><pre class="line-numbers language-java"><code class="language-java">Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> it <span class="token operator">=</span> intList<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong> foreach也就是增强for循环可以与任何实现了接口Iterable（只包含抽象方法itrrator（） ）的对象一起工作。<br><strong>接口Iterable的注意：</strong>   </p><ul><li>Iterable表示对象可以被迭代，并返回Iterator对象。ArrayList中，因为接口Collection继承了接口Iterable，在ArrayList中实现了接口Collection。所以ArrayList可以使用迭代器的方法进行遍历。同时标准类库中的任何容器类也因此都可以使用foreach。  </li><li>对象如果要使用增强for循环，就必须要实现接口Iterable。</li></ul><blockquote><p>ArrayList通过内部类实现接口Iterator。  </p></blockquote><h4 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h4><p>接口ListIterator扩展了接口Iterator，使其增加了向前遍历，添加、修改元素，返回索引元素等方法。  </p><h4 id="迭代器使用的常见错误"><a href="#迭代器使用的常见错误" class="headerlink" title="迭代器使用的常见错误"></a>迭代器使用的常见错误</h4><p>在使用迭代器时候，有一种常见的错误，就是在迭代的中间调用容器（集合）的删除方法。比如要删除整型ArrayList中所有的负数，直觉上可以这样写：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>Integer a <span class="token operator">:</span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是运行时会抛出如下异常：</p><blockquote><p>java.util.ConcurrentModificationException    </p></blockquote><p>为何会发生并发修改异常呢？</p><blockquote><p>因为迭代器内部会维护一些与索引位置相关的数据，要求在迭代过程中，容器（集合）不能发生结构性改变，否则这些索引位置就失效了。结构性变化就是指： 插入、删除元素，而只修改元素的内容不算结构性变化。    </p></blockquote><p><strong> 如何避免并发修改异常？ </strong> 可以使用迭代器的remove方法，具体如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>ArrayList<span class="token operator">&lt;</span>Ingeter<span class="token operator">></span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>  Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> it <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span>next <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="迭代器实现原理"><a href="#迭代器实现原理" class="headerlink" title="迭代器实现原理"></a>迭代器实现原理</h4><p>迭代器是如何知道发生了结构性改变，然后抛出了异常呢？为何自己的remove方法又能使用呢？<br>以下为ArrayList中Iterator方法的实现：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Itr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong> Itr  </strong>  是一个成员内部类，实现了接口Iterator，声明如下：  </p><blockquote><p>private class Itr <strong>implements</strong> Iterator   </p></blockquote><p>它有三个实例成员变量：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> cursor<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//下一个要返回的元素位置</span><span class="token keyword">int</span> lastTRet <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 最后一个返回的索引位置，如果没有为 -1</span><span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>expectedModCount*</strong> 变量表示期望的修改次数，初始化为外部类当前的修改次数 <strong>modCount</strong> （成员内部类可以直接访问外部类的实例成员变量）。每次发生<strong>结构性变化</strong>的时候modCount都会增加，而每次迭代器操作的时候都会检查expectedModCount是否与modCount，这样就能检测出是否发生了结构性变化。  </p><p>以下将会阐述内部类 <strong>Itr</strong> 如何实现接口Iterator接口中的每个方法的。hasNext()方法的代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> cursor <span class="token operator">!=</span> size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//cursor与size比较，很简单</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>next()方法代码如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> cursor<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> size<span class="token punctuation">)</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData <span class="token operator">=</span> ArrayList<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>elementData<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  cursor <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> elementData<span class="token punctuation">[</span>lastRet <span class="token operator">=</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先调用了checkForComodification，它的代码为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>     <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所以，next()前面部分主要目的就是在检查是否发生了结构性变化，如果没有变化，就更新cursor和lastRet的值，以保持其语义，然后返回对应的元素。<br>remove（）方法的代码如下：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>lastRet <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>     <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        ArrayList<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>lastRet<span class="token punctuation">)</span><span class="token punctuation">;</span>        cursor <span class="token operator">=</span> lastRet<span class="token punctuation">;</span>        lastRet <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IndexOutOfBoundsException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它调用了ArrayList的remove方法，但同时更新了cursor, lastRet和expectedModCount的值，所以它可以正确删除。不过，需要注意的是，调用remove方法前必须先调用next，比如，通过迭代器删除所有元素，直觉上，可以这么写：  </p><pre class="line-numbers language-Java"><code class="language-Java">public static void removeAll(ArrayList<Integer> list){  Iterator<Integer> it = list.iterator();  while(it.hasNext()){        it.remove();      }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际运行，会抛出异常：</p><blockquote><p>java.lang.IllegalStateException</p></blockquote><p>正确写法是：  </p><pre class="line-numbers language-Java"><code class="language-Java">public static void removeAll(ArrayList<Integer> list){  Iterator<Integer> it = list.iterator();  while(it.hasNext()){        it.next();        it.remove();  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，如果只是要删除所有元素，ArrayList有现成的方法clear()。<br>listIterator()的实现使用了另一个内部类ListItr，它继承自Itr，基本思路类似。  </p><h4 id="迭代器的优点"><a href="#迭代器的优点" class="headerlink" title="迭代器的优点"></a>迭代器的优点</h4><p>使用普通的for（int i = 0；i &lt; arrs.size()； i++）再加上ArrayList的get（）方法虽然在一些场景中与使用迭代器（增强for循环）效果并没有什么区别，但是使用迭代器（增强for）可以增强可读性，更重要的是更为通用，可以适用于所有的容器（集合）类。<br>此外，迭代器表示了一种关注点相分离的思想，将数据的实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。需要访问容器元素的代码只需要一个Iterator接口，不需要关注数据的实际组织方式，可以使用一致与统一的方式进行访问。<br>而提供的Iterator接口的代码了解数据的组织方式，可以提供更高效的实现。在ArrayList中，size/get(index)语法与迭代器的性能是差不多的，但是在其他的容器类中则不一定，比如LinkedList，迭代器的性能则高许多。  </p><blockquote><p>从封装的思路来讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单和一致的接口。  </p></blockquote><h3 id="ArrayList实现的接口"><a href="#ArrayList实现的接口" class="headerlink" title="ArrayList实现的接口"></a>ArrayList实现的接口</h3><p>ArrayList实现了三个主要的接口： Collection、List、RandomAccess。<br>接口Collection继承了接口Iterable，表示一个数据集合，数据没有位置或者顺序的概念。<br>接口List表示有顺序或者位置的数据集合，它扩展了Collection。<br>接口RandomAccess没有定义任何的代码。这种没有代码的接口在Java中被称为<strong>标记接口</strong> ，用于声明类的一种属性。</p><h3 id="ArrayList的特点"><a href="#ArrayList的特点" class="headerlink" title="ArrayList的特点"></a>ArrayList的特点</h3><ol><li>可以随机访问（数组是一块连续的内存空间，可以根据索引随机访问），使用索引进行随机访问效率很高，时间复杂度为O(1)。  </li><li>普通未排序的ArrayList按内容查找的效率很低，时间复杂度为O(n)。  </li><li>末尾 <strong>添加</strong> 元素的效率还可以，重新分配与复制数组的开销可以被平摊了。 <strong>插入</strong> 与 <strong>删除</strong> 元素效率很低，因为还要移动元素，时间复杂度为O（n）。    </li><li>ArrayList <strong>不是线程安全</strong> 的，实现线程安全的一种方式是使用接口Collection提供的方法装饰ArrayList类。此外，还有一个类 <strong>Vector</strong> ，它是Java早期实现的容器（集合）类之一。也实现了接口List，但基本原理与ArrayList类似，内部使用了 <strong>synchronized</strong> 实现了线程安全。在不需要线程安全的情况下，可优先考虑使用ArrayList。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> java源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我对Hadoop的理解：存储、资源调度、计算</title>
      <link href="/2019/03/01/Architeture%20Hadoop/"/>
      <url>/2019/03/01/Architeture%20Hadoop/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;在看了Google关于大数据的几篇开山论文之后，我又看了看Hadoop的架构设计，虽然Hadoop关键组件的设计原本就是Google的GFS、Bigtable、MapReduce但还是在工程实现上有着自己的特点。本篇博客我会写一写我对Hadoop在存储、资源调度、计算方面的理解，以后也可能会具体的针对重要的组件在进行详细记录 :) ,当然如果你发现我的理解有问题或者有其它问题,我们都可以邮件交流鸭 <a href="mailto:mee.gaoyang@OutLook.com" target="_blank" rel="noopener">mee.gaoyang@OutLook.com</a> :)  </p><h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><p>&emsp;&emsp;<em>A distributed system is a collection of independent computter that appears to user as a single coherent system. –分布式原理与泛型</em><br>&emsp;&emsp;简而言之，分布式系统就是让众多的计算设备针对于使用者来说就像是一台设备来使用。<br>&emsp;&emsp;其实对于使用者来说确实是很简单，但分布式系统背后仍是一个个复杂的理论与设计实现，主要包括CAP理论、分布式存储、分布式事务与分布式锁，并且分布式还涉及到许多技术、协议等等。<br>&emsp;&emsp;分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的存储、计算任务。其目的是利用更多的机器，处理更多的数据。<br>&emsp;&emsp;只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。。。<br>&emsp;&emsp;分布式系统中有大量的节点，且通过网络通信。单个节点的故障（进程crash、断电、磁盘损坏）是个小概率事件，但整个系统的故障率会随节点的增加而指数级增加，网络通信也可能出现断网、高延迟的情况。在这种一定会出现的“异常”情况下，分布式系统还是需要继续稳定的对外提供服务，即需要较强的容错性。最简单的办法，就是冗余或者复制集（Replication），即多个节点负责同一个任务，最为常见的就是分布式存储中，多个节点复杂存储同一份数据，以此增强可用性与可靠性。同时，Replication也会带来性能的提升，比如数据的locality可以减少用户的等待时间。<br>以下是整理的一些组件：  </p><ul><li>负载均衡：<br>　　　　Nginx：高性能、高并发的web服务器；功能包括负载均衡、反向代理、静态内容缓存、访问控制；工作在应用层<br>　　　　LVS： Linux virtual server，基于集群技术和Linux操作系统实现一个高性能、高可用的服务器；工作在网络层  </li><li>webserver：<br>　　　　Java：Tomcat，Apache，Jboss<br>　　　　Python：gunicorn、uwsgi、twisted、webpy、tornado  </li><li>service：　 　<br>　　　　SOA、微服务、spring boot，django</li><li>容器：<br>　　　　docker，kubernetes  </li><li>cache：<br>　　　　memcache、redis等            </li><li>协调中心：<br>　　　　zookeeper、etcd等<br>　　　　zookeeper使用了Paxos协议Paxos是强一致性，高可用的去中心化分布式。zookeeper的使用场景非常广泛。  </li><li>rpc框架：<br>　　　　grpc、dubbo、brpc<br>　　　　dubbo是阿里开源的Java语言开发的高性能RPC框架，在阿里系的诸多架构中，都使用了dubbo + spring boot  </li><li>消息队列：<br>　　　　kafka、rabbitMQ、rocketMQ、QSP<br>　　　　消息队列的应用场景：异步处理、应用解耦、流量削锋和消息通讯  </li><li>实时数据平台：<br>　　　　storm、akka  </li><li>离线数据平台：<br>　　　　hadoop、spark<br>　　　　PS: spark、akka、kafka都是scala语言写的</li><li>dbproxy：<br>　　　　cobar也是阿里开源的，在阿里系中使用也非常广泛，是关系型数据库的sharding + replica 代理   </li><li>db：<br>　　　　mysql、oracle、MongoDB、HBase  </li><li>搜索：<br>　　　　elasticsearch、solr  </li><li>日志：<br>　　　　rsyslog、elk、flume    </li></ul><p>当然上面的许多组件我也是第一次看到:)，先罗列到这里啦，方便以后或深或浅的学习。   </p><h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><p><img src="/images/Hadoop 01.png" alt=""><br>&emsp;&emsp;如上图所示，HDFS负责将数据存储到硬盘上。<br><img src="/images/Hadoop HDFS Architecture.png" alt=""><br>&emsp;&emsp;HDFS中的NameNode对应GFS中的Master节点，block对应Chunk，DataNodes节点对应ChunkService。同样namenode节点存储元数据，每次客户端需要读写数据时候，先从namenode获取要操作block的位置信息，然后客户端再从datanodes中去获取block以进行自己的操作。<br>&emsp;&emsp;需要注意的是，客户端在向namenode查询block信息时，那么namenode返回的是block相关联的元数据信息，并将信息存储在客户端的cache中，方便以后的使用。<br>&emsp;&emsp;上面提到存DataNodes随时可能宕掉的，因此Hadoop使用Heartbeat来检测。具体来说就是DataNode默认每3s向namenode发送心跳报告。但是还存在这DataNode假死的情况，也就是可能因为网络或其它原因在某次heartbeat检测中被判定挂掉了，为了解决这个问题，DataNode默认每1h向namenode发送自己的block信息，例如block的名字、大小等等。<br><img src="/images/Hadoop HDFS write.png" alt=""><br>&emsp;&emsp;Hadoop的HDFS在写入数据的时候和GFS其实还是存在着很大的不同的，如上图数据存放于三处备份中，OutputStream是一套标准的java输出流，在写入的时候，往一个DataNodeA写，然后DataNodeA往DataNodeB写，同理DataNodeB往DataNodeC中写，<strong>需要注意的是，在HDFS中并没有lease租约这个概念，更有控制流与数据流相隔离这个理念</strong> ，每个DataNode都将得到的数据直接存在自己的硬盘上（GFS是先存在cache中），如果所有的副本都存储成功，会返回namenode节点一个 <em>complete</em> 反馈，然后namenode会将block的信息记录在自己的内存中。<br>&emsp;&emsp;但是这样直接存储在disk中仍会产生一个问题：三个DataNode中有一个未能存储成功，这个时候namenode就不会受到完成的反馈，也就是namenode不会将成功存储的文件记录到自己的内存中，虽然有两个DataNode节点已经成功存储了，但是从整个系统来看仍然判定本次存储失败。成功的那两个DataNode节点实际上是没有用的，如果系统不加以识别出来那么也会浪费许多硬盘空间。这个时候就会用到上面提到的在HDFS中DataNode默认1h发送自己的信息给namenode，DataNode可以据此来判断出来自己存储的无用信息。  </p><h4 id="HDFS与GFS的差异"><a href="#HDFS与GFS的差异" class="headerlink" title="HDFS与GFS的差异"></a>HDFS与GFS的差异</h4><p>&emsp;&emsp;以我目前的理解程度来说，我认为两个最大的差异在于 写 方面，GFS利用lease机制，实现了多个客户端可以并行的方式同一个chunk（block）文件进行写操作，而HDFS每次只能允许一个client对chunk进行写操作，并且HDFS是直接将数据写在disk之上，而GFS是写入到cache中，待所有chunkservice的写cache都完成后根据主chunk给出的顺序编号（多个client）再写入到disk中。  </p><h3 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h3><p><img src="/images/Hadoop YArn.png" alt=""><br>&emsp;&emsp;Yet Another Resource Negotiator，另一种资源协调者，是的yarn的之前资源调度者就是MapReduce 1.0。 MapReduce1.0的架构大家可能都已经很清楚了，如下图所示，它最大的弊端就是管理任务过于集中。<br><img src="/images/Hadoop MapReduce 1.0.png" alt=""><br>&emsp;&emsp;架构中压力最大的节点就是JobTracker，无论是调度分配，还是监控，还是重启任务，都全部依赖这个主控节点，特别用户如果提交了不同类型的分析任务的，比如A用户提交的是一个快速查询的任务，B用户提交的是一个多次迭代长事务的任务，在这种不同类型的任务之间确定是否有计算节点资源空闲，就是一个很麻烦的事情。所以在MapReduce 1.0时代，除了容易引发单节点故障，还会因为主控节点因为压力过大导致性能下降，因为JobTracker同时兼备了资源管理和作业控制两个功能，这成为系统的一个最大瓶颈，严重制约了Hadoop集群扩展性。——官方的说法是，当他需要管理的节点数超过4000的时候，1.0就会导致“表现出一定的不可预测性”。<br>&emsp;&emsp;还有就是这种架构是专为mapreduce来设计的，如果需要再hadoop上面运行其他的框架，比如内存计算框架、流式计算框架和迭代式计算框架等，基本上就歇菜了。。。<br>&emsp;&emsp;针对这种问题，apache升级了hadoop的新一代计算框架，MapReduce V2，并且专门抽象出来作为一个独立的系统，就是YARN。<br><img src="/images/Hadoop YArn01.png" alt=""><br>对于具体的YARN是如何进行资源调度与任务管理的以及MapReduce之后新一代的基于内存计算模型Sparkde的相关内容在后面的博客中再记录吧 :)  </p>]]></content>
      
      
      <categories>
          
          <category> 分布式架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式架构 </tag>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Google File System总结</title>
      <link href="/2019/02/15/Architeture%20GFS/"/>
      <url>/2019/02/15/Architeture%20GFS/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;这篇博客是我阅读<a href="http://nil.csail.mit.edu/6.824/2017/papers/gfs.pdf" target="_blank" rel="noopener">Google File System</a>的论文以及<a href="https://mr-dai.github.io/gfs/" target="_blank" rel="noopener">相关资料</a>并总结而来。当然也是我自己的理解，如有问题请邮件联系<a href="mailto:mee.gaoyang@foxmail.com" target="_blank" rel="noopener">mee.gaoyang@foxmail.com</a> :)</p><h3 id="GFS的主要设计需求"><a href="#GFS的主要设计需求" class="headerlink" title="GFS的主要设计需求"></a>GFS的主要设计需求</h3><p>GFS是应用到Google内部的文件系统，针对于其自身的业务场景需求，设计主要基于以下几个需求：</p><ol><li>节点失效是常态。系统会构建在大量的普通廉价机器上，这使得节点失效的可能性很高。因此，GFS 必须能有较高的容错性、能够持续地监控自身的状态，比如应用程序 bug、操作系统的 bug、人为失误，甚至还有硬盘、内存、连接器、网络以及电源失效等造成的问题。所以，持续的监控、错误侦测、灾难冗余以及自动恢复的机制必须集成在 GFS 中。</li><li>存储内容以大文件为主。系统需要存储的内容在通常情况下由数量不多的大文件构成，每个文件通常有几百 MB 甚至是几 GB 的大小；系统应当支持小文件，但不需要为其做出优化。</li><li>主要负载为大容量连续读、小容量随机读以及追加式的连续写。绝大部分文件的修改是采用在文件尾部追加数据，而不是覆盖原有数据的方式。</li><li>系统应当支持高效且原子的文件追加操作，源于在 Google 的情境中，这些文件多用于生产者-消费者模式或是多路归并。</li><li>当需要做出取舍时，系统应选择高数据吞吐量而不是低延时。  </li></ol><h3 id="GFS-集群组成"><a href="#GFS-集群组成" class="headerlink" title="GFS 集群组成"></a>GFS 集群组成</h3><p>&emsp;&emsp;简单来讲，除了客户端以外，一个 GFS 集群还包括一个 Master 节点和若干个 Chunk Server。它们会作为用户级进程运行在普通的 Linux 机器上。<br>&emsp;&emsp;在存储文件时，GFS 会把文件切分成若干个拥有固定长度的 Chunk（块）并存储。Master 在创建 Chunk 时会为它们赋予一个唯一的 64 位 Handle（句柄），并把它们移交给 Chunk Server，而 Chunk Server 则以Linux系统普通文件的形式将每个 Chunk 存储在自己的本地磁盘上。为了确保 Chunk的可用性，GFS 会把每个 Chunk 备份成若干个 Replica（一般为三个备份）分配到其他 Chunk Server 上。<br>&emsp;&emsp;GFS 的 <strong>Master</strong> 负责维护整个集群的元数据，包括集群的 Namespace（命名空间，即文件元数据）以及 Chunk Lease 管理、无用 Chunk 回收等系统级操作。Chunk Server 除了保存 Chunk 以外也会周期地和 Master 通过心跳信号进行通信，Master 也借此得以收集每个 Chunk Server 当前的状态，并向其发送指令。<br>&emsp;&emsp;鉴于整个集群只有一个 Master，客户端在和 GFS 集群通信时，首先会从 Master 处获取 GFS 的元数据，而实际文件的数据传输则会与 Chunk Server 直接进行，以避免 Master 成为整个系统的数据传输瓶颈；除此以外，客户端也会在一定时间内缓存 Master 返回的集群元数据。</p><h3 id="GFS的元数据"><a href="#GFS的元数据" class="headerlink" title="GFS的元数据"></a>GFS的元数据</h3><p>&emsp;&emsp;GFS 集群的所有元数据都会保存在 Master 的内存中。鉴于整个集群只会有一个 Master，这也使得元数据的管理变得更为简单。GFS 集群的元数据主要包括以下三类信息：</p><ol><li>文件与 Chunk 的 Namespace</li><li>文件与 Chunk 之间的映射关系</li><li>每个 Chunk Replica 所在的位置</li></ol><p>&emsp;&emsp;元数据保存在 Master 的内存中使得 Master 要对元数据做出变更变得极为容易；同时，这也使得 Master 能够更加高效地扫描集群的元数据，以唤起 Chunk 回收、Chunk 均衡等系统级管理操作。唯一的不足在于这使得整个集群所能拥有的 Chunk 数量受限于 Master 的内存大小，不过从论文的内容来看，这样的瓶颈在 Google 中从来没有被触及过，源于对于一个 64MB 大小的 Chunk，Master 只需要维持不到 64 字节的元数据。况且，相比于增加代码的复杂度，提高 Master 内存容量的成本要小得多。<br>&emsp;&emsp;为了保证元数据的可用性，Master 在对元数据做任何操作前对会用先写日志的形式将操作进行记录，日志写入完成后再进行实际操作，而这些日志也会被备份到多个机器上进行保存。不过，Chunk Replica 的位置不会被持久化到日志中，而是由 Master 在启动时询问各个 Chunk Server 其当前所有的 Replica。这可以省去 Master 与 Chunk Server 同步数据的成本，同时进一步简化 Master 日志持久化的工作。这样的设计也是合情合理的，毕竟 Chunk Server 当前实际持有哪些 Replica 也应由 Chunk Server 自己说了算。  </p><h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><p>&emsp;&emsp;用户在使用 GFS 这类数据存储系统时，首先应当了解其所能提供的数据一致性，而作为学习者我们也应先理解 GFS 对外呈现的数据一致性功能。<br>&emsp;&emsp;首先，命名空间完全由单节点 Master 管理在其内存中，这部分数据的修改可以通过让 Master 为其添加互斥锁来解决并发修改的问题，&emsp;&emsp;因此命名空间的数据修改是可以确保完全原子的。<br>文件的数据修改则相对复杂。在讲述接下来的内容前，首先我们先明确，在文件的某一部分被修改后，它可能进入以下三种状态的其中之一：  </p><ol><li>客户端读取不同的 Replica 时可能会读取到不同的内容，那这部分文件是不一致的（Inconsistent）</li><li>所有客户端无论读取哪个 Replica 都会读取到相同的内容，那这部分文件就是一致的（Consistent）</li><li>所有客户端都能看到上一次修改的所有完整内容，且这部分文件是一致的，那么我们说这部分文件是确定的（Defined）  </li></ol><p>&emsp;&emsp;在修改后，一个文件的当前状态将取决于此次修改的类型以及修改是否成功。具体来说：   </p><ul><li>如果一次写入操作成功且没有与其他并发的写入操作发生重叠，那这部分的文件是确定的（同时也是一致的）</li><li>如果有若干个写入操作并发地执行成功，那么这部分文件会是一致的但会是不确定的：在这种情况下，客户端所能看到的数据通常不能直接体现出其中的任何一次修改</li><li>失败的写入操作会让文件进入不一致的状态</li></ul><p>这之间的关系也被整理为了论文中的表格 1：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/GFS_consistency-model.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>   </p><p>&emsp;&emsp;GFS 支持的文件数据修改数据包括两种：指定偏移值的数据写入（Write）以及数据追加（Record Append）。当写入时，指定的数据会被直接写入到客户端指定的偏移位置中，覆盖原有的数据。GFS 并未为该操作提供太多的一致性保证：如果不同的客户端并发地写入同一块文件区域，操作完成后这块区域的数据可能由各次写入的数据碎片所组成，即进入不确定的状态。<br>&emsp;&emsp;与写入操作不同，GFS 确保即便是在并发时，数据追加操作也是原子且 at least once（至少一次）的。操作完成后，GFS 会把实际写入的偏移值返回给客户端，该偏移值即代表包含所写入数据的确定的文件区域的起始位置。由于数据追加操作是 at least once 的，GFS 有可能会在文件中写入填充（padding）或是重复数据，但出现的概率不高。<br>&emsp;&emsp;在读取数据时，为了避免读入填充数据或是损坏的数据，数据在写入前往往会放入一些如校验和等元信息以用于验证其可用性，如此一来 GFS 的客户端 library 便可以在读取时自动跳过填充和损坏的数据。不过，鉴于数据追加操作的 at lease once 特性，客户端仍有可能读入重复的数据，此时只能由上层应用通过鉴别记录的唯一 ID 等信息来过滤重复数据了。  </p><h3 id="对应用的影响"><a href="#对应用的影响" class="headerlink" title="对应用的影响"></a>对应用的影响</h3><p>&emsp;&emsp;GFS 的一致性模型是相对松散的，这就要求上层应用在使用 GFS 时能够适应 GFS 所提供的一致性语义。简单来讲，上层应用可以通过两种方式来做到这一点：更多使用追加操作而不是覆写操作；写入包含校验信息的数据。<br>&emsp;&emsp;青睐追加操作而不是覆写操作的原因是明显的：GFS 针对追加操作做出了显著的优化，这使得这种数据写入方式的性能更高，而且也能提供更强的一致性语义。尽管如此，追加操作 at least once 的特性仍使得客户端可能读取到填充或是重复数据，这要求客户端能够容忍这部分无效数据。一种可行的做法是在写入的同时为所有记录写入各自的校验和，并在读取时进行校验，以剔除无效的数据；如果客户端无法容忍重复数据，客户端也可以在写入时为每条记录写入唯一的标识符，以便在读取时通过标识符去除重复的数据。</p><h3 id="GFS-集群常见操作流程"><a href="#GFS-集群常见操作流程" class="headerlink" title="GFS 集群常见操作流程"></a>GFS 集群常见操作流程</h3><h4 id="Master-Namespace-管理"><a href="#Master-Namespace-管理" class="headerlink" title="Master Namespace 管理"></a>Master Namespace 管理</h4><p>&emsp;&emsp;在前面我们已经了解到，Namespace 作为 GFS 元信息的一部分会被维持在 Master 的内存中，由 Master 负责管理。在逻辑上，GFS Master 并不会根据文件与目录的关系以分层的结构来管理这部分数据，而是单纯地将其表示为从完整路径名到对应文件元数据的映射表，并在路径名上应用前缀压缩以减少内存占用。<br>&emsp;&emsp;为了管理来自不同客户端的并发请求对 Namespace 的修改，Master 会为 Namespace 中的每个文件和目录都分配一个读写锁（Read-Write Lock）。由此，对不同 Namespace 区域的并发请求便可以同时进行。<br>&emsp;&emsp;所有 Master 操作在执行前都会需要先获取一系列的锁：通常，当操作涉及某个路径 /d1/d2/…/dn/leaf 时，Master 会需要先获取从 /d1、/d1/d2 到 /d1/d2/…/dn 的读锁，然后再根据操作的类型获取 /d1/d2/…/dn/lead 的读锁或写锁 —— 获取父目录的读锁是为了避免父目录在此次操作执行的过程中被重命名或删除。<br>&emsp;&emsp;由于大量的读写锁可能会造成较高的内存占用，这些锁会在实际需要时才进行创建，并在不再需要时被销毁。除外，所有的锁获取操作也会按照一个相同的顺序进行，以避免发生死锁：锁首先按 Namespace 树的层级排列，同一层级内则以路径名字典序排列。   </p><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><p>&emsp;&emsp;客户端从 GFS 集群中读取文件内容的过程大致如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/gfs-architecture.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>   </p><ol><li>对于指定的文件名和读取位置偏移值，客户端可以根据固定的 Chunk 大小来计算出该位置在该文件的哪一个 Chunk 中</li><li>客户端向 Master 发出请求，其中包含要读取的文件名以及 Chunk 索引值</li><li>Master 向客户端响应该 Chunk 的 Handle 以及其所有 Replica 当前所在的位置。客户端会以文件名和 Chunk 索引值为键缓存该数据</li><li>之后，客户端便可以选取其中一个 Replica 所在的 Chunk Server 并向其发起请求，请求中会指定需要读取的 Chunk 的 Handle 以及要读取的范围<br>Chunk Lease<br>在客户端对某个 Chunk 做出修改时，GFS 为了能够处理不同的并发修改，会把该 Chunk 的 Lease 交给某个 Replica，使其成为 Primary：Primary 会负责为这些修改安排一个执行顺序，然后其他 Replica 便按照相同的顺序执行这些修改。  </li></ol><h5 id="Chunk-Lease"><a href="#Chunk-Lease" class="headerlink" title="Chunk Lease"></a>Chunk Lease</h5><p>&emsp;&emsp;在初始时会有 60 秒的超时时间。在未超时前，Primary 可以向 Master 申请延长 Chunk Lease 的时间；必要时 Master 也可以直接撤回已分配的 Chunk Lease。  </p><h4 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h4><p>&emsp;&emsp;客户端尝试将数据写入到某个 Chunk 的指定位置的过程大致如下：<br><img src="/images/gfs-write.png" alt="">  </p><ol><li>客户端向 Master 询问目前哪个 Chunk Server 持有该 Chunk 的 Lease</li><li>Master 向客户端返回 Primary 和其他 Replica 的位置</li><li>客户端将数据推送到所有的 Replica 上。Chunk Server 会把这些数据保存在缓冲区中，等待使用</li><li>待所有 Replica 都接收到数据后，客户端发送写请求给 Primary。Primary 为来自各个客户端的修改操作安排连续的执行序列号，并按顺序地应用于其本地存储的数据</li><li>Primary 将写请求转发给其他 Secondary Replica，Replica 们按照相同的顺序应用这些修改</li><li>Secondary Replica 响应 Primary，示意自己已经完成操作</li><li>Primary 响应客户端，并返回该过程中发生的错误（若有）<br>&emsp;&emsp;如果该过程有发生错误，可以认为修改已在 Primary 和部分 Secondary 上成功执行（如果在 Primary 上就出错了，那么写请求不会被转发出去）。此时可以认为此次修改操作没有成功，因为数据会处于不一致的状态。实际上，GFS 所使用的客户端 lib 在此时会重新尝试执行此次操作。<br>&emsp;&emsp;值得注意的是，这个流程特意将数据流与控制流分开：客户端先向 Chunk Server 提交数据，再将写请求发往 Primary。这么做的好处在于 GFS 能够更好地利用网络带宽资源。<br>&emsp;&emsp;从上述步骤可见，控制流借由写请求从客户端流向 Primary，再流向其他 Secondary Replica。实际上，数据流以一条线性数据管道进行传递的：客户端会把数据上传到离自己最近的 Replica，该 Replica 在接收到数据后再转发给离自己最近的另一个 Replica，如此递归直到所有 Replica 都能接收到数据，如此一来便能够利用上每台机器的所有出口带宽。  </li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式架构 </tag>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bigtable总结(上)</title>
      <link href="/2019/01/26/Architeture%20BigTable/"/>
      <url>/2019/01/26/Architeture%20BigTable/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;<em>既然目标是地平线&emsp;留给世界的只能是背影<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——汪国真</em><br>&emsp;&emsp;本篇博客是我阅读<a href="http://static.usenix.org/events/osdi06/tech/chang/chang_html/?em_x=22" target="_blank" rel="noopener">Bigtable: A Distributed Storage System for Structured Data</a>的论文以及<a href="">相关资料</a>总结而来(我认为阅读原文还有很有必要的)。当然也是我自己的理解，如有问题请邮件联系<a href="mailto:mee.gaoyang@OutLook.com" target="_blank" rel="noopener">mee.gaoyang@OutLook.com</a> 期待能进行相互讨论 :)<br>&emsp;&emsp;Bigtable是一种分布式的管理、组织结构化数据（Structured Data 因为它实际存储的都是字符串）的存储系统，当然他最终的存储仍然使用的是GFS。Bigtable已经实现了以下几个目标wide applicability, scalability, high performance, and high availability。<br>&emsp;&emsp;许多人把Bigtable直接理解为是像SQL这样的数据库再加上一个分布式的特点，我认为他们的差距还是很大的，甚至Bigtable不应该简单的称作数据库，而更应该是一种数据存储系统。以下是Bigtable的几个特点：</p><ol><li>Bigtable没有SQL数据库中像实体完整性、参照完整性、用户定义的完整性这样的关于数据完整性的约束。  </li><li>与之相反Bigtable提供了一个简单的数据模型，利用这个数据模型clients是可以动态的去控制 <strong>数据的存储位置与格式</strong> 。clients也可以自己去推测需要 <strong>数据的位置相关性</strong>（clients to reason about the locality properties of the data represented in the underlying storage.）  </li><li>存储数据的下标是行与列的名字，而这些名字都是字符串的形式。Bigtable不去解析这些字符串，仅仅去存储已经被串行化为字符串的各种结构化数据或者半结构化的数据。  <h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3>&emsp;&emsp;Bigtable是一个稀疏的、分布式的、持久化存储的多维度排序 Map（A Bigtable is a sparse, distributed, persistent multidimensional sorted map. The map is indexed by a row<br>key, column key, and a timestamp; each value in the map<br>is an uninterpreted array of bytes），我们可以使用行关键字、列关键字与时间戳可以定位到一个我们希望得到的数据。就像下面显示的定位数据的方式：  <pre><code>(row:string,  column:string,  time:int64)  →  string</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Bigtable" alt="model.jpg" title="">                </div>                <div class="image-caption">model.jpg</div>            </figure>   </li></ol><p>&emsp;&emsp;Row Key指的是行关键字，Cell 指的是一个数据项。<br>&emsp;&emsp;Bigtable在存储数据时会按照 Cell 的 Row Key 对 Table 进行字典排序（也就是先按Row Key关键字去分为一小组，然后对于这一小组根据其版本号进行一个排序，前面提到的 <strong>位置相关性</strong> 也是基于此），Bigtable提供行级事务的支持，，不支持跨行事务。存储的时候，Bigtable 会把一个 Table 按 Row 切分成若干个相邻的 <strong>Tablet</strong> ，并将划分的 Tablet 分配到不同的 Tablet Server 上存储。因此，clients查询较为接近的 Row Key 时 Cell 落在同一个 Tablet 上的概念也会更大，查询的效率也会更高。<br>&emsp;&emsp;针对于数据权限上的控制，Bigtable 会按照由若干个 Column 组成的 Column Family（列族，如上图中红框里的两列就是一个列簇）对 Table 的访问权限控制。<strong>Column Key</strong> 由 <strong>family:qualifier</strong> 的形式组成，用户在使用前必须首先声明 Table 中有哪些 Column Family，声明后即可在该 Column Family 中创建任意 Column。由于同一个 Column Family 中存储的数据通常属于同一类型，Bigtable 还会对属于同一 Column Family 的数据进行合并压缩（因为Bigtable是稀疏的）。由于 Bigtable 允许用户以 Column Family 为单位为其他用户设定数据访问权限，数据统计作业有时也会从一个 Column Family 中读出数据后，将统计结果写入到另一个 Column Family 中。<br>&emsp;&emsp;Table 中的不同 Cell 可以保存同一份数据的多个版本，以时间戳进行区分。时间戳本质上为 64 位整数，可由 Bigtable 自动设定为数据写入的当前时间（微秒），也可由应用自行设定，但应用需要自行确保 Cell 间不会出现冲突。对于拥有相同 Row Key 和 Column Key 的 Cell，Bigtable 会按照时间戳降序进行排序，如此一来最新的数据便会被首先读取。在此基础上，用户还可以设定让 Bigtable 只保存最近若干个版本的数据或是时间戳在指定时间范围内的数据。  </p><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p>&emsp;&emsp;一个完整的 Bigtable 集群由两类节点组成：Master 和 Tablet Server。<br>&emsp;&emsp;Master 负责检测集群中的 Tablet Server 组成以及它们的加入和退出事件，会将 Tablet 分配至 Tablet Server，并负责均衡 Tablet Server 间的存储负载以及从 GFS 上回收无用的文件。除外，Master 还负责管理如 Table、Column Family 的创建和删除等 Schema 修改操作。<br>&emsp;&emsp;每个 Tablet Server 会负责管理若干个由 Master 指定的 Tablet，负责处理针对这些 Tablet 的读写请求，并负责在 Tablet 变得过大时对其进行切分。<br>&emsp;&emsp;Bigtable 集群会管理若干个 Table，每个 Table 由若干个 Tablet 组成，每个 Tablet 都会关联一个指定的 Row Key 范围，那么这个 Tablet 就包含了该 Table 在该范围内的所有数据。初始时，Table 会只有一个 Tablet，随着 Tablet 增大被 Tablet Server 自动切分，Table 就会包含越来越多的 Tablet。  </p><h3 id="Tablet-定位"><a href="#Tablet-定位" class="headerlink" title="Tablet 定位"></a>Tablet 定位</h3><p>&emsp;&emsp;Bigtable 的 Tablet 之间会形成一个三层结构，具体如下：</p><ol><li>在 Chubby（一种分布式锁） 中的一个 File 保存着 Root Tablet 的位置</li><li>Root Tablet 保存着 METADATA Table 所有 Tablet 的位置</li><li>METADATA Table 中保存着其他所有 Table 的 Tablet 的位置   </li></ol><p><img src="/images/Bigtable tablet-hierarchy.jpg" alt=""><br>&emsp;&emsp;Root Tablet 是特殊的：无论它的体积如何增长都不会被切分，保证唯一。METADATA 中的每一行都代表 Bigtable 中其他 Table 的一个 Tablet，其 Row Key 由该 Tablet 的 Table 名及 Row Key 上限编码而成。除了 Tablet 的位置信息外，METADATA 表也会保存一些其他有用的元信息，例如 Tablet 的事件日志等。<br>&emsp;&emsp;客户端想要定位某个 Tablet 时，便会递归地安装上述层次向下求得位置，并把中间获得的结果缓存在自己的内存中。如果某一时刻客户端发现缓存在内存中的地址已不再有效，它便会再次递归地沿着上述层次向上，最终再次向下求得所需 Tablet 的位置。  </p>]]></content>
      
      
      <categories>
          
          <category> 分布式架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式架构 </tag>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java源码-剖析HashSet</title>
      <link href="/2018/11/30/Java%20HashSet/"/>
      <url>/2018/11/30/Java%20HashSet/</url>
      
        <content type="html"><![CDATA[<p>Map接口中的keySet方法与entrySet方法返回值类型的都是Set。  </p><h3 id="HashSet的Set接口"><a href="#HashSet的Set接口" class="headerlink" title="HashSet的Set接口"></a>HashSet的Set接口</h3><p><strong>Set表示的是没有重复元素、且不保证顺序的容器接口</strong> ，它扩展了Collection接口，Set接口虽然没有再定义一些自己的新的方法，但是Set接口对于Collection接口中的一些方法，它有自己的规范。<br>Set接口的定义为：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span><span class="token punctuation">;</span>    Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">containsAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">retainAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">removeAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与Collection接口中定义的方法是一样的，不过，一些方法有一些不同的规范要求。</p><h4 id="添加元素-add（E-e）方法"><a href="#添加元素-add（E-e）方法" class="headerlink" title="添加元素 add（E e）方法"></a>添加元素 add（E e）方法</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只会添加集合中不存在的元素并返回true，否则直接返回false。  </p><h4 id="批量添加"><a href="#批量添加" class="headerlink" title="批量添加"></a>批量添加</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只添加不重复的，如果集合有变化，返回true，没变化返回false。  </p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><pre class="line-numbers language-java"><code class="language-java">Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>遍历时，元素之间没有特别的顺序。  </p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>与HashMap类似，HashSet的构造方法有：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HashSet的平常用法如下：</p><pre class="line-numbers language-java"><code class="language-java">Set<span class="token operator">&lt;</span>String<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token string">"java"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>String s <span class="token operator">:</span> set<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//输出为：</span>hello java world<span class="token string">"hello"</span>被添加了两次，但只会保存一份。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="hashCode与equals"><a href="#hashCode与equals" class="headerlink" title="hashCode与equals"></a>hashCode与equals</h4><p>与HashMap类似，HashSet要求元素重写hashCode和equals方法，且对两个对象，equals相同，则hashCode也必须相同，如果元素是自定义的类，需要注意这一点。<br>比如说，有一个表示规格的类Spec，有大小和颜色两个属性：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Spec</span> <span class="token punctuation">{</span>    String size<span class="token punctuation">;</span>    String color<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Spec</span><span class="token punctuation">(</span>String size<span class="token punctuation">,</span> String color<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"[size="</span> <span class="token operator">+</span> size <span class="token operator">+</span> <span class="token string">", color="</span> <span class="token operator">+</span> color <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//看一个Spec的Set：</span>Set<span class="token operator">&lt;</span>Spec<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>Spec<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Spec</span><span class="token punctuation">(</span><span class="token string">"M"</span><span class="token punctuation">,</span><span class="token string">"red"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Spec</span><span class="token punctuation">(</span><span class="token string">"M"</span><span class="token punctuation">,</span><span class="token string">"red"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token punctuation">[</span>size<span class="token operator">=</span>M<span class="token punctuation">,</span> color<span class="token operator">=</span>red<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>size<span class="token operator">=</span>M<span class="token punctuation">,</span> color<span class="token operator">=</span>red<span class="token punctuation">]</span><span class="token punctuation">]</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同一个规格输出了两次，为避免这一点，需要为Spec重写hashCode和equals方法，利用IDE开发工具往往可以自动生成这两个方法，比如Eclipse中，可以通过”Source”-&gt;”Generate hashCode() and equals() …”。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>HashSet有很多应用场景，比如说：</p><ol><li>排重，如果对排重后的元素没有顺序要求，则HashSet可以方便的用于排重。</li><li>保存特殊值，Set可以用于保存各种特殊值，程序处理用户请求或数据记录时，根据是否为特殊值，进行特殊处理，比如保存IP地址的黑名单或白名单。</li><li>集合运算，使用Set可以方便的进行数学集合中的运算，如交集、并集等运算，这些运算有一些很现实的意义。比如用户标签计算，每个用户都有一些标签，两个用户的标签交集就表示他们的共同特征，交集大小除以并集大小可以表示他们的相似长度。  </li></ol><h3 id="HashSet实现原理"><a href="#HashSet实现原理" class="headerlink" title="HashSet实现原理"></a>HashSet实现原理</h3><h4 id="内部组成"><a href="#内部组成" class="headerlink" title="内部组成"></a>内部组成</h4><p>HashSet内部是用HashMap实现的，它内部有一个HashMap实例变量，如下所示：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">transient</span> HashMap<span class="token operator">&lt;</span>E<span class="token punctuation">,</span>Object<span class="token operator">></span> map<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>Map有键和值，HashSet相当于只有键(要存的元素、对象)，值都是相同的固定值</strong>，这个值的定义为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>HashSet的构造方法，主要就是调用了对应的HashMap的构造方法，比如：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接受Collection参数的构造方法稍微不一样，代码为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token number">75f</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>也很容易理解，</p><pre class="line-numbers language-java"><code class="language-java">c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token number">75f</span>用于计算initialCapacity，<span class="token number">0.75f</span>是loadFactor的默认值。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>我们看add方法的代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>就是调用map的put方法，元素e用于键，值就是那个固定值PRESENT，put返回null表示原来没有对应的键，添加成功了。HashMap中一个键只会保存一份，所以重复添加HashMap不会变化。</p><h4 id="检查是否包含元素"><a href="#检查是否包含元素" class="headerlink" title="检查是否包含元素"></a>检查是否包含元素</h4><p>代码为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>就是检查map中是否包含对应的键。</p><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>代码为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token operator">==</span>PRESENT<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>就是调用map的remove方法，返回值为PRESENT表示原来有对应的键且删除成功了。</p><p>迭代器</p><p>代码为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>就是返回map的keySet的迭代器。</p><h3 id="HashSet总结"><a href="#HashSet总结" class="headerlink" title="HashSet总结"></a>HashSet总结</h3><p>HashSet实现了Set接口，内部是通过HashMap实现的，这决定了它有如下特点：</p><ol><li>没有重复元素</li><li>可以高效的添加、删除元素、判断元素是否存在，效率都为O(1)。</li><li>没有顺序<br>如果需求正好符合这些特点，那HashSet就是一个理想的选择。  </li></ol><p>HashSet实现了Set接口，不含重复元素，内部实现利用了HashMap，可以方便高效地实现如去重、集合运算等功能。同HashMap一样，HashSet<strong>没有顺序</strong>，如果要保持添加的顺序，可以使用<strong>HashSet的一个子类LinkedHashSet</strong>。Set还有一个重要的实现类，<strong>TreeSet</strong>，它可以排序。HashMap和HashSet的共同实现机制是哈希表，Map和Set还有一个重要的共同实现机制，<strong>树</strong>，实现类分别是<strong>TreeMap</strong>和<strong>TreeSet</strong> 。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> java源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多态（向上转型、动态绑定、instanceof、抽象）</title>
      <link href="/2018/11/14/Java%20Polymorphic/"/>
      <url>/2018/11/14/Java%20Polymorphic/</url>
      
        <content type="html"><![CDATA[<h3 id="多态（向上转型）"><a href="#多态（向上转型）" class="headerlink" title="多态（向上转型）"></a>多态（向上转型）</h3><p>多态：意味着允许不同类的对象对同一消息做出不同的响应。<br>在Java中，按照广泛的范围来说，多态  可以分为 <strong>编译时多态</strong>（也叫设计时多态，<br>一般通过方法的重载来实现） 与 <strong>运行时多态</strong>（直到ｊａｖａ程序运行时候，系统才能根据调用方法的实例的类型来去决定去具体调用哪个方法）。<br>我们在Java中所说的多态就是<strong>运行时多态</strong>，在程序运行时动态决定调用哪个方法。<br>两个必要条件：  </p><ul><li>满足继承关系  </li><li>父类引用指向子类对象  </li></ul><p>定义父类Animal：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> month<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>  <span class="token keyword">public</span>  <span class="token function">Animal</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span><span class="token keyword">int</span> month<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>month <span class="token operator">=</span> month<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//name与month相对应的get、set方法</span>  <span class="token comment" spellcheck="true">//......</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"动物吃东西"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义子类Cat：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">double</span> weight；  <span class="token keyword">public</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token function">Cat</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span><span class="token keyword">int</span> month<span class="token punctuation">,</span><span class="token keyword">double</span> weight<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span>month<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//this.setMonth(month);</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//weight的get与set方法</span>  <span class="token comment" spellcheck="true">//......</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小猫在跑"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小猫吃鱼"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义子类Dog：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>  <span class="token keyword">private</span> String sex<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token function">Dog</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span><span class="token keyword">int</span> month<span class="token punctuation">,</span><span class="token keyword">double</span> sex<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setMonth</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//sex的get与set方法</span>  <span class="token comment" spellcheck="true">//......</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小狗睡觉"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小狗吃骨头"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写测试类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span> <span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    Animal one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Animal two <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//向上转型、隐式转型、自动转型》》父类引用指向子类实例，小类型转向大类型。</span>    Animal three <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    one<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    two<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    three<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><blockquote><p>动物吃东西<br>小猫吃鱼<br>小狗吃骨头  </p></blockquote><pre class="line-numbers language-java"><code class="language-java">Animal two <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此处为向上转型、隐式转型、自动转型 ———&gt;&gt; 父类引用指向子类实例，小类型转向大类型。可以调用子类重写父类的方法以及父类派生的方法。但是子类特有的方法无法使用。</p><p><strong>向上转型总结:</strong>  </p><blockquote><p>  向上转型是安全的,因为任何子类都继承并接受了父类的方法。从例子中也可以理解,所有的狗狗都属于狗的父类一动物 ,这是可行的,但是向下转型则不行,若说所有的动物都是狗狗就不成立了。(所以向下转型要通过强制类型转换)</p></blockquote><p><strong>向上转型应用：</strong>  </p><ol><li>当一个子类对象向上转型父类类型以后,就被当成了父类的对象,所能调用的方法会减少,只能调用子类重写了父类的方法以及父类派生的方法(如set、get方法),而不能调用子类独有的方法。</li><li>父类中的静态方法不允许被子类重写。<br>如父类Pen中含有静态方法draw()</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"笔可以画画"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当子类Pencil中也定义同名方法时，此时draw()算做Pencile类自己特有的方法：  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"铅笔可以素描"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>测试类：</p><pre class="line-numbers language-java"><code class="language-java">Pen pc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pencil</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//向上转型</span>pc<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果如下，也就是实际上调用的是父类的静态方法deaw()</p><blockquote><p>笔可以画画  </p></blockquote><p>下面更改动物例子中测试类Test的编写：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span> <span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    Animal one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Animal two <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Animal three <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Cat temp <span class="token operator">=</span> <span class="token punctuation">(</span>Cat<span class="token punctuation">)</span>two<span class="token punctuation">;</span>    temp<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">Cat temp <span class="token operator">=</span> <span class="token punctuation">(</span>Cat<span class="token punctuation">)</span>two<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此处为向下转型、强制类型转换 ———&gt;&gt;子类引用指向父类对象，此处必须进行强转，可以调用子类特有的方法。<br>不能Dog temp = (Dog)two；  </p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>two在引用的时候，指向的是Dog的实例空间，所以Cat temp = (Cat)two;  相当于还原为原来的类型。为了避免编写程序时出现上面Dog temp = (Dog)two；这种情况，可以用<strong>instanceof</strong> 运算符。<br>instanceof：<strong>判断e对象是否是E类的实例</strong>。如果是返回true。使用如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>two <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  Cat temp <span class="token operator">=</span> <span class="token punctuation">(</span>Cat<span class="token punctuation">)</span>two<span class="token punctuation">;</span>  temp<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  temp<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  temp<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>多态的实现可以通过向上转型和动态绑定机制来完成，问上转型实现了将子类对象向上转型为父类类型,而动态绑定机制能识别出对象转型前的类型,从而自动调用该类的方法，两者相辅相成。<br><strong>动态绑定:</strong><br>绑定就是将一个方法调用同一个方法所在的类连接到一起就是绑定。绑定分为静态绑定和动态绑定两种。<br>静态绑定:在程序运行之前进行绑定(由编译器和链接程序完成的),也叫做前期绑定。<br>动态绑定:在程序运行期间由JVM根据对象的类型自动的判断应该调用哪个方法,也叫做后期绑定。<br><strong>静态绑定的例子:</strong> 如有一类Human,它派生出来三个子类Chinese类、American 类和British类,三个子类中都重写了父类中的方法speak( ),在测试类中用静态绑定的方式调用方法speak( )。  </p><pre class="line-numbers language-java"><code class="language-java">Chinese ch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Chinese</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ch<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>American am <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">American</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>am<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>British br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">British</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>br<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的调用方式是在代码里指定的，在编译时编译器就知道ch.speak()调用的是Chinese的speak（）。</p><p><strong>动态绑定的例子</strong>:对测试类进行修改如下。  </p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//生成父类对象数组,数组长度为5  </span>Human<span class="token punctuation">[</span><span class="token punctuation">]</span> human<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Human</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>human<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  n<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//随机产生 从0到2中一个数</span>  <span class="token keyword">switch</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>human<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Chinese</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>human<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">American</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>human<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">British</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//循环输出，循环体中每个对象分别调用speak()方法</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span> human <span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  human<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时, Human类中随机生成Chinese类、American 类和British类的对象,编译器不能根据代码直接确定调用哪个类中的speak()方法,直到运行时才能根据产生的随机数n的值来确定humani到底代表哪一个子类的对象,这样才能最终确定调用的是哪个类中的speak()方法。  </p><h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p>最开始写的Animal类中的eat()方法真的有用吗，Animal类实例化有用吗？虽然语法本身没有问题，但是实例化的对象并没有意义， 程序逻辑存在一些问题。<br><strong>abstract</strong> 解决了上面的问题，使程序员编写符合实际意义的有效代码。(abstract 关键字位置可以与public位置交换）<br><strong>基本概念</strong><br>  在面向对象的概念中，所有的对象都是通过类来描述的，但不是所有的类都是用来描述对象的，当一个类中没有包含足够的信息以描述一个具体的对象时，这样的类就是抽象类。  </p><p><strong>特点</strong>    </p><ul><li>类设置为抽象类时，就不能再被实例化，只能作为其它类的父类，<strong>但可以改过向上转型，使其指向子类的实例</strong>。    </li><li>抽象方法只能有声明，不能有实现，即仅有方法头，而没有方法体与操作实现。（如：abstract double area(); ）   </li></ul><p><strong>定义抽象类的意义</strong></p><ul><li>为其子类提供一个公共的类型（父类引用指向子类对象，向上转型）</li><li>封装子类中的重复内容（成员变量与方法）  </li><li>将父类设置为抽象类后，既可以借由父子继承关系限制子类的设计随意性，在一定程度避免了无意义父类的实例化。  </li></ul><p><strong>注意</strong></p><ul><li>含有抽象方法的类，必须被定义为抽象类。  </li><li>抽象类不一定包含抽象方法。（抽象方法在子类中必须被实现）  </li><li>抽象类中的成员方法可以包含一般方法与抽象方法。  </li><li>即使抽象类中不包含抽象方法，抽象类也不能被实例化，抽象类的构造方法主要是用于被其子类调用。</li><li>一个类继承抽象类后，必须实现其所有抽象方法，否则要被定义为抽象类，不同子类对父类的抽象方法可以根据实际有不同的实现。  </li><li>即使父类是具体的， 但其子类也可以是抽象的。例如Object是具体的，但可以创建抽象子类。  </li><li>abstract方法不能用static、private修饰；对于abstract类，不能使用final修饰，因为final关键字使类不可继承，而abstract修饰的类如果不能被继承则没有意义。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java修饰符的限制范围</title>
      <link href="/2018/11/09/Java%20Modifier/"/>
      <url>/2018/11/09/Java%20Modifier/</url>
      
        <content type="html"><![CDATA[<p>以下为Java控制可见性的四个修饰符的总结  </p><ol><li>仅对本类可见 – private  </li><li>对本包可见 – 默认（无修饰符）</li><li>对本包及所有子类可见 – protected</li><li>对所有类可见 – public</li></ol><table><thead><tr><th>访问修饰符</th><th>本类</th><th>同包</th><th>子类</th><th>其它</th></tr></thead><tbody><tr><td>private</td><td>Y</td><td></td><td></td><td></td></tr><tr><td>默认</td><td>Y</td><td>Y</td><td></td><td></td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td></td></tr><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown常用语法</title>
      <link href="/2018/10/10/mdyufa/"/>
      <url>/2018/10/10/mdyufa/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span>  os  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="命令面板"><a href="#命令面板" class="headerlink" title="命令面板"></a>命令面板</h5><blockquote><p>cmd-shift-P</p></blockquote><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><blockquote><p>在行末加两个空格 再回车</p></blockquote><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>两种语法形式 类Setext与类atx<br>类 Setext形式以底线形式,利用 = (最高阶标题) 和 - (第二阶标题)</p><h6 id="Setext-例"><a href="#Setext-例" class="headerlink" title="Setext 例:"></a>Setext 例:</h6><blockquote><h1 id="This-is-an-H1"><a href="#This-is-an-H1" class="headerlink" title="This is an H1"></a>This is an H1</h1></blockquote><h2 id="This-is-an-H2"><a href="#This-is-an-H2" class="headerlink" title="This is an H2"></a>This is an H2</h2><h6 id="atx-例-1-6级"><a href="#atx-例-1-6级" class="headerlink" title="atx 例: (1-6级)"></a>atx 例: (1-6级)</h6><blockquote><h1 id="atx"><a href="#atx" class="headerlink" title="atx"></a>atx</h1><h2 id="atx-1"><a href="#atx-1" class="headerlink" title="atx"></a>atx</h2><h3 id="atx-2"><a href="#atx-2" class="headerlink" title="atx"></a>atx</h3><h4 id="atx-3"><a href="#atx-3" class="headerlink" title="atx"></a>atx</h4><h5 id="atx-4"><a href="#atx-4" class="headerlink" title="atx"></a>atx</h5><h6 id="atx-5"><a href="#atx-5" class="headerlink" title="atx"></a>atx</h6></blockquote><h4 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h4><p>在每行前加 &gt; 区块引用  支持多重嵌套,只用多加&lt;即可</p><blockquote><p>区块引用</p><blockquote><p>123</p></blockquote></blockquote><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>+与-  无序<br>数字接一个英文句点  有序</p><ul><li>Red</li><li>Green</li></ul><ol><li>Red</li><li>Green</li></ol><h4 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h4><p>缩进4个字符即可<br>一个代码区块会一直持续到没有缩进的那一行</p><pre><p>private V getForNullKey() {<br>    if (size == 0) {<br>        return null;<br>    }<br>    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {<br>        if (e.key == null)<br>            return e.value;<br>    }<br>    return null;<br>}</p></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java的非静态方法调用过程</title>
      <link href="/2018/09/25/Java%20CallFunction/"/>
      <url>/2018/09/25/Java%20CallFunction/</url>
      
        <content type="html"><![CDATA[<p>Java中非静态方法的调用过程，即通过对象来调用方法的过程主要有以下几个步骤。<br>假设要调用x.f(args), <strong>隐式参数</strong> x 声明为类C的一个对象。具体调用流程如下：</p><h3 id="1-编译器得到所有可能被调用的候选方法。"><a href="#1-编译器得到所有可能被调用的候选方法。" class="headerlink" title="1. 编译器得到所有可能被调用的候选方法。"></a>1. 编译器得到所有可能被调用的候选方法。</h3><p>编译器查看对象的声明类型与方法名。假设调用x.f(param)，且隐式参数x声明为C类的对象。需要注意的是方法的<strong>重载</strong>（Overload）即：有可能存在多个名字为f，但是<strong>参数类型不一样</strong>的方法。例如，可能存在f(int)和f(String)。编译器将会一一列举所有类C和其超类中访问属性为public且名为f的方法（超类的私有方法不可访问）。</p><h3 id="2-重载解析（编译器得到需要调用的具体的一个方法）"><a href="#2-重载解析（编译器得到需要调用的具体的一个方法）" class="headerlink" title="2. 重载解析（编译器得到需要调用的具体的一个方法）"></a>2. 重载解析（编译器得到需要调用的具体的一个方法）</h3><p>接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程称为重载解析。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。<br>需要注意的是int可以转换为double，子类可以转换为父类，</p><h3 id="3-静态绑定与动态绑定"><a href="#3-静态绑定与动态绑定" class="headerlink" title="3. 静态绑定与动态绑定"></a>3. 静态绑定与动态绑定</h3><p>如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为静态绑定。与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。</p><h3 id="4-使用动态绑定调用方法"><a href="#4-使用动态绑定调用方法" class="headerlink" title="4. 使用动态绑定调用方法"></a>4. 使用动态绑定调用方法</h3><p>当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实例类型最合适的那个类的方法。假设 x 的实际类型是D（子类），它是C类的子类，我们要调用f(String)。如果D类定义了方法f(String)，就直接调用它；否则将在D类的超类中寻找f(String)，以此类推。<br>每次调用方法都要进行方法搜索，时间开销相当大。因此，虚拟机预先为每个类创建一个方法表，其中列举了所有方法的签名和实际调用的方法。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。  </p><blockquote><p>动态绑定有一个很重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展。假设新增一个类E，并且变量e可能引用这个类的对象，我们不需要对包含调用e.f()方法进行重新编译。如果e引用了一个E类的对象，就会自动地调用E.f()方法。  </p></blockquote><blockquote><p>需要注意的是：在 <strong>覆盖</strong>（Override）一个方法的时候，子类方法的可见性不能低于超类方法的可见性。<strong>特别</strong>是如果超类的方法时public，那么子类方法一定要声明为public，否则编译器解释为默认的就会出错。  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
